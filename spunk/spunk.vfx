\ ------------------------------------------------------------------------------
\ spunk
\ Non-scrolling 2D open world game framework
\ ------------------------------------------------------------------------------
 
\ =============================================================================
\ Variables
\ =============================================================================

1024 constant #rooms
tmw tmh * cells constant /screen

|| : ?flip  4 rnd 24 << or ;
|| : randoms,  for 256 rnd ?flip , loop ;
create mram /screen cell/ #rooms * randoms,

mram value playfield
variable room#

\ =============================================================================
\ Low-level stuff
\ =============================================================================

: roombase$  room# @ s" map\room" find-dat-path f" %s%03n" >pad count ;
: room-datfile  roombase$ f" %s.dat" ;
: room-scnfile  roombase$ f" %s.vfx" ;
: screen  1023 and /screen * mram + ;

\ =============================================================================
\ Stashing actors between rooms
\ =============================================================================

class: %actor
    prop r#  \ the room each actor was in
             \ -1 = persist
             \ -2 = discard
    prop a#  \ we also try to restore the ordering using actor#
class;  

|| : belong? ( - flag )
    r# @ room# @ =   r# @ -1 = or ;

: unstashed ( %actor - actor' )
    as>
        a# @ priority
        *actor 
        me over /actor move
        en off ;

: unstash ( %actor - )
    unstashed drop ;

: stashed ( %actor - actor' )
    {
        r# @ -1 <> if room# @ r# ! then
        me actor# a# !   *temp    me over /actor move   me unload 
    } ;

: stash ( %actor - )
    stashed drop ;

: throwaway ( - )
    -2 r# ! ;

%timer :: init ( - )
    throwaway ;

: persist ( - )
    -1 r# ! ;

: stow ( - )
    actives>   r# @ -2 = if me unload else me stash then ;

: takeout ( - )
    temps>   belong? -exit   me unstash ;

borrow scene>> actor-instance

|| : temp-instance ( class - %actor )
    actor-instance stashed ;

: load&stow ( scene - )
    \ load actors from disk to temps
    as> desbin> ['] into-me desbin+  ['] temp-instance desmulti+ ;

\ =============================================================================
\ Room control
\ =============================================================================

variable load-room-chain

: room ( n - ) 1023 and room# ! room# @ screen to playfield ;
: +room ( n - ) room# @ + room ;

: warp ( n - )
    1023 and
    ." WARPING TO ROOM " dup . cr
    stow  room  takeout
    load-room-chain do-chain ;

: +warp ( n - )
    room# @ + 1000 + 1000 mod warp ;

: ?read ( dest len path len - )
    2dup file-exists? if read else 2drop 2drop then ;

: load-room ( path len dest-a - )
    /screen 2swap ?read ;

: revert-bg ( - )
    room-datfile playfield load-room ;

: revert ( - )
    revert-bg
    clear-stage
    room-scnfile ?included
    load-room-chain do-chain ;

: load-world ( - )
    clear-temps #rooms for i room revert stow loop ;

: clear-world ( - )
    mram /screen #rooms * erase 
    clear-temps 
    clear-stage ;

\ =============================================================================
\ Read/write the background
\ =============================================================================

: colrow  ( - c r ) x 2@`` xy>cr ;
: +tile@  ( c r - n ) colrow 2+`` playfield` spot c@ ;
: +tile!  ( n c r - ) colrow 2+`` playfield` spot c! ;
: ftile@  ( f: c r - n ) 2f>p xy>cr`` playfield` spot c@ ;
: ftile!  ( n f: c r - ) 2f>p xy>cr`` playfield` spot c! ;

\ =============================================================================
\ Rendering
\ =============================================================================

\ A word could change playfield and we call BG multiple times
\ to draw multiple layers.
\ Ex:
\ variable layer#
\ 2 /screen array layer-array
\ : layer dup layer# ! layer-array [] to playfield ;
\ : layers 0 layer bg 1 layer bg ;
: bg  0 0 at playfield lay ;
