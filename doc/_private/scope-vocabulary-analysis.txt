# Scope and Vocabulary System Analysis

## Vocabulary Naming Convention

The `~` in vocabulary names is string concatenation, not a dispatch operator. In `wlname` (lines 11-13), it appends "~" to the current source filename to create a vocabulary name:

```forth
: wlname
    CurrSourceName -path -ext wl$ place
    wl$ s" ~" $+ count ;
```

So `myfile.vfx` becomes `myfile~` as the vocabulary name. Words like `myclass~someword` are regular word lookups in the `myclass~` vocabulary.

## Vocabulary Context Switching

The `scope` definition (lines 16-19) performs vocabulary installation and context switching:

```forth
: scope ( - )
    only forth definitions
    s" vocabulary " >pad wl$ count $+ count evaluate
    does> only forth definitions also @ context ! ;
```

The `scope` word:
1. Creates a vocabulary with the computed name
2. Installs a runtime behavior (the `does>` part) that switches the search context

When executing a word created by `scope`, the `does>` clause:
- Resets search order (`only forth definitions`) 
- Adds the vocabulary to search context (`also @ context !`)

## Context Replacement vs Import

The vocabulary system performs context replacement, not importing. The `does>` behavior:

```forth
only forth definitions also @ context !
```

This replaces the entire search order with just `forth` plus the target vocabulary. Access to previously available vocabularies is lost - the operation is not additive.

This is vocabulary switching or context substitution - temporarily switching to operate within a specific vocabulary's namespace, losing access to the previous context until explicitly switching back.

## Terminology

Precise Forth terms:
- **Vocabulary**: Named collection of word definitions
- **Wordlist**: The underlying data structure  
- **Search order**: The stack of vocabularies Forth searches through
- **Context**: Current vocabulary for new definitions

## Vocabulary System as Static Scoping Foundation

The Forth vocabulary system provides primitives to build static scoping, but is fragile due to:

**Manual search order management** - Explicit management of `only`, `also`, `previous` required. Missed cleanup corrupts search order.

**No automatic restoration** - Unlike lexical scoping where context automatically restores when exiting blocks, Forth vocabularies require manual unwinding.

**Global state mutation** - Search order is global mutable state; any word can accidentally break scoping.

**Dynamic vs static mismatch** - Runtime search order manipulation used to achieve compile-time scoping guarantees.

The `preserve-order` mechanism (lines 50-56) attempts to reduce brittleness by automatically saving/restoring search order around includes, but remains a workaround for fundamental limitations.

## Requirements for Lexical Environments

Automatically-managed lexical environments would require implementation in the Forth compiler itself, specifically in word compilation and resolution mechanisms.

**Required compiler changes:**

**Lexical symbol table** - Compiler maintains nested scope stack during compilation, not runtime search order manipulation.

**Compile-time resolution** - `vocabulary::word` resolved to absolute addresses during compilation, not dynamic lookup.

**Automatic scope management** - Constructs automatically push/pop lexical environments without exposing search order.

**Static binding** - Word references bound at compile-time to specific vocabulary locations, eliminating runtime search.

This requires moving from Forth's late-binding vocabulary system to early-binding lexical scoping - a fundamental architectural change.

## Flat Scoping Approach

The current two-level approach avoids complexity pitfalls:

- **Global** (public) scope
- **File-local** (private) scope  

Benefits:
- **No nesting fragility** - Cannot get lost in deep vocabulary stacks
- **Simple mental model** - Public (everyone sees) or private (just this file)
- **Predictable search order** - At most two vocabularies: `forth` + current file's private vocabulary
- **Easy restoration** - `public` always returns to known good state
- **Minimal state** - `preserve-order` mechanism handles only one nesting level

This achieves 80% of scoping benefits with 20% of the complexity, avoiding "namespace spaghetti" from deeper hierarchies.