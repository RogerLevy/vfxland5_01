Asset System Final Design
=========================

Overview
--------
The asset system provides a Smalltalk-like transparent persistence model where assets
(tilesets, scenes, animations, etc.) exist as live objects during development and 
can be committed to disk when ready. At startup, assets are reconstructed from their
persisted state.

Core Concepts
------------
- Assets are live objects in a working set during development
- Changes accumulate in memory until explicitly committed
- Startup reconstructs the working set from persisted files
- Each asset type has its own directory (e.g., dat/tiles/, dat/scn/)
- Asset words provide direct access to asset objects

Asset Protocol (Methods)
-----------------------
Each asset class implements these methods:

    :: cleanup ( - )        
        Free external resources (safe to call on empty assets)
        
    :: setup ( - )          
        Create/recreate external resources using stored parameters
        
    :: gen-path ( <name> - path )
        Generate file path from parsed name (class-specific directory)
        
    :: save-params ( - )    
        Serialize to file (automated via serialization system)
        
    :: load-params ( - )    
        Deserialize from file (automated via serialization system)
        
    :: post-load ( - )      
        Optional hook for custom logic after deserialization

Core Operations
--------------
1. Development time: Create or update assets via >asset words
2. Startup time: Load assets from disk via load-asset
3. Commit time: Persist dirty assets via commit-assets

Parameter Handling Problem
-------------------------
Different asset types require different parameters:
- Tileset: bitmap-id, tile-width, tile-height
- Scene: (no parameters)
- Animation: frame-count, duration

This creates a challenge for the apply-params method which needs to handle
variable numbers of parameters while maintaining consistent method signatures.


Option 1: Allow Variable Parameters
===================================

Design:
    :: apply-params ( ...params - )
        Each class consumes the appropriate number of parameters

Implementation:
    tileset :: apply-params ( bmpid w h - )
        h ! w ! bmp ! ;
    
    scene :: apply-params ( - )
        ;  \ No params
    
    : >asset ( ...params class <name> -- )
        [core logic]
        apply-params
        [cleanup/setup/mark-dirty]

Usage:
    mybmp.png 16 16 tileset >asset mybmp.ts
    scene >asset room1.scn

Pros:
- Simple and direct
- Follows existing VFX Forth patterns (EXECUTE, N>R, etc.)
- No extra complexity

Cons:
- Violates fixed-parameter principle for methods
- No runtime validation of parameter count
- Stack diagram is ambiguous: ( ... - )


Option 2: Add Parameter Count
=============================

Design:
    :: apply-params ( ...params n - )
        Each class validates and consumes n parameters

Implementation:
    tileset :: apply-params ( bmpid w h 3 - )
        drop  \ Drop count after validation
        h ! w ! bmp ! ;
    
    scene :: apply-params ( 0 - )
        drop ;  \ No params
    
    : >asset ( ...params n class <name> - )
        [core logic]
        apply-params
        [cleanup/setup/mark-dirty]

Usage:
    mybmp.png 16 16  3 tileset >asset mybmp.ts
    0 scene >asset room1.scn
    64 0.5  2 animation >asset walk.anim

Pros:
- Explicit parameter count enables validation
- Self-documenting interface
- Stack diagram is clear: ( ...n-items n - )

Cons:
- Extra parameter to specify
- Still technically variable parameters
- Slight usage complexity


Option 3: Split into ?asset and manifest
========================================

Design:
    Separate asset acquisition from property setting and finalization

Implementation:
    : ?asset ( class <name> -- existed? obj )
        parse-name 2dup find-asset-word if
            2drop execute @ true swap    \ Get existing
        else
            over instantiate              \ Create new
            dup create-asset-word
            dup gen-path over >path !
            false swap
        then ;
    
    : manifest ( existed? obj -- )
        swap if dup cleanup then         \ Cleanup if existed
        setup mark-dirty ;                \ Setup and mark dirty
    
    : >tileset ( bmpid w h <name> -- )
        tileset ?asset
        [[ h ! w ! bmp ! me ]]    \ Direct field access
        manifest ;
    
    : >scene ( <name> -- )
        scene ?asset
        drop                             \ No fields to set
        manifest ;

Usage:
    mybmp.png 16 16 >tileset mybmp.ts
    >scene room1.scn

Pros:
- No variable parameters in methods
- Clean separation of concerns
- Direct field access is idiomatic Forth
- Each asset type word is self-contained
- Pattern reads naturally: "get asset, set fields, manifest"

Cons:
- Requires two words (?asset/manifest) instead of one
- Slightly more complex implementation
- Pattern must be followed consistently


Recommendation
-------------
Option 3 (?asset/manifest split) provides the cleanest design:
- Maintains method signature consistency
- Separates concerns clearly
- Provides maximum flexibility
- Follows Forth idioms (direct field access)
- Makes the pattern explicit and readable

The slight increase in implementation complexity is offset by the clarity
and maintainability of the resulting code.


Example Complete Implementation (Option 3)
==========================================

class: tileset
    is-a asset
    var bmp  var w  var h  var tiles
    
    :: cleanup ( - )
        tiles @ ?dup if destroy then ;
        
    :: setup ( - )
        bmp @ w @ h @ slice-tiles ;
        
    :: gen-path ( <name> - path )
    bl parse f" dat/tiles/%s" ;
        
    \ save-params/load-params handled by serialization
class;

: >tileset ( bmpid w h <name> -- )
    tileset ?asset
    [[ h ! w ! bmp ! me ]]
    manifest ;

: load-asset ( path class -- )
    \ Startup/load time
    materialize >r           \ Create asset
    r@ load-params          \ Read params from file
    r> setup ;              \ Create resources (no cleanup needed)

: load-tileset ( path -- )
    tileset load-asset ;

: commit-asset ( asset -- )
    \ Commit time
    dup save-params
    clear-dirty ;

: commit-assets
    ['] commit-easset all-dirty-assets each ;