Asset Extension Filtering Approaches
====================================

Problem: load-assets needs to filter files by extension based on asset class
so it doesn't try to load incompatible files.


Option 1: Class Method for Extensions
-------------------------------------
Each class declares its supported extensions as a string.

    trait: asset
        :: extensions ( - a len )  \ Return supported extensions
            s" .dat" ;              \ Default extension
    trait;

    scene :: extensions ( - a len )
        s" .scn" ;

    tileset :: extensions ( - a len )  
        s" .ts" ;

    bitmap-asset :: extensions ( - a len )
        s" .png .jpg .bmp" ;       \ Multiple extensions

    : load-assets ( path-a path-len class - )
        {: path-a path-len class0 :}
        path-a path-len [: ( fn len )
            2dup extension           \ Get file extension
            class0 >extensions @ execute  \ Get class extensions
            search if                 \ Extension supported?
                class0 load-asset drop
            else 2drop then
        ;] each-file ;

Pros: Simple, declarative
Cons: String searching for multiple extensions


Option 2: Pattern-Based with Glob
---------------------------------
Each class provides a file pattern for matching.

    trait: asset
        :: file-pattern ( - a len )
            s" *.dat" ;             \ Default pattern
    trait;

    scene :: file-pattern ( - a len )
        s" *.scn" ;

    bitmap-asset :: file-pattern ( - a len )
        s" *.{png,jpg,bmp}" ;       \ Multiple extensions

    : load-assets ( path-a path-len class - )
        >r 2dup r@ >file-pattern @ execute
        concat                       \ "dat/gfx/*.png"
        r> swap ['] load-asset each-matching-file ;

Pros: Works with existing glob/file-matching utilities
Cons: Requires glob pattern support


Option 3: Filter Predicate
--------------------------
Each class implements a predicate to test file acceptance.

    trait: asset
        :: accepts? ( fn len - flag )
            \ Default: accept .dat files
            extension s" .dat" compare 0= ;
    trait;

    bitmap-asset :: accepts? ( fn len - flag )
        extension
        dup s" .png" compare 0= if 2drop true exit then
        dup s" .jpg" compare 0= if 2drop true exit then
        s" .bmp" compare 0= ;

    : load-assets ( path-a path-len class - )
        {: path-a path-len class0 :}
        path-a path-len [: ( fn len )
            2dup class0 >accepts? @ execute if
                class0 load-asset drop
            else 2drop then
        ;] each-file ;

Pros: Most flexible - can check extensions, patterns, file size, etc.
Cons: Slightly more code per class


Recommendation
-------------
Option 3 (accepts? predicate) provides maximum flexibility while keeping
the interface clean. It can handle complex filtering logic beyond just
extensions if needed, and reads naturally: "does this class accept this file?"