Working name: Nib 2.0

trait: object%
    system trait that all classes have.

\ Compile-time object life-cycle methods
\ --------------------------------------

: setup: ( #params class - <code> ; ) ( ... - )
    \ special object% method with variable number of params

protocol: teardown ( - )
    \ object% method

\ Run-time object life-cycle methods
\ ----------------------------------

protocol: init ( - )
    \ object% method

protocol: deinit ( - )
    \ object% method

\ Instantiation
\ -------------

: object ( class - object )
    \ compile dictionary instance.
    \ executes SETUP.
    
: $create-object ( class does-xt|0 name len - object ) ( - object ) 
    \ create named dictionary instance.
    \ executes SETUP.
    \ does-xt supplies optional DOES> behavior that overrides the secondary stack diagram .

: create-object ( class does-xt|0 - <name> ) ( - object )
    \ create named dictionary instance (convenience word for BL PARSE $CREATE-OBJECT).
    \ executes SETUP.
    \ does-xt supplies optional DOES> behavior that overrides the secondary stack diagram .
    
: <object ( a size class - object )
    \ assign class to user-allocated memory - size provided for validation.

: <setup ( a size class - object )
    \ SETUP instance in user-allocated memory - size provided for validation.

\ Field definition
\ ----------------

: field ( n size - <name> n+size ) ( - field ) ( object - field )
    \ define an instance accessor (any size) and offset calculator (>NAME).
    \ also defines an external address.
    \ public or private depending on CURRENT.
    
: property ( - <name> ) ( - field ) ( object - field )
    \ define an instance accessor (cell) and offset calculator (>NAME).
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ only definable for traits.
    \ always public.
    
: var ( - <name> ) ( - field ) ( object - field )
    \ define a shared instance accessor (cell) and offset calculator (>NAME) if they have not been already defined.
    \ adds a shared field to the current field space.
    \ the current field space is determined by the current object's class.
    \ if a field space is not defined for the object's class, throw an error.
    \ always public.

: static ( - <name> ) ( - field ) ( class - field )
    \ define a shared class accessor (cell) and offset calculator (>NAME) if they have not been already defined.
    \ statics are global across classes (every class is a fixed size).
    \ the class accessor references the current object's class, while the offset calculator takes a class on the stack.
    \ always public.

\ Class definition
\ ----------------

: class: ( - <name> )
    \ define a class if it has not already been defined.
    \ set as current class for defining members.
    \ paired with CLASS;
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ always public?

: defaults ( - a )
: >defaults ( class - a )
    \ pointer to template (object) for current/given class; if it doesn't exist when invoked, create it.

: field-space ( n - )
    \ create a field space for the current class, fixing the class to the given size.

: trait: ( - <name> )
    \ define a trait - if it has not already been defined - which is a class that can be mixed into other classes.
    \ set as current class for defining members.
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ paired with TRAIT;
    \ traits cannot "inherit" other traits.
    \ always public
    
: is-a ( - <classifier> )
    \ adds trait or extension to current class.
    \ if a wrong data type is given, throw an error.
    \ sets a bit in a 1024-bit static for validation and logic.
    \ if the classifier is an extension, checks that the current class is derived from a related class and throws an error if not.

: is? ( object classifier - b )
    \ check object for class, trait, or extension.

: derive ( class - )
    \ copy the given class (statics and defaults template) to the current class.
    \ if given item is any other data type, throw an error.
    
: protocol: ( - <name> <default-code> ; ) ( ... object - ... )
    \ define a trait or extension method (takes up a static) if it has not already been defined.
    \ must have a stack diagram, which gets stored in the protocol.
    \ is associated with the current trait/extension's bit offset.
    \ always public.
    
: :: ( class - <name> <code> ; ) ( ... object - ... )
    \ define given class's method implementation.
    \ the stack diagram is validated against the protocol's stored one.
    \ the class is validated against the protocol.

: extension: ( extended-class - <name> ) ( - extension )
    \ define an extension for a specific class - if it has not already been defined.
    \ set as current extension for defining members (vars, protocols).
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield for runtime queries.
    \ paired with EXTENSION;
    \ extensions are class-specific feature modules that add capabilities to a single class hierarchy.
    \ vars defined in extensions are added to the extended class's field space.
    \ protocols defined in extensions can be implemented by classes that enable the extension via IS-A.
    \ always public.

: on-derive: ( - <code> ; ) ( original-class derived-class - )
    \ define post-derive behavior for the current class.

\ example 1: arrays with collection trait
\ ---------------------------------------

public

trait: collection%
    property max-items
    property item-size
    property item-count
    property items
    
    protocol: each ( xt - ) ( a - )
        drop ;
    
trait;

class: array%
    is-a collection%
class;

class: slice% 
    is-a collection%
class;

class: stack%
    is-a collection%
class;

|| : /stack ( count item-size - )
    2dup item-size ! max-items !
    align here items ! * allot&erase ;

2 stack% setup: ( max-count item-size - )
    /stack ;

2 array% setup: ( max-count item-size - )
    /stack max-items @ item-count ! ;

: #items ( collection - n )
    's item-count @ ;

array% :: each ( xt - ) ( a - ) \ stack diagram(s) must match the protocol's exactly
    ... ; 


\ example 2: actors with shared field space
-------------------------------------------

trait: drawable%
    protocol: draw ( - )
        ;
trait;

class: actor%
    is-a drawable%
    512 field-space
    var x
    var y
    var vx
    var vy
    var bmp
    \ ...
    static oexec-error-handler ( xt n - )
    on-derive: ( original-class derived-class - )
        2drop 
        private ;  \ set up private vocabulary
class;

\ set static; DERIVE carries it over 
' actor-oexec-error-handler actor% 's oexec-error-handler !

actor% :: draw ( - )
    sprite ;

class: ship%
    actor% derive
    var energy
    var lives
class;

\ kinetic.vfx
actor% extension: kinetic%
    var rad
    var mass
    var ang
    protocol: on-bounce ( object - )
        drop ;
extension;

\ enemy1.vfx
require kinetic.vfx  \ more likely to be in common.vfx to avoid repetition and false cross-app modularity, but this is just an example

class: enemy1%
    actor% derive
    is-a kinetic%   

    on-derive: ( original-class derived-class - )
        nip
        dup register-enemy-class
        auto-bitmap ;
class;




conversation notes
------------------

> would this system be potentially too difficult for Claude to code in effectively without all of the context of
   this conversation?  it is very different from conventional OOP now.

● You raise a valid concern. This system is quite different from conventional OOP and has several non-standard
  concepts:

  Complexity factors:
  - Multiple field types (field, property, var, static) with different allocation rules
  - Dual capability system (traits vs extensions) with same syntax (is-a) but different semantics
  - Field spaces - shared offset allocation across object instances
  - Protocol validation with stack diagram matching
  - Deferred property allocation based on field space presence

  However, I think Claude could handle it with proper documentation because:

  1. Consistent patterns - Once you understand is-a/is? and the field types, the system is quite regular
  2. Clear separation of concerns - Each concept has a distinct purpose (traits = interfaces, extensions = class
   features, field spaces = shared layout)
  3. Good analogies - Extensions are like C# partial classes, traits are like interfaces, field spaces are like
  C structs
  4. Stack comments help - The protocol validation makes method signatures explicit

  Key would be comprehensive examples showing:
  - When to use each field type
  - Trait vs extension decision criteria
  - How is-a works differently for each
  - Common patterns and idioms

  With good documentation and examples in CLAUDE.md, I think this system would actually be quite teachable. The
  conceptual complexity is front-loaded, but once learned, it provides powerful expressiveness for game
  development.

  The bigger risk might be Claude overthinking simple cases where basic classes would suffice.


● | Data Structure | field | property | var  | static | protocol: | Notes                              |
  |----------------|-------|----------|------|--------|-----------|------------------------------------|
  | class:         | Yes   | No       | Yes* | Yes    | No        | *var only if class has field-space |
  | trait:         | No    | Yes      | No   | Yes    | Yes       | Cross-class behavioral interfaces  |
  | extension:     | No    | No       | Yes  | Yes    | Yes       | Class-specific feature modules     |
  | Private blocks | Yes   | No       | No   | No     | No        | Implementation hiding only         |

  Key constraints:
  - property - Traits only (dynamic offset resolution for cross-class compatibility)
  - var - Classes with field-space or extensions only (shared field space required)
  - field - Classes or private blocks only (direct offset allocation)
  - static - Classes, traits, extensions (class-level data, universally useful)
  - protocol: - Traits and extensions only (behavioral contracts)

  Design rationale:
  - Traits focus on flexible interfaces (properties + protocols)
  - Extensions focus on performance features (vars + protocols)
  - Classes get full flexibility for concrete implementations
  - Private blocks only for encapsulated utility components