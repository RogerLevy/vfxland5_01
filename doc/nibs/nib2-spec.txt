Working name: Nib 2.0

trait: object
    system trait that all classes have.

\ Compile-time object life-cycle methods
\ --------------------------------------

: :construct ( #params class - )
    \ defines constructor for class
    \ stateless - always defined outside class blocks
    \ constructor code follows and is executed during object creation

\ These would be defined outside blocks with :: syntax:
\ object :: teardown ( - )
\ object :: init ( - )
\ object :: deinit ( - )

\ Instantiation
\ -------------

: make ( ... class - object )
    \ create unnamed dictionary instance.
    \ executes constructor.
    \ (formerly named 'instance' - alias provided for compatibility)
    
: construct ( ... class addr - )
    \ initialize object at pre-allocated address.
    \ stores class pointer and executes constructor.
    \ used internally by instance and for memory pools.
    
: $object ( ... class name len - object ) ( - object ) 
    \ create named dictionary instance.
    \ executes constructor.

: object ( ... class <name> - ) ( - object )
    \ create named dictionary instance with parsed name.
    \ executes constructor.

: <object ( ... addr class - addr )
    \ initialize object at user-provided address.
    \ for pre-allocated memory like actor pools.
    \ executes constructor.
    \ (planned but not yet implemented)

\ Field definition
\ ----------------

: field ( n size <name> - n+size ) ( - field ) ( struct-addr - field-addr )
    \ define a struct field accessor (any size) and offset calculator (>NAME).
    \ FOR PLAIN STRUCTS ONLY - NOT for classes.
    \ Use with pattern: 0 cell field f1 cell field f2 constant /struct-size
    \ public or private depending on CURRENT.
    
: nproperty ( size <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (any size) and offset calculator (>NAME).
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ supports hot-reload safety - detects size changes and aborts with clear error.
    \ supports serialization metadata via <save, <int, <fixed, <float, <cstring.
    \ always public.
    
: property ( <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (cell) and offset calculator (>NAME).
    \ convenience word equivalent to "CELL NPROPERTY".
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ supports serialization metadata via <save, <int, <fixed, <float, <cstring.
    \ always public.
    
: static ( <name> - ) ( - field ) ( class - field )
    \ define a shared class accessor (cell) and offset calculator (>NAME) if they have not been already defined.
    \ statics are global across classes (every class is a fixed size).
    \ the class accessor references the current object's class, while the offset calculator takes a class on the stack.
    \ always public.

\ Class definition
\ ----------------

: class: ( <name> - )
    \ define a class if it has not already been defined.
    \ used ONLY for data definition (properties, statics).
    \ paired with CLASS;
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ always public.
    
    \ Compact syntax (optional):
    \ class: <name> [optional-class] [additional-traits...] [props...] [prop-name size...] ;
    \ Examples:
    \   Simple class with two properties
    \     class: point x y ;
    \   Class with trait and properties
    \     class: array iterable max-items item-size data ;
    \   Class with parent (first trait is a class)
    \     class: enemy actor ;
    \   Class with capabilities (traits that it does not identify with, same as WORKS-WITH )
    \     class: actor "vessel" "projectile" "pickup" ;
    \   Multiple traits, sized properties
    \     class: network serializable loggable address 4 port 2 buffer 256 ;  
    \ The compact form expands internally to the block form via c: parser.
    \ Implemented with validation: property names cannot match classifier names.

: defaults ( - a )
: >defaults ( class - a )
    \ pointer to template (object) for current/given class; if it doesn't exist when invoked, create it.

: field-space ( n - )
    \ create a field space for the current class, fixing the class to the given size.

: trait: ( <name> - )
    \ define a trait - if it has not already been defined - which is a class that can be mixed into other classes.
    
    \ Compact syntax (optional):
    \ trait: <name> [props...] [prop-name size...] ;
    \ Examples:
    \   trait: iterable item-count ;                  \ Simple trait with one property
    \   trait: drawable x y bitmap flags 4 ;          \ Trait with multiple properties including sized
    \ The compact form expands internally to the block form via c: parser.
    \ Note: traits cannot reference other traits in compact form (no is-a allowed)
    \ used ONLY for data definition (properties).
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ paired with TRAIT;
    \ traits cannot "inherit" other traits.
    \ always public
    
: is-a ( [class] <trait> )
    \ applies trait to given class, or the current class if in a classifier block.
    \ if a wrong data type is given, throw an error.
    \ merges protocols and properties from the trait into the class.

: works-with ( [class] <trait> )
    \ apply trait to class without adding to id-table.
    \ adds protocols and maps properties from the trait for transparent interoperability.
    \ IS? will return 0 (class does not identify as the trait).
    \ CAN? will return -1 (class has the capability).
    \ used for capabilities/interfaces the class supports but doesn't inherit identity from.

: is? ( object classifier - b )
    \ check object for class or trait identity (inheritance).
    
: can? ( object|class classifier|protocol-xt - bool )
    \ check if object/class has capability (trait or protocol support).
    \ similar to IS? but checks capabilities rather than identity.
    \ accepts either traits or protocol XTs as second parameter.

: derive ( class - )
    \ copy the given class (statics and defaults template) to the current class.
    \ if given item is any other data type, throw an error.
    
: :: ( [classifier] <name> - ) ( ... object - ... )
    \ unified protocol definition and implementation.
    \ classifier parameter optional when inside trait:/class: blocks.
    \ uses current classifier context when classifier omitted.
    \ when used with a trait, creates protocol if it doesn't exist.
    \ when used with a class, implements/overrides the protocol.
    \ stateless - can be used anywhere, not just in classifier blocks.
    \ stack diagram is stored and validated for consistency.
    \ the class is validated against the protocol.
    \ always public.

: :derive ( class - ) ( original-class derived-class - )
    \ define post-derive behavior for given class.
    \ stateless - always defined outside class blocks.
    \ executed after DERIVE copies structure and members.

\ Protocol System Safety Features
\ --------------------------------

Protocol Conflict Protection:
    Traits cannot override protocol implementations from other traits.
    System detects conflicts and aborts with descriptive error messages.
    Classes can still override any trait protocol implementations.

Protocol Propagation:
    Protocols added to traits automatically propagate to dependent classes.
    Enables hot-reload protocol extension during development.
    Only propagates when class doesn't have conflicting implementation.

Protocol Tracking:
    Classes maintain their own protocol-list for introspection and debugging.
    Protocols are automatically added when implemented via :: syntax.
    Hot-reload safe - prevents duplicate protocol entries during development.
    Enables .class introspection to show all protocols supported by a class.

Field-Space Protection:
    Properties cannot be added to reopened classifiers without field-space.
    Prevents memory layout corruption from unsafe property addition.
    Use FIELD-SPACE to enable safe property addition in reopened classes.
    
: sizeof ( class|object - n )
    \ smart size query supporting both objects and classes
    \ for objects: gets class then returns instance-size
    \ for classes: directly returns instance-size

\ Introspection System
\ --------------------

: .class ( class - )
    \ detailed class inspection showing size, properties, protocols, traits, and parents
    \ displays protocol count and detailed protocol listing
    \ shows trait relationships and inheritance hierarchy

: .nibs ( - )
    \ system overview showing all classes, traits, and resource usage
    
\ Enhanced Property Access
\ ------------------------

: -> ( object <name> - a )
    \ enhanced field/property access with performance optimization (renamed from 'S)
    \ detects MAGIC_PROPERTY and generates optimized assembly with prop+
    \ generates simple + for regular fields
    \ syntax: object -> property-name

\ example 1: arrays with collection trait
\ ---------------------------------------

public

trait: collection
    property max-items
    property item-size
    property item-count
    property items
trait;

\ Protocols defined outside trait block for statelessness
collection :: each ( xt - ) ( a - )
    drop ;

class: array
    array is-a collection
class;

class: slice 
    slice is-a collection
class;

class: stack
    stack is-a collection
class;

|| : /stack ( count item-size - )
    2dup item-size ! max-items !
    align here items ! * allot&erase ;

2 stack :construct ( max-count item-size - )
    /stack ;

2 array :construct ( max-count item-size - )
    /stack max-items @ item-count ! ;

: #items ( collection - n )
    -> item-count @ ;

\ Class implementation of protocol (stack diagram must match)
array :: each ( xt - ) ( a - )
    ... ; 


\ example 2: actors
-------------------------------------------

trait: drawable
    \ Properties only in trait block
trait;

\ Protocol defined outside for statelessness
drawable :: draw ( - )
    drop ;

class: actor
    actor is-a drawable
    512 field-space
    property x
    property y
    property vx
    property vy
    property bmp
    \ ...
    static oexec-error-handler ( xt n - )
class;

\ derive hook defined outside class block
actor :derive ( original-class derived-class - )
    2drop 
    private ;  \ set up private vocabulary

\ set static; DERIVE carries it over 
' actor-oexec-error-handler actor -> oexec-error-handler !

actor :: draw ( - )
    sprite ;

class: ship
    actor derive
    property energy
    property lives
class;

\ kinetic.vfx
trait: kinetic
    property rad
    property mass
    property ang
trait;

kinetic :: on-bounce ( object - )
    drop ;

\ enemy1.vfx
require kinetic.vfx  \ more likely to be in common.vfx to avoid repetition and false cross-app modularity, but this is just an example

class: enemy1
    actor derive
    enemy1 is-a kinetic   
class;

\ derive hook defined outside
enemy1 :derive ( original-class derived-class - )
    nip
    dup register-enemy-class
    auto-bitmap ;


conversation notes
------------------

> would this system be potentially too difficult for Claude to code in effectively without all of the context of
   this conversation?  it is very different from conventional OOP now.

● You raise a valid concern. This system is quite different from conventional OOP and has several non-standard
  concepts:

  Complexity factors:
  - Multiple field types (field, property, static) with different allocation rules
  - Field spaces - shared offset allocation across object instances
  - Protocol validation with stack diagram matching
  - Deferred property allocation based on field space presence

  However, I think Claude could handle it with proper documentation because:

  1. Consistent patterns - Once you understand is-a/is? and the field types, the system is quite regular
  2. Clear separation of concerns - Each concept has a distinct purpose (traits = interfaces/features, field spaces = fixed size)
  3. Good analogies - traits are like interfaces, field spaces are like C structs
  4. Stack comments help - The protocol validation makes method signatures explicit

  Key would be comprehensive examples showing:
  - When to use each field type
  - How is-a works differently for each
  - Common patterns and idioms

  With good documentation and examples in CLAUDE.md, I think this system would actually be quite teachable. The
  conceptual complexity is front-loaded, but once learned, it provides powerful expressiveness for game
  development.

  The bigger risk might be Claude overthinking simple cases where basic classes would suffice.

\ Serialization System
\ --------------------

Property-level serialization with metadata-driven binary format generation:

: <save
    \ mark current property for serialization
    \ applies to property being defined
    
: <int, <fixed, <float, <cstring
    \ set property data type for serialization
    \ used with <save to generate typed binary output
    
example:
    class: actor
        prop x <int <save
        prop y <int <save  
        256 nprop name <cstring <save
        prop health <int <save
        prop temp <int  \ not serialized
    class;

: serbin ( obj - )
    \ serialize object to compact self-describing binary format
    \ includes class name and property names for forward compatibility
    
: deserbin ( data allocator-xt - obj )
    \ deserialize binary data with custom object allocator
    \ validates class and property names during loading
    
: readbin ( data callback-xt - )
    \ inspect serialized data without instantiation
    \ callback receives member objects (classes and properties)
    
: .bin ( data - )
    \ display serialized data in human-readable format for debugging


● | Data Structure | field | property | static | protocol: | Notes                              |
  |----------------|-------|----------|--------|-----------|------------------------------------|
  | class:         | Yes   | Yes      | Yes    | No        |                                    |
  | trait:         | No    | Yes      | No     | No        | Cross-class behavioral interfaces  |
  | Private blocks | Yes   | No       | No     | No        | Implementation hiding only         |

  Key constraints:
  - field - Plain structs only (traditional Forth struct pattern, not for classes)
  - static - Classes only (class-level data)
  - :: - Traits for definition, classes for implementation (behavioral contracts)

  Design rationale:
  - Traits focus on flexible interfaces (properties + protocols)
  - Classes get full flexibility for concrete implementations
  - Private blocks only for encapsulated utility components