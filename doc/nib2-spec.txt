Working name: Nib 2.0

trait: object%
    system trait that all classes have.

\ Compile-time object life-cycle methods
\ --------------------------------------

: :construct ( #params class - )
    \ defines constructor for class
    \ stateless - always defined outside class blocks
    \ constructor code follows and is executed during object creation

\ These would be defined outside blocks with :: syntax:
\ object% :: teardown ( - )
\ object% :: init ( - )
\ object% :: deinit ( - )

\ Instantiation
\ -------------

: construct ( ... class - object )
    \ create unnamed dictionary instance.
    \ executes constructor.
    
: construct! ( ... class addr - )
    \ initialize object at pre-allocated address.
    \ stores class pointer and executes constructor.
    \ used internally by construct and for memory pools.
    
: $object ( ... class name len - object ) ( - object ) 
    \ create named dictionary instance.
    \ executes constructor.

: object ( ... class <name> - ) ( - object )
    \ create named dictionary instance with parsed name.
    \ executes constructor.

: <object ( ... addr class - addr )
    \ initialize object at user-provided address.
    \ for pre-allocated memory like actor pools.
    \ executes constructor.
    \ (planned but not yet implemented)

\ Field definition
\ ----------------

: field ( n size <name> - n+size ) ( - field ) ( struct-addr - field-addr )
    \ define a struct field accessor (any size) and offset calculator (>NAME).
    \ FOR PLAIN STRUCTS ONLY - NOT for classes.
    \ Use with pattern: 0 cell field f1 cell field f2 constant /struct-size
    \ public or private depending on CURRENT.
    
: nproperty ( size <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (any size) and offset calculator (>NAME).
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ supports hot-reload safety - detects size changes and aborts with clear error.
    \ always public.
    
: property ( <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (cell) and offset calculator (>NAME).
    \ convenience word equivalent to "CELL NPROPERTY".
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ always public.
    
: static ( <name> - ) ( - field ) ( class - field )
    \ define a shared class accessor (cell) and offset calculator (>NAME) if they have not been already defined.
    \ statics are global across classes (every class is a fixed size).
    \ the class accessor references the current object's class, while the offset calculator takes a class on the stack.
    \ always public.

\ Class definition
\ ----------------

: class: ( <name> - )
    \ define a class if it has not already been defined.
    \ used ONLY for data definition (properties, statics).
    \ paired with CLASS;
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ always public.
    
    \ Compact syntax (optional):
    \ class: <name> [parent-trait] [additional-traits...] [props...] [prop-name size...] ;
    \ Examples:
    \   class: point% x y ;                                    \ Simple class with two properties
    \   class: array% iterable% max-items item-size data ;     \ Class with trait and properties
    \   class: network% serializable% loggable% address 4 port 2 buffer 256 ;  \ Multiple traits, sized properties
    \ The compact form expands internally to the block form.

: defaults ( - a )
: >defaults ( class - a )
    \ pointer to template (object) for current/given class; if it doesn't exist when invoked, create it.

: field-space ( n - )
    \ create a field space for the current class, fixing the class to the given size.

: trait: ( <name> - )
    \ define a trait - if it has not already been defined - which is a class that can be mixed into other classes.
    
    \ Compact syntax (optional):
    \ trait: <name> [props...] [prop-name size...] ;
    \ Examples:
    \   trait: iterable% item-count ;                  \ Simple trait with one property
    \   trait: drawable% x y bitmap flags 4 ;          \ Trait with multiple properties including sized
    \ The compact form expands internally to the block form.
    \ Note: traits cannot reference other traits in compact form (no is-a allowed)
    \ used ONLY for data definition (properties).
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ paired with TRAIT;
    \ traits cannot "inherit" other traits.
    \ always public
    
: is-a ( [class] <trait> )
    \ applies trait to given class, or the current class if in a classifier block.
    \ if a wrong data type is given, throw an error.
    \ merges protocols and properties from the trait into the class.

: is? ( object classifier - b )
    \ check object for class or trait.

: derive ( class - )
    \ copy the given class (statics and defaults template) to the current class.
    \ if given item is any other data type, throw an error.
    
: :: ( classifier <name> - ) ( ... object - ... )
    \ unified protocol definition and implementation.
    \ when used with a trait, creates protocol if it doesn't exist.
    \ when used with a class, implements/overrides the protocol.
    \ stateless - can be used anywhere, not just in classifier blocks.
    \ stack diagram is stored and validated for consistency.
    \ the class is validated against the protocol.
    \ always public.

: on-derive: ( class - ) ( original-class derived-class - )
    \ define post-derive behavior for given class.
    \ stateless - always defined outside class blocks.
    \ executed after DERIVE copies structure and members.
    
: sizeof ( class|object - n )
    \ smart size query supporting both objects and classes
    \ for objects: gets class then returns instance-size
    \ for classes: directly returns instance-size
    
\ Enhanced Property Access
\ ------------------------

: 'S ( object <name> - a )
    \ enhanced field/property access with performance optimization
    \ detects MAGIC_PROPERTY and generates optimized assembly with prop+
    \ generates simple + for regular fields

\ example 1: arrays with collection trait
\ ---------------------------------------

public

trait: collection%
    property max-items
    property item-size
    property item-count
    property items
trait;

\ Protocols defined outside trait block for statelessness
collection% :: each ( xt - ) ( a - )
    drop ;

class: array%
    array% is-a collection%
class;

class: slice% 
    slice% is-a collection%
class;

class: stack%
    stack% is-a collection%
class;

|| : /stack ( count item-size - )
    2dup item-size ! max-items !
    align here items ! * allot&erase ;

2 stack% constructor: ( max-count item-size - )
    /stack ;

2 array% constructor: ( max-count item-size - )
    /stack max-items @ item-count ! ;

: #items ( collection - n )
    's item-count @ ;

\ Class implementation of protocol (stack diagram must match)
array% :: each ( xt - ) ( a - )
    ... ; 


\ example 2: actors
-------------------------------------------

trait: drawable%
    \ Properties only in trait block
trait;

\ Protocol defined outside for statelessness
drawable% :: draw ( - )
    drop ;

class: actor%
    actor% is-a drawable%
    512 field-space
    property x
    property y
    property vx
    property vy
    property bmp
    \ ...
    static oexec-error-handler ( xt n - )
class;

\ on-derive hook defined outside class block
actor% on-derive: ( original-class derived-class - )
    2drop 
    private ;  \ set up private vocabulary

\ set static; DERIVE carries it over 
' actor-oexec-error-handler actor% 's oexec-error-handler !

actor% :: draw ( - )
    sprite ;

class: ship%
    actor% derive
    property energy
    property lives
class;

\ kinetic.vfx
trait: kinetic%
    property rad
    property mass
    property ang
trait;

kinetic% :: on-bounce ( object - )
    drop ;

\ enemy1.vfx
require kinetic.vfx  \ more likely to be in common.vfx to avoid repetition and false cross-app modularity, but this is just an example

class: enemy1%
    actor% derive
    enemy1% is-a kinetic%   
class;

\ on-derive hook defined outside
enemy1% on-derive: ( original-class derived-class - )
    nip
    dup register-enemy-class
    auto-bitmap ;




conversation notes
------------------

> would this system be potentially too difficult for Claude to code in effectively without all of the context of
   this conversation?  it is very different from conventional OOP now.

● You raise a valid concern. This system is quite different from conventional OOP and has several non-standard
  concepts:

  Complexity factors:
  - Multiple field types (field, property, static) with different allocation rules
  - Field spaces - shared offset allocation across object instances
  - Protocol validation with stack diagram matching
  - Deferred property allocation based on field space presence

  However, I think Claude could handle it with proper documentation because:

  1. Consistent patterns - Once you understand is-a/is? and the field types, the system is quite regular
  2. Clear separation of concerns - Each concept has a distinct purpose (traits = interfaces/features, field spaces = fixed size)
  3. Good analogies - traits are like interfaces, field spaces are like C structs
  4. Stack comments help - The protocol validation makes method signatures explicit

  Key would be comprehensive examples showing:
  - When to use each field type
  - How is-a works differently for each
  - Common patterns and idioms

  With good documentation and examples in CLAUDE.md, I think this system would actually be quite teachable. The
  conceptual complexity is front-loaded, but once learned, it provides powerful expressiveness for game
  development.

  The bigger risk might be Claude overthinking simple cases where basic classes would suffice.


● | Data Structure | field | property | static | protocol: | Notes                              |
  |----------------|-------|----------|--------|-----------|------------------------------------|
  | class:         | Yes   | Yes      | Yes    | No        |                                    |
  | trait:         | No    | Yes      | No     | No        | Cross-class behavioral interfaces  |
  | Private blocks | Yes   | No       | No     | No        | Implementation hiding only         |

  Key constraints:
  - field - Plain structs only (traditional Forth struct pattern, not for classes)
  - static - Classes only (class-level data)
  - :: - Traits for definition, classes for implementation (behavioral contracts)

  Design rationale:
  - Traits focus on flexible interfaces (properties + protocols)
  - Classes get full flexibility for concrete implementations
  - Private blocks only for encapsulated utility components