Working name: Nib 2.0

trait: object%
    system trait that all classes have.

\ Compile-time object life-cycle methods
\ --------------------------------------

: :construct ( #params class - )
    \ defines constructor for class
    \ stateless - always defined outside class blocks
    \ constructor code follows and is executed during object creation

\ These would be defined outside blocks with :: syntax:
\ object% :: teardown ( - )
\ object% :: init ( - )
\ object% :: deinit ( - )

\ Instantiation
\ -------------

: construct ( ... class - object )
    \ create unnamed dictionary instance.
    \ executes constructor.
    
: construct! ( ... class addr - )
    \ initialize object at pre-allocated address.
    \ stores class pointer and executes constructor.
    \ used internally by construct and for memory pools.
    
: $object ( ... class name len - object ) ( - object ) 
    \ create named dictionary instance.
    \ executes constructor.

: object ( ... class <name> - ) ( - object )
    \ create named dictionary instance with parsed name.
    \ executes constructor.

: <object ( ... addr class - addr )
    \ initialize object at user-provided address.
    \ for pre-allocated memory like actor pools.
    \ executes constructor.
    \ (planned but not yet implemented)

\ Field definition
\ ----------------

: field ( n size <name> - n+size ) ( - field ) ( struct-addr - field-addr )
    \ define a struct field accessor (any size) and offset calculator (>NAME).
    \ FOR PLAIN STRUCTS ONLY - NOT for classes.
    \ Use with pattern: 0 cell field f1 cell field f2 constant /struct-size
    \ public or private depending on CURRENT.
    
: nproperty ( size <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (any size) and offset calculator (>NAME).
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ supports hot-reload safety - detects size changes and aborts with clear error.
    \ always public.
    
: property ( <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (cell) and offset calculator (>NAME).
    \ convenience word equivalent to "CELL NPROPERTY".
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ always public.
    
: static ( <name> - ) ( - field ) ( class - field )
    \ define a shared class accessor (cell) and offset calculator (>NAME) if they have not been already defined.
    \ statics are global across classes (every class is a fixed size).
    \ the class accessor references the current object's class, while the offset calculator takes a class on the stack.
    \ always public.

\ Class definition
\ ----------------

: class: ( <name> - )
    \ define a class if it has not already been defined.
    \ used ONLY for data definition (properties, statics).
    \ paired with CLASS;
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ always public.
    
    \ Compact syntax (optional):
    \ class: <name> [parent-trait] [additional-traits...] [props...] [prop-name size...] ;
    \ Examples:
    \   class: point% x y ;                                    \ Simple class with two properties
    \   class: array% iterable% max-items item-size data ;     \ Class with trait and properties
    \   class: network% serializable% loggable% address 4 port 2 buffer 256 ;  \ Multiple traits, sized properties
    \ The compact form expands internally to the block form.

: defaults ( - a )
: >defaults ( class - a )
    \ pointer to template (object) for current/given class; if it doesn't exist when invoked, create it.

: field-space ( n - )
    \ create a field space for the current class, fixing the class to the given size.

: trait: ( <name> - )
    \ define a trait - if it has not already been defined - which is a class that can be mixed into other classes.
    
    \ Compact syntax (optional):
    \ trait: <name> [props...] [prop-name size...] ;
    \ Examples:
    \   trait: iterable% item-count ;                  \ Simple trait with one property
    \   trait: drawable% x y bitmap flags 4 ;          \ Trait with multiple properties including sized
    \ The compact form expands internally to the block form.
    \ Note: traits cannot reference other traits in compact form (no is-a allowed)
    \ used ONLY for data definition (properties).
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ paired with TRAIT;
    \ traits cannot "inherit" other traits.
    \ always public
    
: is-a ( [class] <trait> )
    \ applies trait to given class, or the current class if in a classifier block.
    \ if a wrong data type is given, throw an error.
    \ merges protocols and properties from the trait into the class.

: is? ( object classifier - b )
    \ check object for class or trait.

: derive ( class - )
    \ copy the given class (statics and defaults template) to the current class.
    \ if given item is any other data type, throw an error.
    
: :: ( classifier <name> - ) ( ... object - ... )
    \ unified protocol definition and implementation.
    \ when used with a trait, creates protocol if it doesn't exist.
    \ when used with a class, implements/overrides the protocol.
    \ stateless - can be used anywhere, not just in classifier blocks.
    \ stack diagram is stored and validated for consistency.
    \ the class is validated against the protocol.
    \ always public.

: on-derive: ( class - ) ( original-class derived-class - )
    \ define post-derive behavior for given class.
    \ stateless - always defined outside class blocks.
    \ executed after DERIVE copies structure and members.
    
: sizeof ( class|object - n )
    \ smart size query supporting both objects and classes
    \ for objects: gets class then returns instance-size
    \ for classes: directly returns instance-size
    
\ Enhanced Property Access
\ ------------------------

: 'S ( object <name> - a )
    \ enhanced field/property access with performance optimization
    \ detects MAGIC_PROPERTY and generates optimized assembly with prop+
    \ generates simple + for regular fields

\ example 1: arrays with collection trait
\ ---------------------------------------

public

trait: collection%
    property max-items
    property item-size
    property item-count
    property items
trait;

\ Protocols defined outside trait block for statelessness
collection% :: each ( xt - ) ( a - )
    drop ;

class: array%
    array% is-a collection%
class;

class: slice% 
    slice% is-a collection%
class;

class: stack%
    stack% is-a collection%
class;

|| : /stack ( count item-size - )
    2dup item-size ! max-items !
    align here items ! * allot&erase ;

2 stack% constructor: ( max-count item-size - )
    /stack ;

2 array% constructor: ( max-count item-size - )
    /stack max-items @ item-count ! ;

: #items ( collection - n )
    's item-count @ ;

\ Class implementation of protocol (stack diagram must match)
array% :: each ( xt - ) ( a - )
    ... ; 


\ example 2: actors
-------------------------------------------

trait: drawable%
    \ Properties only in trait block
trait;

\ Protocol defined outside for statelessness
drawable% :: draw ( - )
    drop ;

class: actor%
    actor% is-a drawable%
    512 field-space
    property x
    property y
    property vx
    property vy
    property bmp
    \ ...
    static oexec-error-handler ( xt n - )
class;

\ on-derive hook defined outside class block
actor% on-derive: ( original-class derived-class - )
    2drop 
    private ;  \ set up private vocabulary

\ set static; DERIVE carries it over 
' actor-oexec-error-handler actor% 's oexec-error-handler !

actor% :: draw ( - )
    sprite ;

class: ship%
    actor% derive
    property energy
    property lives
class;

\ kinetic.vfx
trait: kinetic%
    property rad
    property mass
    property ang
trait;

kinetic% :: on-bounce ( object - )
    drop ;

\ enemy1.vfx
require kinetic.vfx  \ more likely to be in common.vfx to avoid repetition and false cross-app modularity, but this is just an example

class: enemy1%
    actor% derive
    enemy1% is-a kinetic%   
class;

\ on-derive hook defined outside
enemy1% on-derive: ( original-class derived-class - )
    nip
    dup register-enemy-class
    auto-bitmap ;




conversation notes
------------------

> would this system be potentially too difficult for Claude to code in effectively without all of the context of
   this conversation?  it is very different from conventional OOP now.

‚óè You raise a valid concern. This system is quite different from conventional OOP and has several non-standard
  concepts:

  Complexity factors:
  - Multiple field types (field, property, static) with different allocation rules
  - Field spaces - shared offset allocation across object instances
  - Protocol validation with stack diagram matching
  - Deferred property allocation based on field space presence

  However, I think Claude could handle it with proper documentation because:

  1. Consistent patterns - Once you understand is-a/is? and the field types, the system is quite regular
  2. Clear separation of concerns - Each concept has a distinct purpose (traits = interfaces/features, field spaces = fixed size)
  3. Good analogies - traits are like interfaces, field spaces are like C structs
  4. Stack comments help - The protocol validation makes method signatures explicit

  Key would be comprehensive examples showing:
  - When to use each field type
  - How is-a works differently for each
  - Common patterns and idioms

  With good documentation and examples in CLAUDE.md, I think this system would actually be quite teachable. The
  conceptual complexity is front-loaded, but once learned, it provides powerful expressiveness for game
  development.

  The bigger risk might be Claude overthinking simple cases where basic classes would suffice.


‚óè | Data Structure | field | property | static | protocol: | Notes                              |
  |----------------|-------|----------|--------|-----------|------------------------------------|
  | class:         | Yes   | Yes      | Yes    | No        |                                    |
  | trait:         | No    | Yes      | No     | No        | Cross-class behavioral interfaces  |
  | Private blocks | Yes   | No       | No     | No        | Implementation hiding only         |

  Key constraints:
  - field - Plain structs only (traditional Forth struct pattern, not for classes)
  - static - Classes only (class-level data)
  - :: - Traits for definition, classes for implementation (behavioral contracts)

  Design rationale:
  - Traits focus on flexible interfaces (properties + protocols)
  - Classes get full flexibility for concrete implementations
  - Private blocks only for encapsulated utility components