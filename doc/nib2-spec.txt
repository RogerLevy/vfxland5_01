Working name: Nib 2.0

trait: object%
    system trait that all classes have.

\ Compile-time object life-cycle methods
\ --------------------------------------

: constructor: ( #params class - )
    \ defines constructor for class (defined outside class blocks)
    \ constructor code follows and is executed during object creation

protocol: teardown ( - )
    \ object% method

\ Run-time object life-cycle methods
\ ----------------------------------

protocol: init ( - )
    \ object% method

protocol: deinit ( - )
    \ object% method

\ Instantiation
\ -------------

: *object ( ... class - object )
    \ create unnamed dictionary instance.
    \ executes constructor.
    
: $object ( ... class name len - object ) ( - object ) 
    \ create named dictionary instance.
    \ executes constructor.

: object ( ... class <name> - ) ( - object )
    \ create named dictionary instance (convenience word for BL PARSE $OBJECT DROP).
    \ executes constructor.
    
: <object ( a size class - object )
    \ assign class to user-allocated memory - size provided for validation.

: <construct ( a size class - object )
    \ construct instance in user-allocated memory - size provided for validation.

\ Field definition
\ ----------------

: field ( n size <name> - n+size ) ( - field ) ( object - field )
    \ define an instance accessor (any size) and offset calculator (>NAME).
    \ also defines an external address.
    \ public or private depending on CURRENT.
    
: nproperty ( size <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (any size) and offset calculator (>NAME).
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ supports hot-reload safety - detects size changes and aborts with clear error.
    \ always public.
    
: property ( <name> - ) ( - field ) ( object - field )
    \ define an instance accessor (cell) and offset calculator (>NAME).
    \ convenience word equivalent to "CELL NPROPERTY".
    \ dynamic offset resolution (uses a static to store the offset, 0 = invalid).
    \ always public.
    
: static ( <name> - ) ( - field ) ( class - field )
    \ define a shared class accessor (cell) and offset calculator (>NAME) if they have not been already defined.
    \ statics are global across classes (every class is a fixed size).
    \ the class accessor references the current object's class, while the offset calculator takes a class on the stack.
    \ always public.

\ Class definition
\ ----------------

: class: ( <name> - )
    \ define a class if it has not already been defined.
    \ set as current classifier for defining members.
    \ paired with CLASS;
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ always public?

: defaults ( - a )
: >defaults ( class - a )
    \ pointer to template (object) for current/given class; if it doesn't exist when invoked, create it.

: field-space ( n - )
    \ create a field space for the current class, fixing the class to the given size.

: trait: ( <name> - )
    \ define a trait - if it has not already been defined - which is a class that can be mixed into other classes.
    \ set as current classifier for defining members.
    \ if it has not been defined, allocate a bit in a 1024-bit bitfield.
    \ paired with TRAIT;
    \ traits cannot "inherit" other traits.
    \ always public
    
: is-a ( - <trait> )
    \ adds trait to current class.
    \ if a wrong data type is given, throw an error.
    \ sets a bit in a 1024-bit static for validation and logic.

: is? ( object classifier - b )
    \ check object for class or trait.

: derive ( class - )
    \ copy the given class (statics and defaults template) to the current class.
    \ if given item is any other data type, throw an error.
    
: protocol: ( <name> - ) ( ... object - ... )
    \ define a trait method (takes up a static) if it has not already been defined.
    \ must have a stack diagram, which gets stored in the protocol.
    \ is associated with the current trait's bit offset.
    \ always public.
    
: :: ( class <name> - ) ( ... object - ... )
    \ define given class's method implementation.
    \ the stack diagram is validated against the protocol's stored one.
    \ the class is validated against the protocol.

: on-derive: ( - ) ( original-class derived-class - )
    \ define post-derive behavior for the current class.
    \ executed after DERIVE copies structure and members.
    
: sizeof ( class|object - n )
    \ smart size query supporting both objects and classes
    \ for objects: gets class then returns instance-size
    \ for classes: directly returns instance-size
    
\ Enhanced Property Access
\ ------------------------

: 'S ( object <name> - a )
    \ enhanced field/property access with performance optimization
    \ detects MAGIC_PROPERTY and generates optimized assembly with prop+
    \ generates simple + for regular fields

\ example 1: arrays with collection trait
\ ---------------------------------------

public

trait: collection%
    property max-items
    property item-size
    property item-count
    property items
    
    protocol: each ( xt - ) ( a - )
        drop ;
    
trait;

class: array%
    is-a collection%
class;

class: slice% 
    is-a collection%
class;

class: stack%
    is-a collection%
class;

|| : /stack ( count item-size - )
    2dup item-size ! max-items !
    align here items ! * allot&erase ;

2 stack% constructor: ( max-count item-size - )
    /stack ;

2 array% constructor: ( max-count item-size - )
    /stack max-items @ item-count ! ;

: #items ( collection - n )
    's item-count @ ;

array% :: each ( xt - ) ( a - ) \ stack diagram(s) must match the protocol's exactly
    ... ; 


\ example 2: actors
-------------------------------------------

trait: drawable%
    protocol: draw ( - )
        ;
trait;

class: actor%
    is-a drawable%
    512 field-space
    property x
    property y
    property vx
    property vy
    property bmp
    \ ...
    static oexec-error-handler ( xt n - )
    on-derive: ( original-class derived-class - )
        2drop 
        private ;  \ set up private vocabulary
class;

\ set static; DERIVE carries it over 
' actor-oexec-error-handler actor% 's oexec-error-handler !

actor% :: draw ( - )
    sprite ;

class: ship%
    actor% derive
    property energy
    property lives
class;

\ kinetic.vfx
actor% trait: kinetic%
    property rad
    property mass
    property ang
    protocol: on-bounce ( object - )
        drop ;
trait;

\ enemy1.vfx
require kinetic.vfx  \ more likely to be in common.vfx to avoid repetition and false cross-app modularity, but this is just an example

class: enemy1%
    actor% derive
    is-a kinetic%   

    on-derive: ( original-class derived-class - )
        nip
        dup register-enemy-class
        auto-bitmap ;
class;




conversation notes
------------------

> would this system be potentially too difficult for Claude to code in effectively without all of the context of
   this conversation?  it is very different from conventional OOP now.

● You raise a valid concern. This system is quite different from conventional OOP and has several non-standard
  concepts:

  Complexity factors:
  - Multiple field types (field, property, static) with different allocation rules
  - Field spaces - shared offset allocation across object instances
  - Protocol validation with stack diagram matching
  - Deferred property allocation based on field space presence

  However, I think Claude could handle it with proper documentation because:

  1. Consistent patterns - Once you understand is-a/is? and the field types, the system is quite regular
  2. Clear separation of concerns - Each concept has a distinct purpose (traits = interfaces/features, field spaces = fixed size)
  3. Good analogies - traits are like interfaces, field spaces are like C structs
  4. Stack comments help - The protocol validation makes method signatures explicit

  Key would be comprehensive examples showing:
  - When to use each field type
  - How is-a works differently for each
  - Common patterns and idioms

  With good documentation and examples in CLAUDE.md, I think this system would actually be quite teachable. The
  conceptual complexity is front-loaded, but once learned, it provides powerful expressiveness for game
  development.

  The bigger risk might be Claude overthinking simple cases where basic classes would suffice.


● | Data Structure | field | property | static | protocol: | Notes                              |
  |----------------|-------|----------|--------|-----------|------------------------------------|
  | class:         | Yes   | Yes      | Yes    | No        |                                    |
  | trait:         | No    | Yes      | Yes    | Yes       | Cross-class behavioral interfaces  |
  | Private blocks | Yes   | No       | No     | No        | Implementation hiding only         |

  Key constraints:
  - field - Classes or private blocks only (direct offset allocation)
  - static - Classes, traits (class-level data, universally useful)
  - protocol: - Traits only (behavioral contracts)

  Design rationale:
  - Traits focus on flexible interfaces (properties + protocols)
  - Classes get full flexibility for concrete implementations
  - Private blocks only for encapsulated utility components