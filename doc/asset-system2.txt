>>> THIS IS OUTDATED, see asset-system-final-design.txt <<<

Notes
=====

- assets must be named after the file they're associated with

- assets can de-reference themselves (bitmap -> id), so long as a way is provided to get the asset back

- >ASSET pattern: create an asset at dev time (also creating a file)
    if the asset already exists, it is updated (or not, depending on the asset)
    this is why it's "to ____", the idea is we just want to tell the system
        of an asset that should have certain params.


Logic Tree (Claude-analyzed) 
============================

tileset
    dev-time construction: 
        my.png 16 16 >tileset mybmp.ts  
            asset word exists? 
                (assume file hasn't moved)
                free tiles
                re-slice tiles
            else
                create file
                call INIT: slice up tiles
    startup:
        walk tileset files
            asset word exists?  
                store the file path
                call INIT on it
            else:  
                create tileset
                construct it from the file and store the file path
  
scene
    dev-time construction: 
        *scene scene0.scn
            asset word exists? 
                (assume file hasn't moved)
                no-op
            else
                create file
                store the file path

    startup:
        walk scene files in dat/scn
            asset word exists?
                store the file path
            else:  
                create scene object
                store the file path

WIP Design (psuedocode)
=======================

m: cleanup ( asset -- )        \ Free external resources (safe if empty)
m: setup ( asset -- )          \ Create/recreate external resources
m: load-params ( asset -- )    \ Read params from file
m: save-params ( asset -- )    \ Write params to file
m: apply-params ( ...params asset -- )  \ Store params in asset

: >asset ( ...params class <name> -- )
    \ Dev-time create or update
    parse-name 2dup find-asset-word if
        \ Asset exists - get object
        2drop execute @         \ Get existing object
        >r true r>              \ Flag that it existed
    else
        \ Create new asset word and object
        over instantiate        \ Create object of class
        dup >r create-asset-word
        false r>                \ Flag that it's new
    then
    >r >r                       \ Save existed? flag and object

    r@ gen-path r@ >path !      \ Generate and store path
    r@ apply-params             \ Store params
    r> r> if                    \ If existed:
        dup cleanup
    then
    setup
    mark-dirty ;

: load-asset ( path class -- )
    \ Startup/load time
    materialize >r           \ Create asset
    r@ load-params          \ Read params from file
    r> setup ;              \ Create resources (no cleanup needed)

: commit-asset ( asset -- )
    \ Commit time
    dup save-params
    clear-dirty ;



With automatic serialization, the asset protocol becomes even simpler:

  \ Default implementations using serialization
  m: save-params ( asset -- )
      dup >path @ over serialize-to-file ;

  m: load-params ( asset -- )
      dup >path @ over deserialize-from-file ;

  \ Optional customization hook
  m: post-load ( asset -- )  \ Called after deserialization
      ;  \ Default: no-op

  Now asset classes only need to implement the essentials:



Example Implementation for Tileset
==================================

  class: tileset
      var source  var w  var h  var tiles

      :: cleanup  tiles @ ?dup if destroy then ;
      :: setup    source @ w @ h @ slice-tiles tiles ! ;
      :: apply-params ( bmpid w h self -- )
          >r r@ >h ! r@ >w ! r> >source ! ;
      :: gen-path ( <name> -- path )
          parse-name s" dat/tiles/" 2swap concat ;

      \ save-params/load-params handled by serialization!
  class;




get-path should be folded into >ASSET because the automatically-generated
path is class-dependent.


: gen-path ( object <name> - path )
    \ generate path for given object
    \ always constructs a path from the parsed name
    \ the path pattern depends on the class

: >asset ( ...params class <name> -- )
    \ Dev-time create or update
    
    ( instantiate the object )
    dup gen-path
    ...
    
>ASSET can still be used dynamically:
    some-name f" >ASSET %s" evaluate

: >tileset ( bmpid tile-w tile-h <name> - )
    tileset >asset ;

so it's:

mybmp.png 16 16 >tileset mybmp.ts

or, to eliminate defining >TILESET type words:

mybmp.png 16 16 tileset >asset mybmp.ts

or maybe a  convenient shorthand:

mybmp.png 16 16 tileset ~> mybmp.ts

