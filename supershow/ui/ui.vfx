\ ------------------------------------------------------------------------------
\ User Interface Layer
\ ------------------------------------------------------------------------------

require %idir%\..\node.vfx

256 ?constant #elements

class: element
    actor derive
    is-a node
    prop sx <save <fixed
    prop sy <save <fixed
    prop vis <save 
    prop draw <xt
class;

#elements element object-array elements

\ =============================================================================
\ Allocation
\ =============================================================================
: element[] ( n - element ) elements [] ;

|| variable enext#

element template [[
    at@ 2>. x 2!  vis on  1. 1. sx 2!
]]

|| : alloc-element ( - a )
    #elements for
        enext# @ element[] dup free? if
            element over construct
            unloop exit
        then  drop
        enext# @ 1 + #elements mod enext# !
    loop
    -1 abort" Out of elements" ;

: el ( class - actor )
    alloc-element [[ you push  me init  me ]] ;

\ Definition
: el: ( class - <name> a )
    el dup constant ;
    
: draw> ( - ) ( - )
    r> draw ! ;

\ =============================================================================
\ Announce
\ =============================================================================
|| 0 value xt

|| : (announce)
    xt execute 
    [ last-colon-xt @ ] literal me each ;

: announce ( xt el - )
    swap to xt 
    ['] (announce) swap each ;

: announce> ( el - <code> ; )
    r> swap announce ;

\ Update element time counters
|| : (+time) ( - )
    en @ -exit  
    pdelta time +! 
    [ last-colon-xt @ ] literal me each ;

\ =============================================================================
\ processing
\ =============================================================================
|| : (act) ( - )
    en @ -exit
    beha @ ?oexec
    [ last-colon-xt @ ] literal me each ;

|| : middle ( - x y )  bmp @ bmpwh 2 2 2/ ;
|| : sprite ( - )  at@ middle 2negate +at bmp @ put at ;
|| : +t  x 2@ 2.> 2s>f `` sx 2@ 2p>f 0e ``` transform ;

|| : (draw) ( - )
    en @ -exit vis @ -exit
    +m +t 0 0 at
        draw @ if draw @ ?oexec else sprite then
        [ last-colon-xt @ ] literal me each
    -m  ;

element object root 

: ui ( - )
    ['] (+time) root each 
    ['] (act) root each 
    ['] (draw) root each ;

\ =============================================================================
\ Coordinate-system conversions
\ =============================================================================
: p>local ( x. y. - x. y. )
    parent @ ?dup if [[ recurse ]] then x 2@ 2- sx 2@ 2p/ ;

: >local ( x y - x y )
    2>. p>local 2.> ;

\ =============================================================================
\ Live hot-reload
\ =============================================================================
\ : ui-update ( - <class> )
\     {: | c :}
\     \ Live update element class
\     \ TODO: make `update` polymorphic since classes are now objects
\     bl preparse f" ui\%s.vfx" >ld
\     bl word find not if drop exit then
\     >body to c
\     root announce> me c is? -exit me init ;

\ =============================================================================
\ Isolation
\ =============================================================================

element :: unload ( - )
    en off ; 

: isolate ( el - )
    ['] unload over -> parent @ each  -> en on ;
