\ parent lowest highest next prev

: u+  rot + swap ;

: dlremove  ( node -- )
    dup -> parent @ dup 0= if  2drop  exit  then
    locals| p n |
    0 n -> parent !
    p -> lowest @ p -> highest @ = if
        n p -> lowest @ = if
            0 dup p -> lowest ! p -> highest !
        exit then
        -1 abort" dlremove: Corrupt tree!"
    else
        n p -> lowest @ = if
            0 n -> next @ -> prev !
            n -> next @ p -> lowest !
            0 dup n -> prev ! n -> next !
        exit then
        n p -> highest @ = if
            0 n -> prev @ -> next !
            n -> prev @ p -> highest !
            0 dup n -> prev ! n -> next !
        exit then
        n -> next @ n -> prev @ -> next !
        n -> prev @ n -> next @ -> prev !
        0 dup n -> prev ! n -> next !
    then ;

: (dlinit)  ( node parent -- )
    locals| p n |
    n dup p -> lowest ! p -> highest !
    p n -> parent ! ;

: dlpush  ( node parent -- )
    2dup = abort" dlinsert: Same node!" 
    over dlremove
    dup -> lowest @ 0= if  (dlinit)  exit  then
    locals| p n |
    n p -> highest @ -> next !
    p -> highest @ n -> prev !
    n p -> highest !
    p n -> parent ! ;

: dlinsert-after  ( node dest -- )
    2dup = abort" dlinsert: Same node!"
    dup -> parent @ 0= if 2drop exit then
    over dlremove 
    dup -> next @ 0= if  -> parent @ dlpush exit  then
    dup -> next @ locals| neighbor dest src |
    src dest -> next !
    dest src -> prev !
    neighbor src -> next !
    src neighbor -> prev !
    dest -> parent @ src -> parent ! ;

: dlunshift  ( node parent -- )
    2dup = abort" dlinsert: Same node!" 
    over dlremove
    dup -> lowest @ 0= if  (dlinit)  exit  then
    locals| p n |
    p -> lowest @ n -> next !
    n p -> lowest @ -> prev ! 
    n p -> lowest !
    p n -> parent ! ;

: dleach  ( xt node -- )
    -> lowest @ ?dup if
        [[
            begin  me while
                next @ >r  dup >r execute r>  r> to me
            repeat
            drop
        ]]
    else ( xt ) drop then ;

: (dlorphan)  0 dup next ! dup prev ! parent ! ;

: dlclear  ( node -- )
    -> lowest @ ?dup if
        [[
            begin  me while
                next @  (dlorphan)  to me
            repeat
        ]]
        0 dup lowest ! highest !
    then ;

: #children ( obj - n )
    -> lowest @ dup if 0 swap begin 1 u+ -> next @ ?dup 0= until then ;

: nth-child ( n obj - obj )
    dup #children >r -> lowest @ swap 0 r> umod for -> next @ loop ;

: descendant? ( obj obj - f )
    swap [[
        begin parent @ dup while
            over = if   ]] drop -1   exit then
            parent @ to me
        repeat nip ( 0 )
    ]] ;
