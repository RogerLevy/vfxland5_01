require %idir%/checks.vfx
require %idir%/utilities.vfx
require %idir%/actor.vfx
require %idir%/stage.vfx
require %idir%/bitmap.vfx
require %idir%/tilemap2.vfx

\ =============================================================================
\ Actor sprite support
\ =============================================================================

class: %actor
    prop bmp :int <save 
class;

%actor :: draw ( - )
    bmp @ -exit  x 2@ 2>i at bmp @ cput ;

: ?pillory ( - )
    me benched? if
        $ff5555ff s" !" print
    then ;

: backsprites ( - )
    batch> actives> prio @ ?exit me draw ?pillory ;

: sprites ( - )
    batch> actives> prio @ -exit me draw ?pillory ;

\ =============================================================================
\ Frame animation
\ =============================================================================

class: %actor
    prop anm prop a.ts prop a.spd prop a.len
    prop a.ofs prop a.done prop a.flp
class;

|| variable aspd \ pointer to len in animation header
|| : >frames ( anim - a ) cell+ cell+ ;
|| : ?baseid  a.ts @ dup if 0 tile then ;
|| : update  a.ofs @ >i cells anm @ >frames + @ ?baseid + a.flp @ xor bmp ! ;
|| : ?done  a.ofs @ a.spd @ + a.len @ >p >= -exit  a.done on ;

: cycle ( anim spd. - ) \ to stop, say `anm off`
    a.spd !  dup anm !  @+ a.ts ! @ a.len !  0 a.ofs !  a.done off  update ;

: animation ( ts <name> - )  \ 1st , len , ofs , ofs , ofs , ... ofs ,
    create , here aspd ! 0 , ;

: frame, ( n - )
    , 1 aspd @ +! ;

: range, ( n n - )
    2dup < if 1 + swap do i frame, loop
    else swap do i frame, -1 +loop then ;

: animate ( - )
    hold @ ?exit actives>
        anm @ -exit
        a.spd @ a.ofs @ + a.len @ >p mod a.ofs !
        update ?done ;


