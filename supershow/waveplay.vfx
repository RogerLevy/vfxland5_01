require %idir%/checks.vfx
\ require %idir%/mode.vfx
\ require %idir%/tweak.vfx
\ require %idir%/shader.vfx
\ require %idir%/crt.vfx

\ ------------------------------------------------------------------------------
\ Simple sample-based audio
\ ------------------------------------------------------------------------------
defer voice? ( smp - f )
|| 256 constant #samples
\ ALLEGRO SAMPLE * , ALLEGRO_SAMPLE_ID [2] , choke flag , 
|| create samples  #samples 4 cells * allot&erase
|| variable next-smp#  1 next-smp# !
|| 2variable ch 
|| 0 value strm
|| variable play-gain  1. play-gain !

\ =============================================================================
\ Wrappers
\ =============================================================================

|| : play-sample ( allegro-sample - )
    ?dup -exit
    play-gain @ p>f 0e 1e  ALLEGRO_PLAYMODE_ONCE  ch  al_play_sample
    1.0 play-gain ! ;
    
|| : stop-sample ( ALLEGRO_SAMPLE_ID* - )
    dup  al_stop_sample  2 cells erase ;

|| : sample-playing? ( ALLEGRO_SAMPLE_ID* - f )
    dup al_lock_sample_id
        al_get_sample_instance_playing
        swap al_unlock_sample_id ;

|| : load-sample ( a n - allegro-sample )
    >zpad al_load_sample ;

\ =============================================================================
\ Sample pool
\ =============================================================================

|| : sample[]  #samples 1 - and 4 cells * samples + ;

|| : chokes-itself ( smp - )
   sample[] cell+ cell+ cell+ on ;

: add-sample ( alsmp - smpid )
    next-smp# @ 1 next-smp# +!
    dup >r sample[] !  r@ chokes-itself  r> ;

: set-sample ( alsmp smpid - )
    sample[] ! ;

\ =============================================================================
\ Playback
\ =============================================================================

|| : associate-channel ( smp - )
    ch 2@ rot sample[] cell+ 2! ;

|| : ?choke ( smp - smp )
    dup sample[] ( a ) dup cell+ cell+ cell+ @ if
        cell+ stop-sample
    else  ( a ) drop  then ;

: sound  ( smp - )
    dup voice? not if drop exit then
    ?choke  dup sample[] @ play-sample  associate-channel ;

:noname ( smp - f ) drop -1 ; is voice?

\ =============================================================================
\ Automatic loading
\ =============================================================================

|| : lastnfa  last @ ctrl>nfa ;

|| : *sample* ( a n - ) \ filename 
    lastnfa dup >r count -ext f" *%s*"
    screate r> name> >body @ ,
    does> @ sound ;

|| : does-sample  does> @ ;

|| : add-sample-asset ( a n - ) \ filename
    2dup load-sample add-sample ( smp ) >r
        -path screate  r> , 
    does-sample
    *sample* ; 

|| : ?sample ( a n - ) \ path
    2dup -path sfind if
        >r
        \ .loading
        load-sample r> >body @ sample[] !
    else
        drop
        \ .adding
        add-sample-asset
    then ;

|| : (load-sample) ( a n - ) \ path
    ?sample ;

|| : (reload-sample) ( a n - ) \ path
    \ TODO: reload only updated samples
    2dup sfind if
        >body @ sample[] @ al_destroy_sample
    else
        drop
    then
    (load-sample) ;

|| : clear-handles ( - )
    #samples for
        i sample[] 3 cells erase
    loop
    0 to strm
    0 next-smp# ! ;

: destroy-samples ( - )
    ." Destroying samples..." cr 
    #samples for
        i sample[] @ al_destroy_sample  
    loop
    clear-handles ;

: load-samples ( - )
    s" smp" find-dat-path dir-exists? -exit
    clear-handles
    current @ also forth definitions
    s" smp" find-dat-path ['] (load-sample) each-file
    previous current ! ;

: init-samples ( - )
    load-samples ;

: reload-samples ( - )
    s" smp" find-dat-path dir-exists? -exit
    clear-handles
    current @ also forth definitions
    s" smp" find-dat-path ['] (reload-sample) each-file
    previous current ! ;

\ =============================================================================
\ Streaming
\ =============================================================================

: stream-audiofile ( fp len loopmode - )
    \ Can only stream one at a time
    \ Allegro destroys the stream handle on exit
    {: lm :}
    \ strm ?dup if  al_destroy_audio_stream  0 to strm  then
    strm ?dup if  0 al_set_audio_stream_playing drop  then
    >zpad 3 2048 al_load_audio_stream 
        dup 0= if ." Unable to stream audio file." then
        ?dup -exit
        to strm
    strm play-gain @ p>f al_set_audio_stream_gain drop
    1.0 play-gain !
    strm lm al_set_audio_stream_playmode drop
    strm almixer al_attach_audio_stream_to_mixer drop ;

: stream-bgm ( fp len loopmode - )
    >r 
    2dup file-exists? not if
        s" bgm\" find-dat-path f" %s%s"
    then
    r> stream-audiofile ;

: stream ( fp len - )
    ALLEGRO_PLAYMODE_ONCE stream-bgm ;

: streamL ( fp len - )
    ALLEGRO_PLAYMODE_LOOP stream-bgm ;

\ =============================================================================
\ Control
\ =============================================================================

: loud ( n. - )
    play-gain ! ;

: stream-gain ( n. - )
    p>f strm al_set_audio_stream_gain drop ;

|| : stop-sounds ( - )
    strm ?dup if  0 al_set_audio_stream_playing drop  then
    #samples for
        i sample[] cell+ stop-sample
    loop ;

: hush ( - )
    stop-sounds ;

: gain ( n. - )
    p>f almixer al_set_mixer_gain drop ;

: playing? ( smp - f )
    sample[] cell+ dup 2@ or if sample-playing? else drop 0 then ;

: seek ( f:secs - )
    strm al_seek_audio_stream_secs drop ;

: playhead ( - f:secs )
    strm al_get_audio_stream_position_secs ;

: bgm ( - <name> <filename> ) ( - )
    create bl parse $, does> count streamL ;

: audioclip ( - <name> <filename> ) ( - )
    create bl parse $, does> count stream ;