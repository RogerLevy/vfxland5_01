trait: %autoload
    :: on-startup ( - ) ;
trait;

create autoloads /list allot&erase 

: init-autoloads ( - )
    autoloads list-count for
        list-next on-startup
    loop drop ;

class: %asset
    prop data 

    : _embed ( fp len - )
        2dup lslurp data !  srcpath$ place ;

    : asset ( name len class - asset ) ( - asset )
        >r screate r> instance 
        dup autoloads add-to ;

    : data@ ( asset - a len )
        -> data @ lcount ;
class;

: memfile@ ( a len - ALLEGRO_FILE_fp )
    0 z" r" al_open_memfile ;

: -memfile ( ALLEGRO_FILE_fp - )
    al_fclose drop ;

class: %bitmap
    is-a %autoload

    : does-bitmap ( - ) 
        does> -> id @ ;

    : _load-albmp ( - )
        me data@ memfile@ dup
            0 al_load_bitmap_f albmp !
        -memfile ;

    redef : bitmap ( <path> - ) ( - bmpid )
        bl parse 2dup 
        -path %bitmap asset does-bitmap { 
            ( fp len ) _embed
            _load-albmp 
            me add-bitmap id !
        } ;

    :: on-startup ( - )
        _load-albmp ;
class;

class: %tileset
    is-a %autoload

    : tileset-from ( bmpid tilew tileh <name> - ) ( - tileset )
        bl parse %tileset asset {
            tw 2! bmp !
            _slice-tileset
        } ;

    :: on-startup ( - )
        _slice-tileset ;
class;

class: %sample
    %asset derive
    is-a %autoload
    prop id :int
    prop alsmp

    : does-sample ( - ) 
        does> -> id @ sound ;

    : _load-alsmp ( - alsmp )
        me data@ memfile@ dup
            z" .ogg" al_load_sample_f alsmp !
        -memfile ;

    : sample ( <path> - ) ( - )
        \ oggs only for now
        bl parse 2dup 
        -path -ext f" *%s*" %sample asset does-sample { 
            ( fp len ) _embed
            _load-alsmp
            alsmp @ add-sample id !
        } ;

    :: on-startup ( - )
        _load-alsmp 
        alsmp @ id @ set-sample ;

class;
