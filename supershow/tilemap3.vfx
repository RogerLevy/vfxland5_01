\ =============================================================================
\ Tilemap v3
\ Supports different tileset and tilemap metrics rather than just 1 global set.
\ =============================================================================

require %idir%/checks.vfx
require %idir%/utilities.vfx
require %idir%/traits.vfx
require %idir%/asset.vfx
require %idir%/bitmap.vfx
require %idir%/tileset.vfx

fast{ 

class: %tilemap
    is-a %drawable
    is-a %dimensional
    prop ta :ref %array
    prop ts :ref %tileset
    EC_MAX_SIZE nprop ec
    template { ec clear-ec }
class;

ec-cell map

global { %tilemap template map! }
%tilemap template { 
    create default.ta cell array{ array} ta !
    create default.ts %tileset dmake ts !
}


0 %tilemap :construct ( - )
    ec ecp!   me map! ;

\ debug @ [if]
\     crucial test: check-map ( - n:res )
\         map@ 0<> ;

\     before xgap check-map
\     before ygap check-map
\     before tmw check-map
\     before tmh check-map
\ [then]


: xgap ( - n ) map@ >ts @ >tw @ ;
: ygap ( - n ) map@ >ts @ >th @ ;
: tmw ( - n ) map@ >w @ ;
: tmh ( - n ) map@ >h @ ;

: spot ( col row tilemap - a )
    { 0 0`` me dims 1 1 2-`` 2clamp
    w @ * + ta @ swap nth } ;

: xy>cr ( x. y. - col row )
    xgap ygap 2/ 2>i ;

: att ( col row - ) 
    xgap ygap 2*  xgap 2 / ygap 2 / 2+  at ;

\ =============================================================================
\ Tilemap rendering
\ =============================================================================

|| 0 value lm

: nr ( - ) 
    lm peny@ ygap + at ;

: put+ ( bmpid - ) 
    dup $FFFFFFFF = if drop 
    else pile@ + put then
    xgap 0 +at ;

: tiles ( a n - 'a ) 
    penx@ to lm
    udup for @+ put+ loop drop nr 
    tmw cells + ; 

: drawbg ( a cols rows - )
    {: a cols rows :}
    begin-batch  a rows for cols tiles loop drop  end-batch ;

%tilemap :: draw ( - )
    {{ 
        <at
        ts @ >baseid @ pile!
        ta @ 0 nth` me dims`` drawbg 
    }} ;

fast}