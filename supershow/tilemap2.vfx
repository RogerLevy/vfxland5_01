1 constant TILESET_FORMAT_VERSION

cell ecfield pile

class: %tileset
    %asset derive

    is-a %usable

    prop baseid
    prop bmp
    prop tw <save :int 
    prop th <save :int 
    prop #tiles <save :int 
    prop metas-array :ref %array

class;

|| : /metas ( - )
    0 cell %array instance metas-array ! ;

0 %tileset :construct ( - )
    /metas ;

: _slice-tileset ( - )
    \ slice up the source %bitmap into tile sub-bitmaps.
    \ add them to the global %bitmap registry.
    bmp @ -exit
    next-bmp# @ baseid !
    bmp @ bmph th @ - 1 + for
        bmp @ bmpw tw @ - 1 + for
            i j at   bmp @ id>albmp tw 2@ *subbmp wrap-bitmap dup . add-bitmap drop
        tw @ +loop
    th @ +loop
    next-bmp# @ baseid @ - #tiles ! 
    #tiles @ metas-array @ redim ;

\ : reslice-tileset ( tw th %tileset - )
\     \ slice up source bitmap, creating a new range of sub-bitmaps
\     \ use this at dev-time to change the tile size or if the bitmap's size increased.
\     dup unload   {   tw 2!   _slice-tileset   me keep   } ;

\ %tileset :: use ( - )
\     baseid @ pile ! ;

: update-tileset ( %tileset - )
    as>
        bmp @ -exit
        next-bmp# @ >r   baseid @ next-bmp# ! 
        _slice-tileset
        r> next-bmp# ! ;

\ : array, ( array - )
\     \ assumes cell array
\     dup #items ,   ['] , swap each ;

\ : @array+ ( a array - a' )
\     \ assumes cell array
\     {: | n :}
\     {
\         @+ to n 
\         n if
\             n me redim
\             dup data @ n cells move
\             n cells +
\         then 
\     } ;

: tile ( %tileset n - bmpid )
    swap -> baseid @ + ;

aka tile>bmpid tile

: is-tile? ( n - f )
    id>albmp dup -exit al_is_sub_bitmap ;

\ =============================================================================
\ Tilemap rendering
\ =============================================================================

|| 0 value lm
|| : nr ( - ) lm pen y@ gap + at ;
|| : put+ ( bmpid - ) 
    dup $FFFFFFFF = if drop 
    else pile @ + put then
    gap 0 +at ;

: >lmargin ( - ) 
    pen x@ to lm ;

: tiles ( a n - 'a ) 
    >lmargin udup for @+ put+ loop drop nr tmw cells + ; 

: drawbg ( a cols rows - )
    {: a cols rows :} begin-batch a rows for cols tiles loop drop end-batch ; 

: lay ( a - )
    tmw tmh drawbg ;

: spot ( col row a - a )
    -rot 0 0 tmw 1 - tmh 1 - 2clamp tmw * + cells + ;

: xy>cr ( x. y. - col row )
    gap dup 2/ 2>i ;

\ =============================================================================
\ Tile metadata
\ =============================================================================

#bitmaps cell array global-metas
global-metas 0 i>a constant metas
: meta ( tile# - n ) 65535 and pile @ + cells metas + @ ;
: collectible?  meta $20 and 0<> ;
: destructible?  meta $80 and 0<> ;
: solid?  meta $0F and $0F = ;
: instakill?  meta $40 and 0<> ;
: trap?  meta $10 and 0<> ;

: load-metas ( fp len tileset - )
    \ load tile metas from a binary file directly into the global table
    { global-metas baseid @ i>a` #tiles @ cells` 2swap read } ; 

: tileset>metas ( tileset - ) 
    \ copy tile metas that have been stored in a tileset into the global table
    { metas-array @, global-metas, 0, me 0 tile>bmpid, #tiles @ move-range } ;
