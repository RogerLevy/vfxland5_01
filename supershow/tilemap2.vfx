\ ------------------------------------------------------------------------------
\ Tilemap v2
\
\ (Untested)
\ ------------------------------------------------------------------------------

variable pile

\ =============================================================================
\ tileset
\ =============================================================================

class: tileset

    tileset is-a usable
    tileset is-a _totem

    prop baseid <save <int 
    prop bmp
    prop tw <save <int 
    prop th <save <int 
    prop #tiles <save <int 

    defaults [[
        s" ts" extension$ place
    ]]

    default-path: dat/gfx

class;

\ 256 cell stack tilesets
\ tilesets tileset -> registry !

|| : bmpw  dup if al_get_bitmap_width then ;
|| : bmph  dup if al_get_bitmap_height then ;

: slice-tiles ( tileset - )
    \ slice up the source bitmap into tile sub-bitmaps.
    \ write them to the global bitmap registry starting at baseid.
    \ preserve next-bmp#.
    >r bmp @ bitmap@ tw @ th @ r> {: b tw th ts :}
    ts as>
        b -exit
        next-bmp# @ >r   baseid @ next-bmp# !
        b bmph th - 1 + for
            b bmpw tw - 1 + for
                b i j tw th al_create_sub_bitmap +bitmap drop
            tw +loop
        th +loop
        next-bmp# @ baseid @ - #tiles !   r> next-bmp# ! ;

: reslice-tileset ( tw th tileset - )
    \ slice up source bitmap, creating a new range of sub-bitmaps
    \ use this at dev-time to change the tile size or if the bitmap's size increased.
    next-bmp# @ baseid !
    me slice-tiles
    #tiles @ next-bmp# +! 
    me mark-dirty ;

tileset :: use ( - )
   baseid @ pile ! ;

tileset :: load ( - )
    \ slice up the tileset's source bitmap.
    \ if the tileset was just defined, initialize baseid and increment next-bmp#
    me new? if next-bmp# @ baseid ! then
    me slice-tiles 
    me new? if #tiles @ next-bmp# +! then ;

tileset :: unload ( - )
    baseid @ #tiles @ bounds do
         i bitmap@ al_destroy_bitmap
    loop ;

|| : reconnect-bmp 
    my-name -ext f" %s.png" >pad find 0= abort" tileset source bitmap not found!"
    execute bmp ! ;   \ Bitmap words return their own bitmap ID's

tileset :: intake ( - )
    _totem:intake   reconnect-bmp   me load ;

: +tileset ( bmp# tw th <name> - )
    tileset +totem 
    [[ th ! tw ! bmp ! me ]]
    manifest drop ;

: tile ( tileset n - n )
    swap -> baseid @ + ;

: is-tile? ( n - f )
    bitmap@ dup -exit al_is_sub_bitmap ;

\ =============================================================================
\ Tilemap - Low level
\ =============================================================================

|| : nr  0 pen y@ gap + at ;
|| : tile+  pile @ + put gap 0 +at ;

: lay ( a - )
    batch> tmh for tmw for @+ tile+ loop nr loop drop ;

: spot ( col row a - a )
    -rot 0 0 tmw 1 - tmh 1 - 2clamp tmw * + cells + ;

: xy>cr ( x. y. - col row )
    gap dup 2/ 2p>s ;

\ =============================================================================
\ Tile metadata
\ =============================================================================

create metas #bitmaps cells allot&erase
: meta ( n - n ) pile @ + cells metas + @ ;
: collectible?  meta $20 and 0<> ;
: destructible?  meta $80 and 0<> ;
: solid?  meta $0F and $0F = ;
: instakill?  meta $40 and 0<> ;
: trap?  meta $10 and 0<> ;

: load-metas ( a:fn len:fn tileset - )
    >r
        here >r >datadir file,
        r> here over -
    r> -> baseid @ cells metas + swap move ;

