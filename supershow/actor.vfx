512 ?constant /actor

class: %actor
    is-a %drawable
    is-a %unloadable
    /actor field-space

    prop en
    prop x :fixed <save
    prop y :fixed <save
    prop vx :fixed <save prop vy :fixed <save 
    
    \ hitbox 1
    prop x1 :int <save prop y1 :int <save 
    prop w1 :int <save prop h1 :int <save 
    
    prop beha :xt
    prop phys :xt
    prop time :fixed                \ secs
    prop n1 prop n2 prop n3 prop n4 \ General purpose props (legacy)
    prop prio :int <save            \ 0 = behind BG, <>0 = in front of BG   
    prop id :int <save

    template { -1 id ! }

    static autoclass                \ flag

    prop unloaded

    EC_MAX_SIZE nprop ec
    template { ec clear-ec }
class;

\ =============================================================================
\ Actor management
\ =============================================================================

: free? ( actor - flag ) >en @ 0= ;

: exists? ( actor - flag )
    dup 0= if drop 0 exit then
    dup valid-object? if drop -1 exit then
    >en @ ;

0 %actor :construct ( - )
    \ ." construct" cr
    at@ 2>p x 2!
    ec ecp! ;

: init-actor ( actor - )
    { me init } ;

\ =============================================================================
\ Actor logic
\ =============================================================================

\ Actor benching (disabling when there's an error)
c: %actor benched ;  \ controls behavior and physics
: benched?  -> benched @ ;
: bench  -> benched on ;
: ?benched  benched @ if r> drop then ;

\ Step
: +gametime ( - )
    clock @ if
        gametime usdelta 0 d+ to gametime  
    then
    1 gamelife +! ;

: behave  beha @ ?oexec ;
: physics  phys @ ?oexec ;
: +time  ?benched pdelta time +! ;

\ =============================================================================
\ Actor scripting
\ =============================================================================

continuation: act> ( - ) ( - ) 0 time !  ( xt ) beha ! ; 
\ continuation: act&> ( - ) ( - ) 0 time !  ( xt ) dup execute  beha ! ; 
continuation: physics> ( - ) ( - ) ( xt ) phys ! ;

: simple-motion
    vx 2@ x 2+! ;

: -collisions ( - )
    physics> simple-motion ;

\ =============================================================================
\ Template
\ =============================================================================

%actor template {
    en on
    prio on
    -5 -5 x1 2!  10 10 w1 2!
    -collisions
}

\ =============================================================================
\ Object collisions
\ =============================================================================

: hitbox ( - x1 y1 x2 y2 )
    x 2@ 2>i x1 2@ 2+  w1 2@ 2over 2+ ; \ 1 1 2- ;

: hit? ( obj obj - f )
    2dup = if 2drop 0 exit then  \ actors can't collide with themselves
    over free? over free? or if 2drop 0 exit then
    >r { hitbox } r> { hitbox } overlap? ;

\ =============================================================================
\ Scripting utilities
\ =============================================================================

: att ( col row - ) gap dup 2*  gap 2 / dup 2+  at ;

: *{ ( class - <code> } )
    \ Parse-ahead instantiation for serialized objects/actors
    \ Allows property settings between *{ } that can be picked up by INIT
    s" (one) { " evaluate
    '}' parse' evaluate  1 >in +!
    s" me init }" evaluate ; immediate

: passed? ( n. - flag ) time @ <= dup if 0 time ! then ;

: from ( %actor x y - ) rot as> x 2@ 2>i 2+ at  ; \ me actor# priority ;

redef : halt  beha off  0 0 vx 2! ;

: morph ( class - )
    >r x 2@ vx 2@
    default me /actor move
    r> cla !
    vx 2! x 2! init ;

: vanish  y @ 16384. or y ! ;

: appear  y @ 16384. invert and y ! ;

%actor object dummy 

: expanded ( %actor amt - actor' )
    swap dummy copy as>
        dup negate dup x1 2+! 2 * dup w1 2+!
        me ;

: hitbox! ( x y w h - ) w1 2! x1 2! ;

: freemove ( actor - )
    as> halt -collisions act>
        <left> held? if -2. x +! then
        <right> held? if 2. x +! then
        <up> held? if -2. y +! then
        <down> held? if 2. y +! then ;

\ =============================================================================
\ Actor Inspection
\ =============================================================================

|| : .status ( - )
    benched @ if ." (BENCHED) " exit then
    en @ 0= if ." (FREE) " then ;

%actor :: .summary ( %actor - )
    11 push-foreground ." [ "
    id @ dup 0 >= if ." #" . else drop me .name then
    cla @ .name
    .status
    ." at: " x 2@ 2>i swap . . 
    ." ] " pop-attribute ;


\ =============================================================================
\ Backward Compatibility
\ =============================================================================

aka @hitbox hitbox
aka actor %actor
aka act&> act>
aka floating -collisions
