\ ------------------------------------------------------------------------------
\ Stage - Actor System
\ ------------------------------------------------------------------------------

1024 ?constant #actors
1024 ?constant #temps
512 ?constant /actor

variable gamelife
0d 2value gametime

class: %actor
    is-a %drawable
    is-a %unloadable
    /actor field-space

    prop en
    prop x <fixed <save
    prop y <fixed <save
    prop vx <fixed <save prop vy <fixed <save 
    
    \ hitbox 1
    prop x1 <int <save prop y1 <int <save 
    prop w1 <int <save prop h1 <int <save 
    
    prop beha <xt
    prop phys <xt
    prop time <fixed                \ secs
    prop n1 prop n2 prop n3 prop n4 \ General purpose props (legacy)
    prop prio <int <save            \ 0 = behind BG, <>0 = in front of BG
    prop benched                    \ controls behavior and physics    
    prop id <int <save
    24 nprop tag$ <cstring <save

    template { -1 id ! }

    static autoclass                \ flag
class;

#actors %actor object-array actors 
#temps %actor object-array temps

\ =============================================================================
\ Actor Access Words
\ =============================================================================

: free? ( %actor - f ) -> en @ 0= ;
: actor[] ( n - %actor ) actors [] ;
: actor# ( %actor - n ) -> id @ ;
continuation: act> ( - ) ( - ) 0 time !  ( xt ) beha ! ; 
continuation: act&> ( - ) ( - ) 0 time !  ( xt ) dup execute  beha ! ; 
continuation: physics> ( - ) ( - ) ( xt ) phys ! ;

: exists? ( %actor - f )
    dup 0= if drop 0 exit then
    dup valid-object? if drop -1 exit then
    -> en @ ;

fast{

continuation: actives> ( - ) ( - )
    ( xt ) {: xt :}
    0 actor[] {
        #actors for
            en @ if xt execute then
            /actor +to me
        loop
    } ; 

fast}

\ =============================================================================
\ Actor Inspection
\ =============================================================================

|| : .status ( - )
    benched @ if ." (BENCHED) " exit then
    en @ 0= if ." (FREE) " then ;

%actor :: .summary ( %actor - )
    11 push-foreground ." [ "
    me actor# dup 0 >= if ." #" . else drop me .name then
    cla @ .name
    .status
    ." at: " x 2@ 2>i swap . . 
    ." ] " pop-attribute ;

\ =============================================================================
\ Actor Errors
\ =============================================================================

: benched?  -> benched @ ;
: bench  -> benched on ;
: ?benched  benched @ if r> drop then ;

: behave ( - )
    beha @ ?oexec ;

: restore-sp ( a - )
    \ Restore SP. If debug mode is on, report stack imbalances.
    debug @ if
        \ Compare SP to previous SP.
        \ The data stack grows downward.
        dup sp@ cell+ cell+ > if
            s{ ." Positive stack imbalance in logic for actor " me .summary
            s} log-warning .rs cr .s cr
        then
        dup sp@ cell+ cell+ < if
            s{ ." Negative stack imbalance in logic for actor " me .summary
            s} log-warning .rs cr .s cr
        then
    then
    sp! ;

|| : (behave) ( - )
    actives> ?benched sp@ >r behave r> restore-sp ;

: physics ( - )
    phys @ ?oexec ;

|| : (move) ( - )
    actives> ?benched physics ;

: +gametime ( - )
    gametime usdelta 0 d+ to gametime  
    1 gamelife +! ;

: +time ( - )
    ?benched pdelta time +! ;
    
|| : (+time) ( - )
    +gametime actives> +time ;

|| : (step) ( - )
    (behave) (move) (+time) ;

: step ( - )
    hold @ ?exit
    ['] (step) catch
    ?dup if
        hold on
        .throw \ dup .throw .catch 
    then ;

\ =============================================================================
\ Find actors
\ =============================================================================

|| 0 value xt

|| : (find) ( 0 %actor - 0|actor )
    dup -> en @ 0= if drop exit then    
    { xt execute if enough drop me then } ;

continuation: who> ( - actor|0 ) ( - f )
    ( xt ) to xt
    0 ['] (find) actors each ;

|| 0 value $

: tagged ( $ - actor|0 )
    to $ who> $ count tag$ count s= ;

\ =============================================================================
\ Actor management
\ =============================================================================

variable next#

: floating ( - )
    physics> vx 2@ x 2+! ;

%actor template {
    en on
    prio on
    -5 -5 x1 2!  10 10 w1 2!
    floating
}

: priority ( n - )
    0 #actors 1 - clamp next# ! ;

%actor :: unload ( - )
    en off  ; 

: clear-stage ( - )
    0 next# !  actives>  me unload ;

: just ( - )
    ." JUST : Clearing all actors!" cr
    clear-stage gamew 2 / gameh 2 / at  ;

0 %actor :construct ( - )
    at@ 2>p x 2! ;

: stage-init ( actor - )
    { me actors slot>index id !   me init } ;

: stage-slot ( - actor )
    #actors for
        next# @ actor[] dup free? if
            unloop exit
        then  drop
        next# @ 1 + #actors mod next# !
    loop  -1 abort" one : Out of actors." ;

: one ( class - actor )
    stage-slot swap over construct dup stage-init ;
    
: *actor ( - %actor )
    %actor one ;

%actor object dummy 

\ =============================================================================
\ Object collisions
\ =============================================================================

: hitbox ( - x1 y1 x2 y2 )
    x 2@ 2>i x1 2@ 2+  w1 2@ 2over 2+  1 1 2- ;

: hit? ( obj obj - f )
    over free? over free? or if 2drop 0 exit then
    >r { hitbox } r> { hitbox } overlap? ;

\ =============================================================================
\ Scripting utilities
\ =============================================================================

: att ( col row - ) gap dup 2*  gap 2 / dup 2+  at ;

: *{ ( class - <code> } )
    \ Parse-ahead instantiation for serialized objects/actors
    \ Allows property settings between *{ } that can be picked up by INIT
    s" (one) { " evaluate
    ']' parse' evaluate  1 >in +!
    s" me init }" evaluate ; immediate

: passed? ( n - f ) time @ <= dup if 0 time ! then ;

: from ( %actor x y - ) rot as> x 2@ 2>i 2+ at  ; \ me actor# priority ;

redef : halt  beha off  0 0 vx 2! ;

: morph ( class - )
    >r x 2@ vx 2@
    default me /actor move
    r> cla !
    vx 2! x 2! init ;

: vanish  y @ 16384. or y ! ;

: appear  y @ 16384. invert and y ! ;

: expanded ( %actor amt - actor' )
    swap dummy copy as>
        dup negate dup x1 2+! 2 * dup w1 2+!
        me ;

: hitbox! ( x y w h - ) w1 2! x1 2! ;

: freemove ( - )
    halt floating act>
        <left> held? if -2. x +! then
        <right> held? if 2. x +! then
        <up> held? if -2. y +! then
        <down> held? if 2. y +! then ;

\ =============================================================================
\ Timer actors
\ =============================================================================

c: %timer %actor xt1 dur ;

: clear-timers ( -- )
    actives> me %timer is? -exit me unload ;

|| : act-timer
    act&> dur @ passed? -exit me unload xt1 @ >r ;
    
|| : (timer) ( time. xt -- )
    xt1 ! 0 max dur ! act-timer ;

continuation: timer> ( time. - ) ( - )
    ( xt ) %timer one { (timer) } ;

\ =============================================================================
\ Secondary actor storage
\ =============================================================================

|| variable tnext#
: temp[] ( n - a ) temps [] ;
: *temp ( - a )
    #temps for
        tnext# @ temp[] dup free? if
            unloop exit
        then
        drop
        tnext# @ 1 + #temps mod tnext# !
    loop  -1 abort" Out of temps" ;

fast{
continuation: temps> ( - ) ( - )
    ( xt )  {: xt :}
    0 temp[] {
        #temps for
            en @ if xt execute then
            /actor +to me
        loop
    } ; 
fast} 

: clear-temps ( - )
    temps> me unload ;

\ =============================================================================
\ Script Classes
\ =============================================================================

: (actor-definition) ( class - )
    dup body>name >pad count >lowercase ?-%
    CurrSourceName -path -ext >lowercase 
    s= if
        private
    then
    >template to me \ allows immediate assignment of template (TODO: revisit)
;

%actor :derive ( source-class derived-class - )
    nip (actor-definition) ;

: hide-if-autoclass ( class - )
    \ Hide autoclass to fix LOCATE
    \ otherwise it would take us to the call to load-autoclasses
    \ even if it's been defined in a script
    dup -> autoclass @ if >name hidename else drop then ;

%actor :reopen ( class - )
    \ Hide generated autoclass when defining an actor class.
    \ This will cause a new class to be created. (see above for rationale)
    \ TODO: There's a better way: modify the class's source file string.
    \       (Hopefully there's a string pointer we can change.)
    \       This will prevent any dangling references to autoclasses.
    dup hide-if-autoclass
    (actor-definition) ;
    
: find-class ( a len - class | %actor )
    ?-% f" %%%s"
    >pad find if execute else drop %actor then ;
