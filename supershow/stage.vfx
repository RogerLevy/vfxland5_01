\ ------------------------------------------------------------------------------
\ Stage - Actor System
\ ------------------------------------------------------------------------------

1024 ?constant #actors
1024 ?constant #temps

#actors %actor object-array actors 
#temps %actor object-array temps

variable next#

\ =============================================================================
\ Actor Access Words
\ =============================================================================

: actor[] ( n - %actor ) actors swap []@ ;
: actor# ( %actor - n ) -> id @ ;

fast{
continuation: actives> ( - ) ( - )
    ( xt ) {: xt :}
    0 actor[] {
        #actors for
            en @ if xt execute then
            /actor +to me
        loop
    } ; 
fast}

\ =============================================================================
\ Actor Errors
\ =============================================================================

: restore-sp ( a - )
    \ Restore SP. If debug mode is on, report stack imbalances.
    debug @ if
        \ Compare SP to previous SP.
        \ The data stack grows downward.
        dup sp@ cell+ cell+ > if
            s{ ." Positive stack imbalance in logic for actor " me .summary
            s} log-warning .rs .s 
        then
        dup sp@ cell+ cell+ < if
            s{ ." Negative stack imbalance in logic for actor " me .summary
            s} log-warning .rs .s
        then
    then
    sp! ;

: ?actorerr  
    catch ?dup -exit 
    dup err_bailed = if drop exit else me bench throw then ;

\ =============================================================================
\ Find actors
\ =============================================================================

class: %actor
    24 nprop tag$ :cstring <save
class;

|| 0 value xt

|| : (find) ( 0 %actor - 0|actor )
    dup -> en @ 0= if drop exit then    
    { xt execute if enough drop me then } ;

continuation: who> ( - actor|0 ) ( - f )
    ( xt ) to xt
    0 ['] (find) actors each ;

|| 0 value $

: tagged ( $ - actor|0 )
    to $ who> $ count tag$ count s= ;

\ =============================================================================
\ Actor management
\ =============================================================================

: priority ( n - )
    0 #actors 1 - clamp next# ! ;

|| : (behave)  actives> ?benched sp@ >r behave r> restore-sp ;
|| : (move)  actives> ?benched physics ;
|| : (+time)  +gametime actives> +time ;
|| : (step) ( - )
    ['] (behave) ?actorerr 
    ['] (move) ?actorerr 
    (+time) ;

%actor :: unload ( - )
    unloaded on ; 

: sweep ( - )
    actives> unloaded @ -exit en off ;

: step ( - )
    hold @ ?exit
    ['] (step) catch
    sweep
    ?dup if 
        hold on
        .throw 
    then 
;

: _clear-stage ( - )
    0 next# !  actives>  me unload ;

: clear-stage ( - )
    _clear-stage sweep ;

: just ( - )
    ." JUST : Clearing all actors!" cr
    clear-stage gamew 2 / gameh 2 / at  ;

: stage-init ( actor - )
    { ec ecp!  me actors slot>index id !   me init } ;

: stage-slot ( - actor )
    #actors for
        next# @ actor[] dup free? if
            unloop exit
        then  drop
        next# @ 1 + #actors mod next# !
    loop  -1 abort" one : Out of actors." ;

: one ( class - actor )
    >r stage-slot r> over construct dup stage-init ;
    
: *actor ( - %actor )
    %actor one ;

\ =============================================================================
\ Secondary actor storage
\ =============================================================================

|| variable tnext#
: temp[] ( n - a ) temps swap []@ ;
: *temp ( - a )
    #temps for
        tnext# @ temp[] dup free? if
            unloop exit
        then
        drop
        tnext# @ 1 + #temps mod tnext# !
    loop  -1 abort" Out of temps" ;

fast{
continuation: temps> ( - ) ( - )
    ( xt )  {: xt :}
    0 temp[] {
        #temps for
            en @ if xt execute then
            /actor +to me
        loop
    } ; 
fast} 

: clear-temps ( - )
    temps> me unload ;

\ =============================================================================
\ Script Classes
\ =============================================================================

: (actor-definition) ( class - )
    dup body>name >pad count >lowercase ?-%
    CurrSourceName -path -ext >lowercase 
    s= if
        private
    then
    >template to me \ allows immediate assignment of template (TODO: revisit)
;

%actor :derive ( source-class derived-class - )
    nip (actor-definition) ;

: hide-if-autoclass ( class - )
    \ Hide autoclass to fix LOCATE
    \ otherwise it would take us to the call to load-autoclasses
    \ even if it's been defined in a script
    dup -> autoclass @ if >name hidename else drop then ;

%actor :reopen ( class - )
    \ Hide generated autoclass when defining an actor class.
    \ This will cause a new class to be created. (see above for rationale)
    \ TODO: There's a better way: modify the class's source file string.
    \       (Hopefully there's a string pointer we can change.)
    \       This will prevent any dangling references to autoclasses.
    dup hide-if-autoclass
    (actor-definition) ;
    
: find-class ( a len - class | %actor )
    ?-% f" %%%s"
    sfind if execute else drop %actor then ;
