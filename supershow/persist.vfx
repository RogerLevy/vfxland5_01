bitmap>>

class: %bitmap
    is-a %totem
    extension: png
    default-dir: dat/gfx

    : add-bitmap-obj ( - )
        alloc-bmp# id ! 
        me id @ bitmap-objects [] ! ;

    :: load ( - ) 
        srcpath$ count 
        >zpad al_load_bitmap albmp ! 
        me new? if add-bitmap-obj then 
        albmp @ id @ bitmap[] ! ;

    :: _intake ( - ) 
        me load   me new? if does-bitmap then ;    
class;

: init-bitmaps ( - )
    %bitmap load-default-dir ;

public

class: %tileset
    is-a %totem
    extension: ts
    default-dir: dat/gfx
    format: TILESET_FORMAT_VERSION 

    prop bw \ parent %bitmap dims, used to determine if reallocating sub-bitmaps is needed
    prop bh 

    : bitmap-size-changed? ( - flag )
        bmp @ bmpw bw @ <>
        bmp @ bmph bh @ > or 
        bmp @ bmpwh bw 2! ;

    :: load ( - )
        \ slice up the tile set's source bitmap.
        \ if the tileset is being re-loaded, refresh the allocated bitmap range.
        me new?   bitmap-size-changed? or if 
            me slice-tileset
        else
            me update-tileset
        then ;

    :: unload ( - )
        #tiles @ for
            me i tile >albmp -albmp
        loop ;
class;

|| : des-tileset ( - )
    desbin>
        ['] into-me desbin+
        metas-array @ @array+ ;

class: %bitmap
    prop ts <ref %tileset
class;

%bitmap :: reload ( - )
    totem:reload
    ts @ ?dup if reload then ;

|| : reconnect-bmp ( - ) 
    my-name -ext f" %s.png" 
    >pad find 0= if
        drop 
        pad count f" RECONNECT-BMP : Tileset source bitmap %s not found" type cr
        exit
    then
    execute bmp !    \ Bitmap words return their own bitmap ID's
    me bmp @ bmpobj -> ts ! ;

%tileset :: _intake ( - )
    des-tileset   reconnect-bmp   me load ;

%tileset :: _keep ( - )
    serbin>
        me serbin,
        metas-array @ array, ;

: +tileset ( bmp# tw th <name> - )
    %tileset +totem { tw 2! bmp ! me } dup load keep ;

: init-tilesets
    %tileset load-default-dir ;

20 cell stack script-classes

class: %actor-script
    %asset derive
    static script-class \ <ref %class
    
    template {
        %actor script-class !
    }

    extension: vfx
    default-dir: scripts

    :: _intake ( - )
        me >r   srcpath$ count required   r> to me ;
class;

%actor-script script-classes push

%actor-script :derive ( parent derived - )
    nip 
    dup script-classes contains? if drop exit then
    script-classes push ;

%actor :: on-error ( xt err# - )
    {: xt err :}
    err -exit
    me bench
    xt .name ." : actor threw an error - disabling "
    me ['] .summary catch drop cr
    .s
    err throw ;


|| : has-image? f" %s.png" >pad find nip ;

: >default-dir ( fn len class - path len )
    -> default-dir$ count f" %s\%s" ;

: +script (  script-totem-class <basename> - %actor-script )
    \ Create an actor script containing some boilerplate.
    {: class0 | n[ 256 ] fn len :}
    bl parse f" %s.vfx" to len to fn
    fn len class0 >default-dir 2dup
    file-exists? abort" Script already exists"
    class0 materialize {
        my-name -ext n[ place
        srcpath$ count file-exists? not if
            srcpath$ count write{
                n[ count 
                f" class: %s" line,
                script-class @ body>name
                f"     %s derive" line,
                n[ count has-image? if
                    n[ count 
                    f"     template { %s.png bmp ! }" line,
                then
                s" class;" line,
                nl,
                n[ count 
                f" %s :: init ( - )" line,
                s"     act> ;" line,
                nl,
            write}
            srcpath$ count included
        then
        n[ count f" locate %s" evaluate 
        me 
    } ;

: +actor ( - <name> )
    %actor-script +script drop ;