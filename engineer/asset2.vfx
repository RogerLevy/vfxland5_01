trait: asset
\    static registry
    prop existed
    prop dirty
    256 nprop srcpath

    :: cleanup ( - ) ;                \ Free external resources (safe if empty)
    :: setup ( - ) ;                  \ Create/recreate external resources
    :: gen-path ( name len - a len ) stub ;  \ Generate file path from asset name (compile-time)
    :: save-content ( - ) ;                    \ Serialize asset to disk (dev-time)
    :: load-content ( - ) ;                    \ Deserialize asset from disk (runtime/dev-time)
    \ :: extension ( - a len ) stub ;
trait;

: my-name me body> >name count ;
: new? -> existed @ not ;

: find-asset ( $ - asset|0 )
    find if >body dup asset is? and else drop 0 then ;

|| : srcpath! ( fn len - )
    >abspath srcpath place ;

: materialize ( fn len class - obj )
    \ Find or create asset object by name (compile/runtime)
    {: fn len class0 :}
    fn len -path >pad find-asset ?dup 
    if dup -> existed on exit then 
    class0 fn len -path $object
    [[ my-name -ext me gen-path srcpath!   me ]] ;

: ?asset ( class <name> - obj )
    \ Parse name and materialize asset (compile-time)
    bl parse rot materialize ;

: manifest ( obj - )
    \ Initialize asset for use (runtime)
    as>
        existed @ if me cleanup then
        me setup 
        dirty on ;

asset :: save-content ( asset - )
    temp[ me serbin temp] 
    srcpath count 
    ['] write catch abort" File write error" ;

: into-me ( class - obj )
    drop   me ;

asset :: load-content ( asset - )
    srcpath count ['] file@ catch nip abort" File read error"
    ( a ) dup ['] into-me desbin drop  
    free throw ;

: commit ( asset - )
    \ Save asset to disk and clear dirty flag (dev-time)
    dup save-content   -> dirty off ;

|| 0 value class0

: load-asset ( fn len class - asset )
    \ Load single asset from file (runtime/startup)
    materialize dup load-content dup setup ;

|| : (load-asset) ( fn len - )
    class0 load-asset drop ;

: load-assets ( path-a path-len class - )
    \ Load all assets from directory (runtime/startup)
    \ TODO: filter by extension (single)
    to class0   ['] (load-asset) each-file ;

: refresh ( asset - )
    \ Reload asset from disk keeping same object (dev-time)
    dup load-content
    dup cleanup
    setup ;

|| : (refresh-asset) ( fn len - )
    class0 materialize refresh ;

: refresh-assets ( path-a path-len class - )
    \ Reload all assets in directory (dev-time hot-reload)
    \ TODO: filter by extension (single)
    to class0   ['] (refresh-asset) each-file ;


|| _trait object asset-fresh  
asset asset-fresh copy drop

: reset-asset-trait
    asset-fresh asset copy drop ;