((

[ ] IMPORT
[ ] IMPORT-DIR

SYNC
    go through all totem classes, loading totems from default directories
    according to their extension.  can be overriden by setting DISCOVER-XT
    of any totem class.
    
SAVE
    commits all dirty totems

:: INTAKE 
    load totem at discovery
    first load anything essential into the dictionary
    then optionally call LOAD to load more external resources, or defer for later
    INTAKE default: deserialize self

:: keep
    save relevant data to disk - any/all of the following:
        1. serialize self
        2. serialize some other objects
        3. save other data (such as bitmaps)
    COMMIT default: serialize self

))

trait: _totem

    prop existed
    prop dirty
    256 nprop srcpath$ <cstring         \ cstring: main file path

    4 nstatic extension$                \ cstring: main file extension
    /list nstatic instances             \ nib2 list, track instances
    static on-discovery-xt              \ ( path len class - ) 
    256 nstatic default-path$           \ Where +TOTEM locates assets by default 

    :: load ( - ) ;                     \ Load/create external resources.  optional.
    :: unload ( - ) ;                   \ Free external resources.  optional.
    :: intake ( - ) ;                   \ Load from filesystem.
    :: keep ( - ) ;                   \ Save to disk.
    
trait;

_totem :apply ( class - )
    {: class0 :}
    class0 reopened? not if
        \ new totem classes get their own blank list
        0 class0 -> instances list-count! 
    then ;

\ =============================================================================
\ Utilities
\ =============================================================================

: my-name me body> >name count ;
: new? -> existed @ not ;
: srcpath! ( path len totem - ) [[ >abspath srcpath$ place ]] ;
: find-totem ( a len - totem|0 )
    -path >pad find if >body dup _totem is? and else drop 0 then ;
: ext? ( fn len ext len - flag ) 2swap '.' ending compare 0= ;
: correct-ext? ( fn len class - flag ) -> extension$ count ext? ;
: ?toolong  udup > abort" Extension must be 3 chars or less." ;
: extension: ( <ext> - ) bl parse 3 ?toolong classifier -> extension$ place ;
: default-path: ( <path> - ) bl parse classifier -> default-path$ place ;

\ =============================================================================
\ Materialization
\ =============================================================================

: materialize ( path len class - totem ) ( - totem )
	\ ensure totem is in dictionary.
    \ takes file name or path.
	\ if we create the totem word, set its srcpath$ and set DIRTY flag.
    \ if word already existed, set EXISTED flag
    {: path len class0 :}
    path len find-totem ?dup 
    if 
        dup -> existed on 
    else 
        class0 path len -path $object
        [[ 
            path len me srcpath!
            dirty on
        me ]]
        dup class0 -> instances add-to
    then ;

|| : @default-path
    my-name
    default-path$ count f" %s/%s" me srcpath! ;

: +totem ( class <name> - totem ) ( - totem )
    \ usage: +totem <name> ...
    bl parse   rot materialize [[ @default-path   me ]] ;

: manifest ( path len class - totem )
    \ materialize (create/find) and if created, intake (load).
    \ accepts either names or paths.
    \ if a name is given, the class's default path becomes the totem's dir path.
    \ use this to load dependencies.
    \ example: world totem that loads tilemaps and tilesets
    {: path len class0 :}
    path len file-exists? not if
        path len
        class0 -> default-path$ count f" %s/%s" to len to path
    then

    path len class0 materialize dup new? if 
        dup -> dirty off dup intake 
    then ;

\ =============================================================================
\ Loading/reloading
\ =============================================================================

: reload ( totem - )
    [[
        me new? not if me unload then
        dirty off
        me intake
    ]] ;

|| 0 value class0

|| : (discover) ( fn len - )

    \ execute on-discovery override if any
    class0 -> on-discovery-xt @ ?dup if
        >r 2dup type cr r>
        class0 swap ( fn len class xt ) execute
        exit
    then

    \ check extension
    class0 -> extension$ @ if
        2dup class0 correct-ext? not if
            2drop exit 
        then 
    then

    class0 materialize reload ;

: load-dir ( path-a path-len class - )
    \ (Re-)load all totems in given directory
    \ Not recursive.
    \ If class's extension$ is empty, include directories in discovery
    
    11 push-attribute
    dup body> >name count f" Loading %s totems..." type cr
    pop-attribute
    
    to class0   
    
    ['] (discover) 
    
    class0 -> extension$ c@ if
        each-file
    else
        each-file-and-dir 
    then ;

: load-default-dir ( class - )
    \ Not recursive.
    dup -> default-path$ count rot load-dir ;

\ =============================================================================
\ I/O
\ =============================================================================

|| 0 value (dest)
|| : into-dest ( class - obj )
||     drop   (dest) ;

: into-me ( class - obj )
    drop   me ;

: deserialize ( path len dest-a - )
    (dest) >r
    to (dest)   ['] file@ catch nip abort" File read error"
    ( a ) dup >r ['] into-dest desbin drop  
    r> free throw
    r> to (dest) ;

: serialize ( obj path len - )
    2>r temp[ ( obj ) serbin temp]
    2r> ['] write catch abort" File write error" ;

: commit ( totem - )
    as>   
        dirty @ -exit   
        srcpath$ count -file ensure-dir
        me keep   
        my-name f" Saved %s" type
        dirty off ;

: save ( - )
    _totem -> dependents list-count for
        @next 
        dup body> >name count f" Saving %s totems..." type cr
        -> instances list-count for
            @next commit
        loop drop
    loop drop ;

: sync ( - )
    \ (re)load everything; adds undefined totems and updates existing ones
    \ (NOTE: currently from default directories only)
    \ TODO: update/create intelligently (in default dirs) and support 
    \ syncing all instances, even those not in default directories.

    _totem -> dependents list-count for
        @next load-default-dir
    loop drop ;

: mark-dirty ( totem - )
    -> dirty on ;

\ =============================================================================
\ Defaults

_totem :: intake ( - )
    srcpath$ count me deserialize ;

_totem :: keep ( - )
    me srcpath$ count serialize ;

\ =============================================================================

|| _trait object _totem-fresh  
_totem _totem-fresh copy drop

: reset-totem-trait
    _totem-fresh _totem copy drop ;

