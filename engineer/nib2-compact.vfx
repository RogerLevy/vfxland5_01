\ Compact class syntax parser for NIBS
\ Claude gets confused by files that use this, so there's an automatic 
\ Python script to perform expansion, but it's still useful for quick
\ experiments and stuff that I don't need help from Claude with.

: number? ( a len - f )
    isnumber? case
        1 of drop -1 exit endof
        2 of drop drop -1 exit endof
        -2 of fdrop -1 exit endof
    endcase
    0 ;

: size? ( $ - f )
    \ number or /size or s/size
    {: $ :}
    $ count number? ?dup ?exit
    $ 1 + c@ '/' = ?dup ?exit
    $ 2 + c@ '/' = ?dup ?exit
    0 ;

: "word"? ( $ - f )
    {: $ :}
    $ 1 + c@ '"' =
    $ count + 1 - c@ '"' = and ;
    
: eval  bl parse evaluate ;
: consume  bl parse 2drop ;
: pre-xt  preword count 1 /string >pad find 0<> and ;
: @size  preword size? if eval else cell then ;
: comment?  preword 1 + c@ dup '\' = swap '(' = or ;
: eol?  preword c@ 0= ;
: ?term preword 1 + c@ ';' = dup if consume then ;

: *property ( - )
    bl parse 2dup
    >pad find if
        >body valid-classifier? if
            >pad count fe" '%s' is a classifier name. Use @class, +trait, or \"trait\" syntax."
            -1 -rot .abort
        then
    else drop then
    @size
    f" %n nproperty %s" evaluate ;

: is-class? ( ? - f )
    dup valid-object? not if drop 0 exit then
    -> cla @ _class = ;

: ?class ( - f ) 
    preword 1 + c@ '@' <> if 0 exit then
    pre-xt dup 0= if consume -1 abort" Token not found." then
    >body dup is-class? not if
        consume -1 abort" Token preceded by @ must be a class."
    then
    derive -1 consume ;

: "trait" ( $ - a len )
    {: $ :}
    $ 2 + $ count nip 2 - ;

: is-trait? ( ? - f )
    dup valid-object? not if drop 0 exit then
    -> cla @ _trait = ;
    
: ?"trait" ( - f )
    preword "word"? if
        bl word "trait" >pad find
        0= if consume -1 abort" Token not found." then
        >body dup is-trait? not abort" Token surrounded by quotes must be a trait." 
        ( trait ) classifier 0 apply-trait
        -1
    else 0 then ;

: ?trait ( - f ) 
    ?"trait" ?dup ?exit
    preword 1 + c@ '+' <> if 0 exit then
    pre-xt dup 0= if consume -1 abort" Token not found." then
    >body dup is-trait? not if
        consume -1 abort" Token preceded by + must be a trait."
    then
    classifier -1 apply-trait consume -1 ;
    
: ?comment
    comment? abort" Comments not allowed in compact class definitions."  ;
    
: ?invalid
    preword size? if
        consume
        -1 abort" Invalid token."
    then
    ?comment ;

: token ( - )
    ?invalid
    ?class ?exit
    ?trait ?exit
    *property ;

: ?fieldspace ( - ) 
    preword size? if eval field-space then ;    

: next-line
    refill 0= abort" Unexpected end of file."
    eol? abort" Blank line encountered; check for missing semicolon." ;

: c:
    class:
    ?comment
    eol? if next-line then
    ?fieldspace
    begin ?term not while
        token
        eol? if next-line then
    repeat
    class; ;

\\
\ Test:

trait: thinker trait;
trait: _lifo trait;
512 constant /actor

c: thingy ;
c: actor  /actor  @thingy  +_lifo  "thinker"
    en buf 256 x y vx vy ;
