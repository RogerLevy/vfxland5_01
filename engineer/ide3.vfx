\ -------------------------------------------------------------------------------
\ IDE v3 - Next-Level Development Interface (now utilizing OOP for display modes) 
\ -------------------------------------------------------------------------------

fast{

public

defer draw-ide

|| : ?game-throw ( n - ) 
    dup -1 = if drop exit then
    dup if going off >vfx then throw ;

: draw-game ( - ) 
    at@ 2>r
    cls
    repl @ if save-kb erase-kb then 
    'show @ catch ?game-throw
    repl @ if restore-kb then  
    2r> at ;

private

aka dup-endcase end-case
aligned-page uios
variable uiosp  uios uiosp !
variable display-mode  \ 0 = IDE, 1 = Fullscreen (game), 2 = Windowed (game)
variable old-hold

: ?type ?dup 0= if drop else type then ;

create scalexy 0 , 0 ,
create (pen) 0 , 0 , 

continuation: scaled>  ( x. y. - <code> ; )
    ( xt ) >r 2dup scalexy 2! m{ 0e 0e 2p>f 0e transform r> ( xt ) execute m} ;

: scaled-at ( x y - )
    scalexy 2@ 2p/ at ;

\ =============================================================================
\ History I/O device
\ =============================================================================

include %idir%/history.vfx   \ private to this file's vocabulary

\ =============================================================================
\ IDE Components Display
\ =============================================================================

variable active  active on

variable stack-mode
stack-mode jumptable ?.   ' . , ' p. , ' h. , ' .name ,
: ints  0 stack-mode ! ;
: fixes  1 stack-mode ! ;
: hexes  2 stack-mode ! ;
: names  3 stack-mode ! ;
: +stackmode  stack-mode @ 1 + 4 mod stack-mode ! ;

variable hsplit   0.5 hsplit !

: split-x ( - x )
    winw hsplit @ p* ;

: from-bottom ( y - y )
    winh swap - ;

: lines ( n - h )
    24 * ;

: zoomed-game z >p dup scaled> draw-game ;

: margin-x  split-x 2 / appw 2 / z * - ;
: margin-y  z 1 = if 200 else 50 then ;
: gamewin-w appw z * margin-x 2 * + ;
: gamewin-h apph z * margin-y 2 * + ;
: game-window ( - )
    monw gamewin-w - 0 gamewin-w gamewin-h al_set_clipping_rectangle

    m{
    identity
    monw gamewin-w - margin-x +
    margin-y
    2s>f 1e 1e 0e transform

    zoomed-game
    out @ if cr then

    1e f>ds >r \ thickness
    -1e -1e 
    appw z * 1 + 
    apph z * 1 + 2s>f 
    hold @ if
        1e 0.25e 0.25e 1e \ red
    else
        repl @ if 
            0.33e fdup fdup 1e \ dark-grey
        else
            1e 1e 1e 1e \ white
        then
    then
    r> al_draw_rectangle
    
    m}
    0 0 monw monh al_set_clipping_rectangle ;

\ borrow engineer>> func[]
: .hotkeys ( - )
    s" Alt+Enter=Display  Tab=REPL  Esc=Quit  Alt+F4=Bye  CTRL+\=Stack" type cr
    12 for
        i func[] c@ if
            i func[] count >uppercase i 1 + f" F%n=%s  " type
        then
    loop ;

: .honing ( - )
    honing @ if ." ON  " else ." OFF  " then ;

: .ld-action ( - )
    ld-action$ count ?type space space ;

: .state ( - )
    state @ if ." COMPILING  " else ." INTERPRETING  " then ;

: .unused ( - )
    unused .comma ."  bytes" ;

: .hold ( - )
    hold @ if ." ON  " else ." OFF  " then ;

: .watch ( - )
    watch-xt @ -exit
    watch-context @ .name
    \ ." >> "
    watch$ count ?type cr
    push-order
    only forth watch-context @ +order
    s{ watch-xt @ catch drop s} ?type
    pop-order
    ;

: .me ( - )
    \ Display current object info if valid, used in REPL debugging
    me valid-object? -exit  me ['] .summary catch drop ;

: info-box ( - )
    1. 2. scaled>
    split-x gamewin-h scaled-at
    s{
        .hotkeys cr
        ." Me: " .me cr 
        ." WD: " wd@ '\' ending type space space
        ." Current: " current @ .name space
        ." Pen: " (pen) 2@ swap . . space
        ." State: " .state space
        ." Hold: " .hold space
        ." Dict free: " .unused cr 
        ." Honing: " .honing
        ." Load action: " .ld-action cr
        ." Watch: " cr .watch cr
    s} 12 print2 ;

: user-area ( - )
    1. 2. scaled>
    split-x gamewin-h 8 lines + scaled-at
    s" (User Area)" print ;

: command-history ( - )
    1. 2. scaled>
    \ split-x s>f 0e 1e 1e 0e transform
    0 0 at   draw-history ;

: ?.s ( - )
    depth | d |
    d 0 max 0 ?do d 1 - i - pick ?. loop
    cr ; 

: stack-display ( - )
    1. 2. scaled>
    0 6 lines from-bottom scaled-at
    s{ ?.s s} 12 print2 ;

: .tib ( - )
    context @ .name
    \ ." >> "  
    tib #tib @ ?type ;

: command-line ( - )
    1. 2. scaled>
    0 1 lines from-bottom scaled-at
    repl @ if 15 else 8 then color 
    s{
        .tib
        active @ repl @ and if
            counter 20 / 8 and if ." _" then
        then
    s} 
    print 
    15 color 
;
    
: ide-layout ( - )
    \ title-bar
    game-window     command-history
    info-box        stack-display
    ( user-area )   command-line ;

\ =============================================================================
\ IDE Logic
\ =============================================================================

: ShowErrorLine	
  line# @ -1 <> if
    ." Source: "
    [char] " emit  'SourceFile @ .SourceName  [char] " emit
    ."  on line "
    base @ >r  decimal  line# @ .  r> base !
    cr
  then
;

: ShowSourceOnError     
  >in @ -1 <> if
    ."  -> " source type cr
    >in @ 3 + spaces [char] ^ emit cr
    ShowSourceOnErrorHook
  then
;

: .source-line  ShowErrorLine ShowSourceOnError ;

: (DoErrorMessage) ( err - )
    15 4 push-attributes
    dup -13 = if
        drop
        lastword count type ." ? " 
    else
        dup Err$ nip if			\ if text available
            .ErrDef     		\ generate error message
        else
            ." No text available for THROW code #" #.
        then
        cr 
        .source-line
    then
    pop-attribute
    ide @ if EditOnError then ;
assign (DoErrorMessage) to-do DoErrorMessage

: (DoAbortMessage) $. .source-line ;
assign (DoAbortMessage) to-do DoAbortMessage

\ : .throw ( n - )
\     case
\         0 of  endof				                    \ not an error
\         -1 of  endof				                \ quiet
\         -2 of  'AbortText @ DoAbortMessage  endof	
\         .error  
\     end-case ;

: obey ( - )
    osp @ >r uiosp @ osp !
    .tib cr 
    tib #tib @ interpret-string
    out @ if cr then
    ?dup if .throw cr rs state off then 
    0 #tib ! 
    osp @ uiosp ! r> osp !
    checkdict ;

: ide-char ( n - )
    case
        ( bksp ) 8 of #tib @ -exit -1 #tib +! exit endof
        ( tab ) 9 of exit endof
        ( enter ) 13 of alt? not if obey then exit endof
        ( esc ) 27 of exit endof
    dup-endcase
    dup 32 < over 127 = or if drop exit then
    tib #tib @ + c! 1 #tib +! ;

: ide-key ( n - )
    case
        <up> of scroll-up endof
        <down> of scroll-down endof
        <pad8> of scroll-up endof
        <pad2> of scroll-down endof
        <pgup> of page-up endof
        <pgdn> of page-down endof
        <pad9> of page-up endof
        <pad3> of page-down endof
        <home> of scroll-to-top endof
        <end> of scroll-to-bottom endof
        <pad7> of scroll-to-top endof
        <pad1> of scroll-to-bottom endof
        drop
    end-case ;

: repl-events ( - )
    ALLEGRO_EVENT_KEY_DOWN happened? if
        ctrl? not alt? not and if
            the-key <tab> = if
                repl toggle
                repl @ not if hold off then
            then
            the-key <`> = if
                ide @ not if
                    repl toggle
                then
            then
        then
    then
    ALLEGRO_EVENT_KEY_CHAR happened? if
        repl @ ctrl? not and alt? not and if
            the-char ide-char
            the-key ide-key
        then
    then 
    ALLEGRO_EVENT_DISPLAY_SWITCH_OUT happened? if
        active off
        repl @ if ( hold @ old-hold ! ) hold on then
    then
    ALLEGRO_EVENT_DISPLAY_SWITCH_IN happened? if
        active on
        repl @ not if hold off then
        ide @ if hold on then
        \ ide @ repl @ not and if hold off then
        \ ide @ repl @ and if old-hold @ hold ! then
    then ;

\ =============================================================================
\ Display Modes
\ =============================================================================

\ borrow engineer>> fullscreen
\ borrow engineer>> windowed
\ borrow engineer>> winmode
\ borrow engineer>> draw-tv

\ %displaymode-like trait
trait: %displaymode-like
    redef prop _ide
    redef prop _repl
    redef prop _hold
    static draw-xt
trait;

%displaymode-like :: activate ( - ) stub ;
%displaymode-like :: draw ( - ) stub ;

\ IDE mode
class: %ide-mode
    is-a %displaymode-like
class;

%ide-mode :: activate ( - )
    fullscreen winmode ;

: %ide-mode-draw ( - )
    at@ (pen) 2! 
    hold @ if repl on then
    ['] ide-layout catch drop 
    (pen) 2@ at ;

' %ide-mode-draw %ide-mode -> draw-xt !

0 %ide-mode :construct ( - )
    _ide on _repl on ;

\ Full mode
class: %full-mode
    is-a %displaymode-like
class;

%full-mode :: activate ( - )
    fullscreen winmode ;

: %full-mode-draw ( - )
    ['] draw-game draw-tv
    ( TODO: draw repl ) ;

' %full-mode-draw %full-mode -> draw-xt !

\ Window mode
class: %window-mode
    is-a %displaymode-like
class;

%window-mode :: activate ( - )
    windowed winmode ;

: %window-mode-draw ( - )
    ?border draw-game
    ( draw repl here ) ;

' %window-mode-draw %window-mode -> draw-xt !

\ Create array of display modes
%ide-mode object ide-mode0
%full-mode object full-mode0
%window-mode object window-mode0

display-mode jumptable current-mode
    ' ide-mode0 , ' full-mode0 , ' window-mode0 ,

\ Redefine ide and repl to point to current mode's properties
:noname ( - a ) current-mode -> _ide ; is ide
:noname ( - a ) current-mode -> _repl ; is repl
:noname ( - a ) current-mode -> _hold ; is hold

: enact-display-mode ( - )
    current-mode activate ;

: draw-display-mode ( - )
    current-mode { draw-xt } @ execute ;

\ =============================================================================
\ Public Words
\ =============================================================================

\ borrow engineer>> -keys

public

: ide-?w/f ( - )
    <enter> pressed?  alt? and if
        \ Toggle between 3 states: windowed, fullscreen (IDE), and fullscreen (game)
        display-mode @ 1 + 3 umod display-mode !
        enact-display-mode
        -keys
    then ;

: ide-events ( - )
    debug @ if
        ide @ if
            repl-events

            ALLEGRO_EVENT_KEY_DOWN happened? if
                the-key <f1> - 0 12 within? if
                    the-key ?func
                then
                ctrl? if
                    the-key <\> = if +stackmode exit then
                then
            then

            ALLEGRO_EVENT_KEY_CHAR happened? if
                ctrl? if
                    1 pad c!
                    the-char pad 1 + c! 
                    pad f" ctrl+%$" >pad find if execute else drop then
                then
            then

        then

        ALLEGRO_EVENT_DISPLAY_SWITCH_IN happened? if
            onSwitchIn
        then
    then ;

:noname ( - )
    ?dirchange 
    m{ identity cls draw-display-mode m} ;
is draw-ide

|| variable running

: >ide ( - )
    \ Switch to IDE mode with proper visual formatting
    running on 
    hist{ 7 attribute
    enact-display-mode
    >display 
    rs ;

: .rainbow
    bounds do
        i c@ dup emit
        bl <> if
            attr @ 1 + 15 and dup 0= if 2 + then attribute
        then
    loop
    7 attribute ;

: welcome
    hist{  10 attribute  s" Welcome to VFX Land!" .rainbow cr   hist} ;

: init-ide ( - )
    init-history
    monh 7 lines - 24 / visible-lines !
    0 display-mode !
    welcome ;

: ide-interpret ( a len - res )
    hist{ interpret-string out @ if cr then hist} ;

: ide-quit
    ." IDE-QUIT" cr
    running off
    consoledev setio
    ((quit))
;

borrow error2>> console-debugger
: ide-debugger
    running @ if hist{ 15 4 push-attributes then
    console-debugger
    running @ if pop-attribute hist} then
;

[defined] native-debugger not [if]
    ' ide-debugger to-callback debugger
[then]

' ide-quit is quit
' noop is boot
' noop is onSwitchIn
init-history

fast}
