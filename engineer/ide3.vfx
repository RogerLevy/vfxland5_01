\ -------------------------------------------------------------------------------
\ IDE v3 - Next-Level Development Interface (now utilizing OOP for display modes) 
\ -------------------------------------------------------------------------------

fast[

public

defer draw-ide

private   
include %idir%/history.vfx   \ private to this file's vocabulary

synonym dup-endcase end-case
aligned-page uios
variable uiosp  uios uiosp !
variable display-mode  \ 0 = IDE, 1 = Fullscreen (game), 2 = Windowed (game)
variable old-hold

: ?type ?dup 0= if drop else type then ;

create scalexy 0 , 0 ,
create (pen) 0 , 0 , 

: scaled>  ( x. y. - <code> ; )
    2dup scalexy 2! +m 0e 0e 2p>f 0e transform r> execute -m ;

: scaled-at ( x y - )
    scalexy 2@ 2p/ at ;

\ =============================================================================
\ History I/O device
\ =============================================================================

create str 256 allot
0 value >str

: pagealign ( - )  here $ff and 256 swap - allot ;
: aligned-page ( - <name> )  pagealign here $100 allot&erase constant ;
aligned-page hist-stack
variable hsp   hist-stack hsp ! 
: hist-push ( ? - ) hsp @ !  4 hsp c+! ;
: hist-pop ( - ? ) -4 hsp c+!  hsp @ @ ;

: hist-emit ( c sid - )
    drop  
    >str 256 = if drop exit then
    str >str + c!  1 +to >str  1 out +! ;

: hist-type ( a len - )
    drop  bounds ?do  i c@ 0 hist-emit  loop ;

: (echo) ( - )
    \ Echo to VFX console
    {: | skip :} 
    >str -exit
    op-handle @ >r
    consoledev op-handle !
    str >str bounds do
        1 to skip
        i c@ ATTR_FG = if 3 to skip then
        i c@ ATTR_BG = if 3 to skip then
        skip 1 = if
            i c@ 10 ATTR_CODES 1 - within if i c@ emit then
        then
    skip +loop
    r> op-handle ! ;

: hist-cr
    drop
    10 emit
    refresh-attribute
    (echo)
    str >str add-history
    0 to >str
    0 out !
    ;
    
create vectors
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' hist-emit ,
  ' drop ,
  ' hist-type ,
  ' hist-cr ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,
  ' drop ,

create hist-dev   0 , vectors ,

: hist[ ( - )
    op-handle @ hist-push
    textmode @ hist-push textmode on 
    >str out !
    hist-dev op-handle ! ;

: hist] ( - )
    hist-pop textmode ! 
    hist-pop op-handle !
    str >str add-history
    (echo)
    0 to >str ;

\ =============================================================================
\ IDE Components Display
\ =============================================================================

variable active  active on
variable stackmode
stackmode jumptable ?.
    ' . , ' p. , ' h. , ' .name ,

\ : win/ ( x. y. - x y )
\     winw winh 2swap 2p* ;
\ 
\ : pos ( x. y. - )
\     \ Position the pen proportionally to the display
\     win/ at ;

variable hsplit   0.5 hsplit !

: split-x ( - x )
    winw hsplit @ p* ;

: from-bottom ( y - y )
    winh swap - ;

: lines ( n - h )
    24 * ;

borrow engineer/ draw-game
: (2x-game) 2. 2. scaled> draw-game ;
: gamewin-h apph 2 * 100 + ;
: game-window ( - )
    split-x  0 monw 2 / gamewin-h al_set_clipping_rectangle

    +m
    identity
    monw 4 / appw - 2 +  split-x +
    gamewin-h 2 / apph - 2 +
    2s>f 1e 1e 0e transform

    
    hist[
    (2x-game)
    >str if cr then
    hist]
  

    1e f>ds >r
    -1e -1e appw 2 * 1 + apph 2 * 1 + 2s>f 
    hold @ if
        1e 0.25e 0.25e 1e \ red
    else
        repl @ if 
            1e 1e 1e 1e \ white
        else
            0e 1e 0.5e 1e \ green
        then
    then
    r> al_draw_rectangle
    
    -m
    0 0 monw monh al_set_clipping_rectangle ;

borrow engineer/ func[]
: .hotkeys ( - )
    s" Alt+Enter=Display  Tab=REPL  Esc=Quit  Alt+F4=Bye  " type cr
    12 for
        i func[] c@ if
            i func[] count 2dup upper i 1 + f" F%n=%s  " type
        then
    loop ;

: .honing ( - )
    honing @ if ." ON  " else ." OFF  " then ;

: .ld-action ( - )
    ld-action$ count ?type space space ;

: .state ( - )
    state @ if ." COMPILING  " else ." INTERPRETING  " then ;

: .unused ( - )
    unused .comma ."  bytes" ;

: .hold ( - )
    hold @ if ." ON  " else ." OFF  " then ;

: .watch ( - )
    watch-xt @ -exit
    watch-context @ .name
    ." >> "
    watch$ count ?type cr
    push-order
    only forth watch-context @ +order
    s[ watch-xt @ catch drop s] ?type
    pop-order
    ;

: .me ( - )
    \ Display current object info if valid, used in REPL debugging
    me valid-object? -exit  me ['] .summary catch drop ;

: info-box ( - )
    1. 2. scaled>
    split-x gamewin-h scaled-at
    s[
        .hotkeys cr
        ." Me: " .me cr 
        ." CWD: " path '\' ending type space space
        ." Current: " current @ .name space
        ." Pen: " (pen) 2@ swap . . space
        ." State: " .state space
        ." Hold: " .hold space
        ." Dict free: " .unused cr 
        ." Honing: " .honing
        ." Load action: " .ld-action cr
        ." Watch: " cr .watch cr
    s] 12 print2 ;

: user-area ( - )
    1. 2. scaled>
    split-x gamewin-h 8 lines + scaled-at
    s" (User Area)" print ;

: command-history ( - )
    1. 2. scaled>
    \ split-x s>f 0e 1e 1e 0e transform
    monh 7 lines - 24 / visible-lines !
    0 0 at
    s[ render-history s] print-colorful ;

: ints  0 stackmode ! ;
: fixes  1 stackmode ! ;
: hexes  2 stackmode ! ;
: names  3 stackmode ! ;

: ?.s ( - )
    depth | d |
    d 0 max 0 ?do d 1 - i - pick ?. loop
    cr ; 

: stack-display ( - )
    1. 2. scaled>
    0 6 lines from-bottom scaled-at
    s[
        names ?.s
        ints ?.s
        fixes ?.s
        hexes ?.s
        \ f.s
    s] 12 print2 ;

: .tib ( - ) 
    context @ .name
    ." >> "  tib #tib @ ?type ;

: command-line ( - )
    1. 2. scaled>
    0 1 lines from-bottom scaled-at
    s[
        .tib
        active @ repl @ and if
            counter 20 / 8 and if ." _" then
        then
    s] print ;
    
: ide-layout ( - )
    textmode off
    \ title-bar
    game-window     command-history
    info-box        stack-display
    ( user-area )   command-line ;

\ =============================================================================
\ IDE Logic
\ =============================================================================

: ShowErrorLine	
  line# @ -1 <> if
    ."  Source: "
    [char] " emit  'SourceFile @ .SourceName  [char] " emit
    ."  on line "
    base @ >r  decimal  line# @ .  r> base !
  then
;

: ShowSourceOnError     
  >in @ -1 <> if
    ."  -> " source type cr
    >in @ 3 + spaces [char] ^ emit
    ShowSourceOnErrorHook
  then
;

: (DoErrorMessage) ( err - )
    4 push-attribute
    dup -13 = if
        lastword count type ." ? " 
    else
        dup Err$ nip if			\ if text available
            .ErrDef     		\ generate error message
        else
            ." No text available for THROW code "
            base @ >r  decimal 0 .r ." (10)"  r> base !
        then
        cr 
        ShowErrorLine
        ShowSourceOnError
    then
    pop-attribute
    EditOnError ;

assign (DoErrorMessage) to-do DoErrorMessage

: (interpret)	\ --
    page-check
    begin  
        ?stack 
        parse-name 
        2dup lastword place
        dup
    while
        parser execute
    repeat
    2drop ;

' (interpret) is interpret

\ : .throw ( n - )
\     case
\         0 of  endof				                    \ not an error
\         -1 of  endof				                \ quiet
\         -2 of  'AbortText @ DoAbortMessage  endof	
\         .error  
\     end-case ;

: obey ( - )
    osp @ >r uiosp @ osp !
    .tib cr 
    tib #tib @ >interpret
    >str if cr then
    ?dup if .throw cr rs state off then 
    0 #tib ! 
    osp @ uiosp ! r> osp !
    checkdict ;

: ide-char ( n - )
    alt? if drop exit then
    case
        ( bksp ) 8 of #tib @ -exit -1 #tib +! exit endof
        ( tab ) 9 of exit endof
        ( enter ) 13 of alt? not if obey then exit endof
        ( esc ) 27 of exit endof
    dup-endcase
    dup 32 < over 127 = or if drop exit then
    tib #tib @ + c! 1 #tib +! ;

: ide-key ( n - )
    case
        <up> of scroll-up endof
        <down> of scroll-down endof
        <pad8> of scroll-up endof
        <pad2> of scroll-down endof
        <pgup> of page-up endof
        <pgdn> of page-down endof
        <pad9> of page-up endof
        <pad3> of page-down endof
        <home> of scroll-to-top endof
        <end> of scroll-to-bottom endof
        <pad7> of scroll-to-top endof
        <pad1> of scroll-to-bottom endof
        drop
    end-case ;

: repl-events ( - )
    ALLEGRO_EVENT_KEY_DOWN happened? if
        the-key <tab> = if
            repl toggle
            repl @ not if hold off then
        then
        the-key <`> = if
            ide @ not if
                repl toggle
            then
        then
    then
    ALLEGRO_EVENT_DISPLAY_SWITCH_OUT happened? if
        active off
        ide @ if hold @ old-hold ! hold on then
    then
    ALLEGRO_EVENT_DISPLAY_SWITCH_IN happened? if
        active on
        ide @ repl @ not and if hold off then
        ide @ repl @ and if old-hold @ hold ! then
    then
    repl @ if
        ALLEGRO_EVENT_KEY_CHAR happened? if
            the-char ide-char
            the-key ide-key
        then
    then ;

\ =============================================================================
\ Display Modes
\ =============================================================================

borrow engineer/ fullscreen
borrow engineer/ windowed
borrow engineer/ winmode
borrow engineer/ draw-tv

\ Displaymode-like trait
trait: displaymode-like
    prop _ide
    prop _repl
    prop _hold
    static draw-xt
trait;

displaymode-like :: activate ( - ) stub ;
displaymode-like :: draw ( - ) stub ;

\ IDE mode
class: ide-mode
    is-a displaymode-like
class;

ide-mode :: activate ( - )
    fullscreen winmode ;

: ide-mode-draw ( - )
    at@ (pen) 2! ['] ide-layout catch drop (pen) 2@ at ;
' ide-mode-draw ide-mode -> draw-xt !

0 ide-mode :construct ( - )
    _ide on _repl on ;

\ Full mode
class: full-mode
    is-a displaymode-like
class;

full-mode :: activate ( - )
    fullscreen winmode ;

: full-mode-draw ( - )
    draw-tv
    ( draw repl here ) ;
' full-mode-draw full-mode -> draw-xt !

\ Window mode
class: window-mode
    is-a displaymode-like
class;

window-mode :: activate ( - )
    windowed winmode ;

: window-mode-draw ( - )
    ?border draw-game
    ( draw repl here ) ;
' window-mode-draw window-mode -> draw-xt !

\ Create array of display modes
ide-mode object ide-mode0
full-mode object full-mode0
window-mode object window-mode0

display-mode jumptable current-mode
    ' ide-mode0 , ' full-mode0 , ' window-mode0 ,

\ Redefine ide and repl to point to current mode's properties
:noname ( - a ) current-mode -> _ide ; is ide
:noname ( - a ) current-mode -> _repl ; is repl
:noname ( - a ) current-mode -> _hold ; is hold

: enact-display-mode ( - )
    current-mode activate ;

: draw-display-mode ( - )
    current-mode [[ draw-xt ]] @ execute ;

\ =============================================================================
\ Public Words
\ =============================================================================

borrow engineer/ -keys

public

: ide-?w/f ( - )
    <enter> pressed?  alt? and if
        \ Toggle between 3 states: windowed, fullscreen (IDE), and fullscreen (game)
        display-mode @ 1 + 3 umod display-mode !
        enact-display-mode
        -keys
    then ;

: ide-events ( - )
    debug @ if
        hist[
        ALLEGRO_EVENT_KEY_DOWN happened? if
            the-key <f1> - 0 12 within? if
                the-key ?func
            then
        then
        repl-events
        hist] 
    then ;

:noname ( - )
    +m identity cls draw-display-mode -m ;
is draw-ide

|| variable running

: >ide ( - )
    \ Switch to IDE mode with proper visual formatting
    running on 
    hist[ 7 attribute hist]
    enact-display-mode
    >display ;

: .rainbow
    bounds do
        i c@ dup emit
        bl <> if
            attr @ 1 + 15 and dup 0= if 2 + then attribute
        then
    loop
    7 attribute ;

: welcome
    hist[  10 attribute  s" Welcome to VFX Land!" .rainbow cr   hist] ;

: init-ide ( - )
    init-history
    0 display-mode !
    >ide
    welcome ;

: ide-interpret ( a len - res )
    hist[ >interpret out @ if cr then hist] ;

: ide-quit
    ." IDE-QUIT" cr
    running off
    textmode off
    consoledev setio
    ((quit))
;

borrow error2/ console-debugger
: ide-debugger
    running @ if hist[ 4 push-attribute then
    console-debugger
    running @ if hist] then
;

' ide-debugger to-callback debugger
' ide-quit is quit
' noop is boot
' noop is onSwitchIn
init-history

fast]
