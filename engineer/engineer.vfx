\ ------------------------------------------------------------------------------
\ Engineer v1
\ ------------------------------------------------------------------------------

\ =============================================================================
\ Core System Components
\ =============================================================================

include %idir%\vfxcore.vfx

\ =============================================================================
\ Engineer Variables
\ =============================================================================

variable 'show ( - ) \ app logic and rendering
' noop 'show !
defer desktop ( - ) \ default behavior of SHOW (restored on EMPTY)
defer boot ( - ) \ app startup code like loading assets
defer onSwitchIn ( - ) \ Window gets focus
variable debug  debug on
variable going
variable bye-chain
cstring home-path$
create funcs 256 12 * allot&erase
0 value reload-shift?
variable repl  repl on   \ enable commandline
variable ide   ide on    \ enable IDE mode (enables commandline automatically)
defer pump ' noop is pump
cstring watch$
variable watch-xt
variable watch-context
variable hold            \ HOLD ON / HOLD OFF to stop/resume logic updates

\ =============================================================================
\ System Integration
\ =============================================================================

: bye ( - )  bye-chain do-chain  0 ExitProcess ;
|| create buf 256 allot
: path  buf 256 buf GetCurrentDirectory ;

\ =============================================================================
\ Oversight - Contract-orientation system
\ =============================================================================

public

include %idir%/debug/oversight.vfx

\ Enable Oversight and validated Forth core words if debugging mode enabled
\ - Performance can be increased by 30-50% by disabling VALIDATIONS,
\       (just, keeping it disabled requires preserving the value of VALUDATIONS)
\ - In addition, because validators are compiled lazily, validator
\       compilation errors can happen if words aren't found etc but the error
\       is not intuitive, showing the wrong source location.

init-oversight
include %idir%/debug/core-checks.vfx
include %idir%/checks.vfx

debug @ 0= [if]
    validations off  \ Speeds up performance by 85%-90%
[then]

\ =============================================================================
\ Additional Facilities
\ =============================================================================

include %idir%/../lib/wstring.vfx
include %idir%/strout.vfx
include %idir%/error2.vfx  \ TODO: Make platform-agnostic

\ TODO: make counter.vfx platform-agnostic so we can move these to vfxcore.vfx
include %idir%/counter.vfx  \ required by mersenne
include %idir%/mersenne.vfx
include %idir%/gamemath.vfx

\ =============================================================================
\ Allegro
\ =============================================================================

LIBRARY: allegro_monolith-5.2.dll
include %idir%/allegro-5.2.5.vfx
include %idir%/al-utils.vfx
include %idir%/keys.vfx

\ =============================================================================
\ Window bring-to-front
\ =============================================================================

extern void * GetForegroundWindow( );
extern bool SetForegroundWindow( void * hwnd );
GetForegroundWindow value vfx-hwnd
\ vfx-hwnd 0 0 0 0 0 $41 SetWindowPos drop 

: >display ( - )
    flushOP-gen drop \ flush buffered output (VFX)
    reset-keyboard 
    display al_get_win_window_handle SetForegroundWindow drop ;

: >vfx ( - )
    vfx-hwnd SetForegroundWindow drop ;

\ =============================================================================
\ Filesystem
\ =============================================================================

: dir-exists? ( a n - f )
    >zpad GetFileAttributes -1 <> ;

: >datadir ( a n - a n )
    s" dat" dir-exists? if s" " else s" ..\" then f" %sdat\%s" ;

: each-file ( path:a n xt - ) ( a n - )
    -rot >zpad al_create_fs_entry locals| e xt |
    e al_open_directory if
        begin  e al_read_directory ?dup while
            dup >r al_get_fs_entry_name zcount xt execute
            r> al_destroy_fs_entry
        repeat
        e al_close_directory drop    
    else
        abort" Couldn't open directory"
    then 
    e al_destroy_fs_entry ;

\ =============================================================================
\ Interactive Tools
\ =============================================================================

\ Try/Honing - Convenient code testing

variable honing     \ boolean XT, controls forced reloading of REQUIRE'd files
                    \ as well as the action of the F5 key.
                    \ ( off = reload game, on = reload module or other action )
                    \ if not 0 or -1, HONING is treated as an XT to execute 
                    \ instead of re-INCLUDEing the last TRY'd file.

cstring retry-filepath$

wordlist constant honing-wl

: >try ( a len - )
    dup 0= if 2drop exit then
    honing @ if honing-wl +order then
    2dup >abspath
    retry-filepath$ place
    ['] included catch
    honing @ if honing-wl -order then
    throw ;

|| : try-again ( - )
    honing @ -1 0 within? if
        retry-filepath$ count >try 
    else
        honing @ if honing-wl +order then
        honing @ execute
        honing @ if honing-wl -order then
    then ;

: try ( - <file-noext> )
    bl preparse nip 0= if
        bl parse 2drop try-again exit
    then
    bl parse f" %s.vfx" >try ;

honing-wl +order definitions
: require include ;
: required included ;
public

\ =============================================================================
\ Bitmap array
\ =============================================================================

public

65536 ?constant #bitmaps
|| create bitmaps #bitmaps cells allot&erase

variable next-bmp# 1 next-bmp# !

|| : bitmap[]  $FFFF and cells bitmaps + ;
|| : bitmap! bitmap[] ! ;

: bitmap@ ( n - bmp )
    bitmap[] @ ;

: +bitmap ( bmp - n )
    next-bmp# @ dup >r bitmap! 1 next-bmp# +! r> ;

\ =============================================================================
\ Graphics
\ =============================================================================

include %idir%/matrix.vfx
create pen 0 , 0 , \ int

: at ( x y - )
    pen 2! ;

: at@ ( - x y )
    pen 2@ ;

: at@f ( - f:x f:y )
    at@ 2s>f ;

: +at ( x y - )
    pen 2+! ;

|| : draw-bitmap ( bmp n - )
    over if at@f al_draw_bitmap else 2drop then ;

: put ( n - ) \ draw a sprite; takes a bitfield $F000IIII
    dup bitmap@ swap 24 rshift draw-bitmap ;

|| : abmpw  dup if al_get_bitmap_width then ;
|| : abmph  dup if al_get_bitmap_height then ;

: bmpwh ( n - w h )
    bitmap@ ?dup if dup abmpw swap abmph else 0 0 then ;

\ =============================================================================
\ Automatic bitmap loader
\ =============================================================================

|| variable bitmap-assets \ list

: .loading ; \ cr ." Loading " 2dup -path type ;
: .adding ; \ cr ." Adding " 2dup -path type ;

: load-bitmap ( a n - allegro-bitmap )
    .loading >zpad al_load_bitmap ;

: $global-create
    current @ >r also forth definitions $create previous r> current ! ;

|| : add-bitmap-asset ( a n - ) \ path
    .adding 
    2dup load-bitmap +bitmap ( n ) 
    >r -path >pad
    $global-create bitmap-assets link r> , 
    does> cell+ @ ;

: bitmap-file ( n - a n )
    bitmap@ | bmp |
    bmp 0= abort" BITMAP-FILE Bitmap is null!" 
    bmp al_is_sub_bitmap if
        bmp al_get_parent_bitmap to bmp
    then
    bitmap-assets begin @ ?dup while
        dup cell+ @ bitmap@ bmp = if
            body> >name count exit
        then
    repeat  -1 abort" BITMAP-FILE Bitmap file not found!" ;

|| : ?bitmap ( a n - ) \ path
    2dup -path >pad find if
        >body cell+ @ >r load-bitmap r> bitmap[] !
    else
        drop add-bitmap-asset
    then ;

|| : (load-bitmap) ( a n - ) \ path
    ?bitmap ;

: load-bitmaps ( - )
    s" gfx" >datadir ['] (load-bitmap) each-file ;

|| : (reload-bitmap) ( a n - ) \ path
    \ TODO: reload only updated bitmaps
    2dup -path >pad find if >body cell+ @ bitmap@ al_destroy_bitmap else drop then
    (load-bitmap) ;

: reload-bitmaps ( - )
    s" gfx" >datadir ['] (reload-bitmap) each-file ;

: destroy-bitmaps ( - )
    ." Destroying bitmaps" cr 
    65536 1 do
        i bitmap[] dup @ ?dup if al_destroy_bitmap then off
    loop  1 next-bmp# ! ;

\ =============================================================================
\ Text rendering
\ =============================================================================

include %idir%/print.vfx
include %idir%/../textmode/textmode.vfx

\ =============================================================================
\ Input
\ =============================================================================

: held? ( - f )  kbs0 swap al_key_down 0<> ;
: kdelta ( - n )  dup kbs0 swap al_key_down kbs1 rot al_key_down - ;
: pressed? ( - f )  kdelta 1 = ;
: letgo? ( - f )  kdelta -1 = ;
: shift? ( - f )  215 held? 216 held? or ;
: ctrl? ( - f )  217 held? 218 held? or ;
0 value alt?
    
\ =============================================================================
\ Framerate independence
\ =============================================================================

|| 60e fvalue tps \ float, ticks per second
|| 0 0 2value ustime \ long, in microseconds
0 value mstime \ int, in milliseconds
0 value usdelta
0 value pdelta \ fixed, in seconds
0e fvalue sdelta \ in seconds

: ticks  ( n - ms )
    s>f 1000e tps f/ f* f>s ;

|| : !delta  ( - )
    ustime  ucounter 2dup to ustime  2swap 2-
        d>s to usdelta
    usdelta s>f 1000000e f/ to sdelta
    ustime 1000 m/ to mstime
    sdelta f>p to pdelta ;

synonym z zoom

\ =============================================================================
\ Event handling
\ =============================================================================

|| create e /ALLEGRO_EVENT allot&erase
: happened? ( n - f ) e ALLEGRO_EVENT.type @ = ;
: the-char ( - n ) e KEYBOARD_EVENT.unichar @ ;
: the-key ( - n ) e KEYBOARD_EVENT.keycode @ ;
: the-wheel ( - n ) e MOUSE_EVENT.dz @ ;
: the-mouse ( - n ) e MOUSE_EVENT.x 2@ ; 
: the-walt ( - n ) e MOUSE_EVENT.dx 2@ ; 
: the-mbutton ( - n ) e MOUSE_EVENT.button @ ;

\ =============================================================================
\ Function Keys
\ =============================================================================

|| : func[] 256 * funcs + ;
   
: func ( a c n - )
    <f1> - func[] place ;

|| : clear-funcs ( - )
    funcs 256 12 * erase
    s" ?reload" <f5> func ;

: ?func ( n - )
    <f1> - dup 0 12 within? if
        func[] count dup if
            state off
            evaluate
        else
            2drop
            ." Unassigned function key." cr
        then
    else drop then ;

\ =============================================================================
\ Persistent variable control
\ =============================================================================

magic-id TWEAK_MAGIC TWK
: tweak ( n - <name> )
    \ Define a variable with initial value n, but only if the name doesn't already exist
    \    in CURRENT.
    push-order
    only current @ +order
    TWEAK_MAGIC ?already not if 
        create , TWEAK_MAGIC ,
    else
        drop
    then
    pop-order ;

: (?.tweak) ( thread# nfa - f )
    nip
    {: nfa :} 
    nfa name> >body cell+ @ TWEAK_MAGIC = if
        cr
        ."     "
        nfa count type
        ."  = "
        nfa name> >body @ dup .name p.
    then
    -1 ;

: .tweaks ( - )
    ['] (?.tweak) walk-order ;

\ =============================================================================
\ Display Mode Control
\ =============================================================================

|| : fullscreen ( - )
    ." FULLSCREEN" cr -1 to fullscreen? ;

|| : windowed ( - )
    ." WINDOWED" cr 0 to fullscreen? ;

|| : *display ( - )
    \ fullscreen? if fullscreen else windowed then
    create-display ;

|| : winmode ( - )
    2 to zoom
    appw apph fullscreen? resize-display
    !delta !delta ;
    
|| : w/f ( - )
    \ Display mode switching for release builds
    fullscreen? if windowed else fullscreen then
    winmode ;
        
\ =============================================================================
\ Main Loop Support
\ =============================================================================

|| create kbs2 /ALLEGRO_KEYBOARD_STATE allot

: save-kb
    kbs0 kbs2 /ALLEGRO_KEYBOARD_STATE move
    kbs0 /ALLEGRO_KEYBOARD_STATE erase ;

: restore-kb
    kbs2 kbs0 /ALLEGRO_KEYBOARD_STATE move ;

|| : ?kb-lock repl @ if save-kb then ; 
|| : ?kb-unlock repl @ if restore-kb then ;
    
|| : -keys  reset-keyboard ;
|| : ?quit  <esc> pressed? debug @ and if going off >vfx quit then ;
|| : ?bye  <f4> pressed?  alt? and if bye then ;

|| : spin ( - f: n )
    ustime  ucounter 2dup to ustime  2swap 2- d>f 1000000e f/ ;

|| : pre ( - )
    0 #tib ! postpone \\ 
    \ ['] noop is EditOnError
    !delta !delta ;
    
|| : ?throw ( n - ) 
    dup -1 = if drop exit then
    dup if going off >vfx then throw ;

|| : cls ( - )
    0e 0e 0e 1e al_clear_to_color ;

|| : draw-game ( - ) 
    at@ 2>r
    cls
    ?kb-lock 
    'show @ catch ?throw
    ?kb-unlock 
    2r> at ;

: show> ( - ) ( - )
    r> dup 'show ! cls execute ; 

|| : poll ( - )
    poll-keyboard  <alt> held? <altgr> held? or to alt? ;

: refresh ( - )
    ustime 
    0e begin spin f+ fdup 1e tps f/ f>= until fdrop
    to ustime
    display al_flip_display
    !delta
    poll ;

|| : spin ( - f: n )
    ustime  ucounter 2dup to ustime  2swap 2- d>f 1000000e f/ ;

\ =============================================================================
\ TV
\ =============================================================================

: refit ( - )  \ find biggest integer scaling that fits display
    monw monh 2s>f f/
    appw apph 2s>f f/
    f> if
        monh apph /
    else
        monw appw /
    then
    to zoom ;

: fs-w  appw z * ;
: fs-h  apph z * ;
: border-xy  monw 2 / monh 2 / fs-w 2 / fs-h 2 / 2- ;
: tv-xy  border-xy `` 2 z * dup `` 2- ;
: tv-xy2  border-xy `` 2 z * dup `` 2+ fs-w fs-h 2+ ;

: clip-screen ( - )
    border-xy fs-w fs-h al_set_clipping_rectangle ;

: border ( - )
    identity
    0 0 winw winh al_set_clipping_rectangle
    cls

    tv-xy 2s>f `` tv-xy2 2s>f ``
        0.25e 0.25e 0.25e 1e ```` al_draw_filled_rectangle

    6e f>ds >r
    border-xy 2s>f `` fs-w 1 + fs-h 1 + border-xy 2+ 2s>f ``
        0e 0e 0e 1e ```` r> ` al_draw_rectangle
    
    border-xy 2s>f `` z z 2s>f `` 0e ` transform
    clip-screen ;

: ?border
    identity 
    fullscreen? if
        refit border
    else
        0e 0e zoom s>f fdup 0e transform
    then ; 

|| : draw-tv ( - )
    ?border draw-game ;

\ =============================================================================
\ Interface Module
\ =============================================================================

load-bitmaps

defer frame ( - ) ' noop is frame

' engineer~ public-xt !
    include %idir%/ide2.vfx
' forth public-xt !

\ =============================================================================
\ Global Events
\ =============================================================================

|| : global-events ( - )
    ALLEGRO_EVENT_DISPLAY_CLOSE happened? if
        bye
    then
    ALLEGRO_EVENT_DISPLAY_SWITCH_OUT happened? if
        reset-keyboard reset-mouse
    then
    ALLEGRO_EVENT_DISPLAY_SWITCH_IN happened? if
        onSwitchIn
    then
    ALLEGRO_EVENT_DISPLAY_RESIZE happened? if
        display al_acknowledge_resize
    then ;

\ =============================================================================
\ Global Event Handler
\ =============================================================================

|| : ?event ( - f )
    alqueue e al_get_next_event 0<>
    dup -exit
    >r global-events ide-events r> ;

|| variable need-pump
    
|| : (pump) ( - )
    need-pump @ -exit
    begin ?event not until ;

:noname ( - )
    ['] (pump) catch ?throw need-pump on ;
    is pump

: event? ( - f )
    repl @ if 0 exit then
    need-pump off ?event ;

\ =============================================================================
\ Main Loop
\ =============================================================================

|| : ?idle ( - ) debug @ if EmptyIdle then ;
|| : ?reload-shift ( - ) shift? to reload-shift? ;
|| : ?w/f ( - )
    debug @ if ide-?w/f exit then
    <enter> pressed?  alt? and if
        w/f -keys
    then ;    
|| : controls ( - ) ?quit ?w/f ?bye ?idle ?reload-shift ;
|| : screen ( - ) debug @ if draw-ide else draw-tv then ;

:noname ( - )
    screen refresh controls pump ;
is frame

: go ( - )
    \ going @ ?exit
    .rs >display pre going on begin frame again ;

\ =============================================================================
\ Entry Points  
\ =============================================================================

|| : /console
    debug @ -exit
    -1 line# !
    hWndMain to vfx-hwnd
    vfx-hwnd z" Engineer Dev Console" SetWindowText drop
    >vfx ;

|| : setup
    \ Initialize runtime environment
    init-mersenne
    init-allegro
    *display
    init-vga-font
    0 0 to ustime ;

|| create bye-chain-root
bye-chain link 0 ,

|| : vfxforth-entrypoint ( hinst hpinst lpcommand nshow -- res )
    [ ' EntryPoint >body @ compile, ] ;

|| : cleanup ( - )
    bye-chain-root bye-chain !
    destroy-bitmaps
    ['] noop 'show !
    ['] noop is boot
\    ['] noop is .apperr
    ['] noop is onSwitchIn
    honing off
    retry-filepath$ 256 erase ;

' cleanup bye-chain-root cell+ !

\ || : return ( - )
\     home-path$ count $cwd ;

: empty ( - )
    debug @ -exit
    rs
    cleanup
    init-nib
    clear-funcs
    only forth definitions
    s" anew gild" evaluate ;

: cartridge
    \ Load user program
    empty
    load-bitmaps
    s" main.vfx" fileExist? if s" main.vfx" included then ;

: dev-frigid
    \ Development-only startup
    path home-path$ place
    +xrefs
    256 1024 * xref-kb
    s" xref.xrf" fileexist? if load-xref then
    rs
    init-ide ;

: frigid ( - )
    debug @ if dev-frigid then
    setup cartridge ;

: cold ( - )
    frigid boot go ;

\ =============================================================================
\ Debugging tools
\ =============================================================================

\ include debug/logging.vfx \ TODO: test and fix
\ debug @ [if]
\ include debug/contracts.vfx
\ [then]

\ =============================================================================
\ Reloading
\ =============================================================================

: reload ( - )
    honing off
    cartridge
    repl on ;

: ?reload ( - )
    honing @ reload-shift? not and if
        try-again
    else
        reload
    then ;

\ =============================================================================
\ Turnkey creation
\ =============================================================================

: save-release ( - <path> )
    ['] cold is EntryPoint
    fullscreen?
        ide @ repl @ debug @
            ide off
            repl off
            debug off
            fullscreen
            save cr
        debug ! repl ! ide !
    if fullscreen else windowed then ;

: save-debug ( - <path> )
    ['] vfxforth-entrypoint is EntryPoint
    fullscreen?
        ide @ repl @ debug @
            ide off
            repl off
            debug off \ This disables Engineer-only initialization.
                      \ Counter-intuitive because we want to debug the game not Engineer.
            windowed
            save cr
        debug ! repl ! ide !
    if fullscreen else windowed then ;

: save-dev ( - <path> )
    fullscreen?
        ide @ repl @
            ide on
            repl on
            windowed
            save cr
        repl ! ide !
    if fullscreen else windowed then ;

|| : prj ( - a len ) path '\' ending ;

: turnkey ( - )
    prj prj prj prj fe" cmd /c \"mkdir ..\\..\\rel\\%s\ & del ..\\..\\rel\\%s\\*.* /s /q & xcopy dat ..\\..\\rel\\%s\\dat /i /q /s /y /e & copy ..\\bin\\*.dll ..\\..\\rel\\%s\"" cr 2dup type shellcmd
    500 ms
    prj prj f" save-release ..\..\rel\%s\%s" cr 2dup type evaluate
    prj prj f" save-debug ..\..\rel\%s\%s-debug" cr 2dup type evaluate ;

: watch ( - <code> )
    context @ watch-context !
    0 parse 2dup f" :noname %s ;" evaluate watch-xt !
    watch$ place ;

\ =============================================================================
\ Kickoff
\ =============================================================================

create zcommand 65536 allot 

: engineer-entrypoint ( hinst hpinst lpcommand nshow -- res )
    over zcount zcommand zplace
    vfxforth-entrypoint ;

borrow ide2~ history-stats
borrow ide2~ visible-lines
: engineer.cold
    /console
    (.cold)
    ."  ~~~ Engineer v1 ~~~ "
    cr
    frigid
    \ 20 visible-lines !
    zcommand zcount strip-exe ide-interpret
    \ history-stats 
    dup 0= if drop go else .throw then ;
    
:noname me valid-object? if me .name then ; is .me

' engineer-entrypoint is EntryPoint
assign engineer.cold to-do .cold
marker gild

