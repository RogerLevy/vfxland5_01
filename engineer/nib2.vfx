\ ------------------------------------------------------------------------------
\ Engineer OOP extension - Nib 2.0 Foundation
\ ------------------------------------------------------------------------------
\ ==============================================================================
\ [x] Phase 1: Foundation infrastructure 
\ [x] Phase 2: Classifier bit allocation system
\ [ ] Phase 3: Field type registry and protocols
\ [ ] Phase 4: Enhanced message dispatch with classifier checks
\ [ ] Phase 5: Advanced object creation with type validation
\ ==============================================================================

validations off

1024 constant #max-classifiers
4096 constant /classifier
#max-classifiers 8 / constant /bit-table

0 value me              \ current object
0 value classifier      \ current classifier
0 value /static         \ next static field offset

variable next-classifier#

magic-id MAGIC_FIELD FIEL
magic-id MAGIC_PROPERTY PROP
magic-id MAGIC_CLASSIFIER CLAS

\ ==============================================================================
\ Low-level stuff
\ ==============================================================================

: field ( ofs size <name> - n ) ( a - a )
    create 0 , MAGIC_FIELD , over , +
    does> 2 cells + @ me + ;

0
    cell field cla
dup constant /object-base
    cell field magic
constant /magical-base

: prop+ ( object offset - a )
    over [ ' cla >body 2 cells + @ ] literal + @ + @ + ;

: 's ( object <name> - a )
    preword find not abort" 'S >> field name not found!"
    >body cell+ @ MAGIC_PROPERTY = if
        ' >body 2 cells + @ ?literal s" prop+" evaluate
    else
        ' >body 2 cells + @ ?literal s" +" evaluate
    then ; immediate 

: already? ( ? <name> - b <name> )
    {: n :}
    preword find if >body @ n = else drop 0 then ;

: ?already ( ? <name> - 1 | <name> 0 )
    {: n :}
    preword find if
        >body @ n = dup if bl word drop then
    else drop 0 then ; 

|| : ?literal  state @ if postpone literal then ;

: -% ( a c -- a c' )
    dup -exit 2dup + 1 - c@ '%' = -exit 1 - ;

cstring name$
: >$ ( a len - $ )
    name$ place name$ ;

: set-bit ( bit# addr - )
    {: bit# addr | byte-ofs bit-ofs :}
    bit# 8 / to byte-ofs
    bit# 8 mod to bit-ofs
    addr byte-ofs +
    dup c@ 1 bit-ofs lshift or swap c! ;

: test-bit ( bit# adr - b )
    >r 8 /mod ( bit-ofs byte-ofs )
    r> + c@ 1 rot lshift and 0<> ;

: add-to ( item list - )
    \ list (head): [ next-node , item , count , ]
    \ node: [ next-node , item , ]
    {: item head :}
    head cell+ cell+ @ 0= if
        item head cell+ !
    else
        head
        begin dup @ while @ repeat 
        here swap ! 0 , item , 
    then
    1 head cell+ cell+ +! ;

: @next ( node - next-node item )
    dup @ swap cell+ @ ;

: list-count ( list - c )
    cell+ cell+ @ ;

3 cells constant /list

: copy-list ( src dest - )
    {: src dest :}
    dest /list erase  \ re-initialize head
    src dup list-count for
        @next dest add-to
    loop drop ;

\ ==============================================================================
\ Object stack
\ ==============================================================================

: pagealign ( - )  here $ff and 256 swap - allot ;
: aligned-page ( <name> - )  pagealign here $100 allot constant ;
aligned-page os
variable osp   os osp ! \ object stack pointer

\ ==============================================================================
\ Object scoping
\ ==============================================================================

: [[ ( object - ) me osp @ !  4 osp c+!  to me ;
: unsafe-[[ ( a - ) me osp @ !  4 osp c+!  to me ;
: ]] ( - ) -4 osp c+!  osp @ @ to me ;
: you ( - object ) osp @ cell- @ ;
: that ( - object ) osp @ @ ;

\ ==============================================================================
\ Classes
\ ==============================================================================

/magical-base
    cell field instance-size                \ Size of this class
    cell field next-ofs                     \ Next field offset for this class
    cell field field-space-size
    cell field classifier#
    /bit-table field bit-table    \ Classification table
    /list field property-list
    /list field protocol-list
    cell field template
    cell field constructor-xt
    cell field constructor-#params
dup constant /classifier-base
to /static

: allocate-classifier-bit ( - )
    next-classifier# @ classifier 's bit-table set-bit
    next-classifier# @ classifier 's classifier# !
    1 next-classifier# +! ;

|| : (classifier) ( class - class )
    here swap , /classifier cell- allot&erase
    dup to classifier
    [[
        /classifier instance-size !
        allocate-classifier-bit
    me ]]  ;
    
: (init-class) ( - )
    MAGIC_CLASSIFIER magic ! ;
    
create class% class% (classifier) [[ (init-class) ]]

|| : create-class ( <name> - class )
    create class% (classifier) dup [[ (init-class) ]] ;

: (init-trait) ( - )
    MAGIC_CLASSIFIER magic ! ;

create object% 0 (classifier) [[
    (init-trait)
]]

: (add-object-system-trait) ( - )
    object% 's classifier# @ bit-table set-bit ;

create-class trait% [[
    (add-object-system-trait)
]]

object% [[
    trait% cla !
    (add-object-system-trait)
]]

: sizeof ( object - n )
    's cla @ 's instance-size @ ;

: !defaults ( object - )
    dup 's cla @ 's template @ ?dup if
        \ dup .name ." template copying" cr
        \ over >r 
        cell+ over dup cell+ swap sizeof cell- move
        \ r> dup sizeof dump
    else
        dup cell+ over sizeof cell- erase
    then
    drop ;

: object ( ... class - object )
    \ TODO: validate class
    here over , swap 's instance-size @ cell- allot
    dup !defaults
    [[
        cla @ 's constructor-xt @ ?dup if execute then
    me ]] ;

: $create-object ( ... class name len - object ) ( - object ) 
    >$ $create object ;

: create-object ( ... class <name> - ) ( - object )
    bl parse $create-object drop ;

create property%  class% object [[
    (add-object-system-trait)
    /magical-base
        cell field offset
        cell field next-property
    dup instance-size ! next-ofs !
]]

create static%  class% object [[
    property% 's instance-size @
    dup instance-size ! next-ofs !
]]

create protocol%  class% object [[
    static% 's instance-size @
        cell field default-xt
        cell field next-protocol
    dup instance-size ! next-ofs !
]]

|| : has-field-space? ( class - b )
    's field-space-size @ 0<> ;
    
: field-space ( n - )
    classifier [[
        field-space-size !
        field-space-size @ instance-size !
    ]] ;       

: begin-classifier ( class - )
    create object to classifier
    allocate-classifier-bit ;

: end-classifier ( - )
    0 to classifier ;

: allocate-static-offset ( - )
    /static offset !
    cell +to /static ;
    
: create-property ( <name> - property ) 
    create property% object [[
        allocate-static-offset
        MAGIC_PROPERTY magic !
    me ]]
    does> 's offset @ cla @ + @ me + ;

: defining-a-trait? ( - b )
    classifier 's cla @ trait% = ;

: add-property ( property - )
    classifier 's property-list add-to ;

: is-property-mapped? ( property - b )
    's offset @ classifier + @ 0<> ;

: map-property ( property - )
    \ map property for current class
    [[
        classifier 's next-ofs @ offset @ classifier + !
        cell classifier 's next-ofs +!
    ]]
    classifier has-field-space? not if            
        classifier [[ next-ofs @ instance-size ! ]]
    then ;

: add-trait ( trait - )
    {: trait :}
    trait 's classifier# @ classifier 's bit-table set-bit
    trait 's protocol-list dup list-count for
        @next
        ( protocol ) [[ default-xt @ offset @ ]] classifier + !
    loop drop
    trait 's property-list dup list-count for
        @next dup is-property-mapped? if drop else map-property then
    loop drop ;

: is-a ( <trait> - )
    ' >body add-trait ;
    
: class: ( <name> - ) 
    class% begin-classifier
    classifier [[
        (init-class) 
        /object-base instance-size !
        /object-base next-ofs !
    ]] ;

: class; ( - )
    end-classifier ;
    
: is? ( object classifier - bool )
    's classifier# @ swap 's cla @ 's bit-table test-bit ;

: property ( <name> - ) ( - a )
    property% already? if ' >body else create-property then
    dup is-property-mapped? if
        drop \ -1 abort" PROPERTY >> Property already mapped!"
    else
        dup add-property
        map-property
    then ;

: static ( <name> - ) ( - a )
    static% ?already ?exit    
    create static% object [[
        allocate-static-offset
        MAGIC_FIELD magic !
    ]]
    does> 's offset @ cla @ + ;

: trait: ( <name> - )
    trait% begin-classifier
    classifier [[ (init-trait) ]] ;

: trait;
    end-classifier ;

: add-protocol ( protocol - )
    classifier 's protocol-list add-to ;

: does-protocol ( - )
    does> swap [[
        dup 's offset @ cla @ + @ ?dup if
            nip
        else
            >r
            -1
            cla @ >name count
            r> body> >name count
            f" DOES-PROTOCOL >> Protocol %s not supported by %s!" .abort
        then
        ( xt ) execute
    ]] ;
    
: protocol: ( <name> - ) ( ... object - ... )
    create protocol% object [[
        me add-protocol
        allocate-static-offset 
        :noname default-xt !
    ]]
    does-protocol ;

: :: ( class <protocol> - )
    {: class | name[ 256 ] :}
    ' >body [[
        me body> >name count name[ place
        name[ count
            class body> >name count 1 -
            f" : %s::%s" 2dup upper evaluate
        state on
        here ( xt ) class offset @ + !
    ]] ;

: constructor: ( #params class - )
    [[
        :noname constructor-xt !
        constructor-#params !
    ]] ;

: defaults ( - a )
    classifier 's cla @ trait% = if
        -1 abort" DEFAULTS >> Cannot create defaults for traits - use in classes only"
    then
    classifier 's template @ ?dup if else
        classifier object classifier 's template !
        classifier 's template @
    then ;

: >defaults ( class - a )
    's template @ ?dup if else
        dup object over 's template !
        's template @
    then ;

: derive ( class - )
    {: source-class :}
    
    \ Copy size fields
    source-class [[ instance-size @ next-ofs @ field-space-size @ ]]
    classifier [[ field-space-size ! next-ofs ! instance-size ! ]]
    
    \ Copy statics
    source-class /classifier-base +
    classifier /classifier-base +   
    /classifier /classifier-base - move
    
    \ Copy member lists
    source-class 's protocol-list  classifier 's protocol-list copy-list
    source-class 's property-list  classifier 's property-list copy-list
    
    \ Copy parent's bit-table (trait relationships)
    source-class 's bit-table classifier 's bit-table /bit-table move
    
    \ Set parent bit for inheritance queries
    source-class 's classifier# @ classifier 's bit-table set-bit
    
    \ Copy template if it exists
    source-class 's template @ ?dup if
        defaults source-class 's instance-size @ move
    then
;

: reset-object-trait ( - )
    object% 's protocol-list /list erase
    object% 's property-list /list erase ;

: init-nib ( - )
    [ next-classifier# @ ] literal next-classifier# ! 
    [ /static ] literal to /static
    0 to classifier
    reset-object-trait ;

\ Tests
\ -----

trait: thinker%
    protocol: init  me .name ." init " cr ;
    protocol: deinit  me .name ." deinit " cr ;
    protocol: think  me .name ." think " cr ;
trait;

trait: physics%
    property mass
    property rad
    property x
    property y
    property vx
    property vy
trait;

class: actor%
    is-a object%
    is-a thinker%
    is-a physics%
    property x
    property y
    property vx
    property vy
    defaults [[
        me .
        1. mass !
        rad .
        10. rad !
    ]]
class;
actor% >defaults [[ rad ]] p? cr

class: enemy%
    actor% derive
    property atk
class;

class: waypoint%
    is-a object%
    property id          \ unique identifier for pathfinding
    property x           \ world position
    property y           \ world position
    property connections \ bitfield of connected waypoints
class;

create waypoint waypoint% object drop

create actor actor% object [[
    me .
    x .
    y .
    \ me 's y .
    me actor% is? .
    cr
    static i/hp
    i/hp . actor% 's i/hp .
]]


cr
waypoint [[ x me - . ]]
actor [[ x me - . ]]

actor init

actor think
\ waypoint think

actor% :: think
    ." I try to think but nothing happens!" cr ;

actor [[
    me dup . .name
    ." &mass=" mass .
    ." &x=" x .
    ." &vx=" vx .
    cr
    me think
]]

create enemy enemy% object [[
    me dup . .name
    ." &mass=" mass .
    ." &x=" x .
    ." &vx=" vx .
    ." &atk=" atk .
    cr
    me think
    me actor% is? .
    me enemy% is? .
    me physics% is? .
    me object% is? .
    cr
    ." mass=" mass p?
    ." rad=" rad p?
    cr
]]

\ waypoint [[
\     me dup . .name
\     mass .
\     vx .
\     cr
\ ]]


class: tileset%
    property bmp
    property tw
    property th
class;

3 tileset% constructor: ( bmp tw th - )
    th ! tw ! bmp ! ;

1 16 16 tileset% create-object tileset

