\ ------------------------------------------------------------------------------
\ Engineer OOP extension - NIBS (NIBS Interactive Behavior System) a.k.a Nib 2.0
\ ------------------------------------------------------------------------------

\ validations off

1024 constant #max-classifiers
4096 constant /classifier
#max-classifiers 8 / constant /bit-table

0 value me              \ current object
0 value classifier      \ current classifier
0 value /static         \ next static field offset

variable next-classifier#

magic-id MAGIC_FIELD FIEL
magic-id MAGIC_PROPERTY PROP
magic-id MAGIC_CLASSIFIER CLAS

\ ==============================================================================
\ Low-level stuff
\ ==============================================================================

: field ( ofs size <name> - n ) ( a - a )
    create 0 , MAGIC_FIELD , over , +
    does> 2 cells + @ me + ;

0
    cell field cla
dup constant /object-base
    cell field magic
constant /magical-base

: ?prop ( n - n )
    dup 0= abort" ?PROP >> Property offset is 0 - property not mapped for this class!" ;

' cla >body 2 cells + @ constant cla-offset
: prop+ ( object offset - a )
    s" over cla-offset + @ + @ ?prop +" evaluate ; immediate

: >cla  s" cla-offset +" evaluate ;  immediate

: 's ( object <name> - a )
    preword find not abort" 'S >> field name not found!"
    >body cell+ @ MAGIC_PROPERTY = if
        ' >body 2 cells + @ ?literal s" prop+" evaluate
    else
        ' >body 2 cells + @ ?literal s" +" evaluate
    then ; immediate 

: already? ( ? <name> - b <name> )
    {: n :}
    preword find if >body @ n = else drop 0 then ;

|| : ?literal  state @ if postpone literal then ;

cstring name$
: >$ ( a len - $ )
    name$ place name$ ;

: set-bit ( bit# addr - )
    {: bit# addr | byte-ofs bit-ofs :}
    bit# 8 / to byte-ofs
    bit# 8 mod to bit-ofs
    addr byte-ofs +
    dup c@ 1 bit-ofs lshift or swap c! ;

: test-bit ( bit# adr - b )
    >r 8 /mod ( bit-ofs byte-ofs )
    r> + c@ 1 rot lshift and 0<> ;

: @next ( node - next-node item )
    dup @ swap cell+ @ ;

\ Forward-Linked List

3 cells constant /list

: list-count ( list - c )
    cell+ cell+ @ ;

: list-count! ( c list - )
    cell+ cell+ ! ;

: add-to ( item list - )
    \ list (head): [ next-node , item , count , ]
    \ node: [ next-node , item , ]
    {: item head | count :}
    head list-count to count
    count 0= if
        item head cell+ !
    else
        head count 1 - for @ loop
        here swap ! 0 , item ,
    then
    count 1 + head list-count! ;

: copy-list ( src dest - )
    {: src dest :}
    dest /list erase  \ re-initialize head
    src dup list-count for
        @next dest add-to
    loop drop ;

\ ==============================================================================
\ Object stack
\ ==============================================================================

: pagealign ( - )  here $ff and 256 swap - allot ;
: aligned-page ( <name> - )  pagealign here $100 allot constant ;
aligned-page os
variable osp   os osp ! \ object stack pointer

\ ==============================================================================
\ Object scoping
\ ==============================================================================

: [[ ( object - ) me osp @ !  4 osp c+!  to me ;
: ]] ( - ) -4 osp c+!  osp @ @ to me ;
: you ( - object ) osp @ cell- @ ;
: that ( - object ) osp @ @ ;
: as> ( actor - ) ( - ) [[ r> execute ]] ;


: as ( object - )
    \ Bind the given object and switch to its vocabulary if it has one
    [[
    cla @ body> >name count f" %s~"
    >pad find if execute else drop then ;

\ ==============================================================================
\ Classes
\ ==============================================================================

/magical-base
    cell field instance-size            \ Size of this class
    cell field next-ofs                 \ Next field offset for this class
    cell field field-space-size
    cell field classifier#
    /bit-table field id-table           \ Classification table
    /bit-table field can-table          \ Capability table
    /list field property-list
    /list field protocol-list
    cell field template
    cell field constructor-xt
    cell field constructor-#params
    cell field on-derive-xt
    /list field dependents              \ trait dependents (classes that applied the trait)
    cell field #openings
dup constant /classifier-base
to /static

: allocate-classifier-bit ( - )
    next-classifier# @ classifier 's id-table set-bit
    next-classifier# @ classifier 's can-table set-bit
    next-classifier# @ classifier 's classifier# !
    1 next-classifier# +! ;

|| : (classifier) ( class - class )
    here swap , /classifier cell- allot&erase
    dup to classifier
    [[
        /classifier instance-size !
        allocate-classifier-bit
    me ]]  ;
    
: (init-class) ( - )
    MAGIC_CLASSIFIER magic ! ;
    
create _class _class (classifier) [[ (init-class) ]]

|| : create-class ( <name> - class )
    create _class (classifier) dup [[ (init-class) ]] ;

: sizeof ( class|object - n )
    dup >cla @ _class = if 's instance-size @
    else >cla @ 's instance-size @ then ;

\ ==============================================================================
\ TRAIT% and OBJECT%
\ ==============================================================================

: (init-trait) ( - )
    MAGIC_CLASSIFIER magic ! ;

create _object 0 (classifier) [[
    (init-trait)
]]

: (add-object-system-trait-bit) ( - )
    _object 's classifier# @ id-table set-bit ;

create-class _trait [[
    (add-object-system-trait-bit)
]]

_object [[
    _trait cla !
    (add-object-system-trait-bit)
]]

\ ==============================================================================
\ Object instantiation
\ ==============================================================================

: (sizeof) ( object - n )
    >cla @ 's instance-size @ ;

: !defaults ( object - )
    dup >cla @ 's template @ ?dup if
        \ dup .name ." template copying" cr
        \ over >r 
        cell+ over dup cell+ swap (sizeof) cell- move
        \ r> dup (sizeof) dump
    else
        dup cell+ over (sizeof) cell- erase
    then
    drop ;

: construct ( ... class addr - )
    swap over >cla !   \ Store class pointer
    [[
        me !defaults
        cla @ 's constructor-xt @ ?dup if execute then
    ]] ;
    
: instance ( ... class - object )
    \ TODO: validate class
    here >r
    dup 's instance-size @ allot
    ( class ) r@ construct r> ;

: $object ( ... class name len - object ) ( - object ) 
    >$ $create instance ;

: object ( ... class <name> - ) ( - object )
    bl parse $object drop ;

\ ==============================================================================
\ Members
\ ==============================================================================

create _property  _class instance [[
    (add-object-system-trait-bit)
    /magical-base
        cell field offset
        cell field next-property
        cell field property-size
    dup instance-size ! next-ofs !
]]

create _static  _class instance [[
    _property 's instance-size @
    dup instance-size ! next-ofs !
]]

create _protocol  _class instance [[
    _static 's instance-size @
        cell field default-xt
        cell field next-protocol
    dup instance-size ! next-ofs !
]]

|| : has-field-space? ( class - b )
    's field-space-size @ 0<> ;
    
: field-space ( n - )
    classifier >cla @ _trait = abort" FIELD-SPACE >> Cannot add a field-space to traits, only classes."
    classifier [[
        field-space-size !
        field-space-size @ instance-size !
    ]] ;       

: begin-classifier ( class - )
    push-order only forth definitions
    create instance to classifier
    1 classifier 's #openings +!
    allocate-classifier-bit
    pop-order ;

: end-classifier ( - )
    0 to classifier ;
    
: reopened? ( class - b )
    's #openings @ 1 > ;

: allocate-static-offset ( - )
    /static offset !
    cell +to /static ;
    
: does-property
    does> 's offset @ cla @ + @ ?prop me + ;    

: create-property ( size <name> - property )
    push-order only forth definitions
    create _property instance [[
        property-size !
        allocate-static-offset
        MAGIC_PROPERTY magic !
    me ]]
    pop-order
    does-property ;

: defining-a-trait? ( - b )
    classifier >cla @ _trait = ;

: add-property ( property - )
    classifier 's property-list add-to ;

: is-property-mapped? ( property - b )
    's offset @ classifier + @ 0<> ;

: map-property ( property - )
    \ map property for current class
    [[
        classifier 's next-ofs @ offset @ classifier + !
        property-size @ classifier 's next-ofs +!
    ]]
    classifier has-field-space? not if            
        classifier [[ next-ofs @ instance-size ! ]]
    then ;

: supports-protocol? ( protocol class - bool )
    swap 's offset @ + @ 0<> ;

: support-protocol ( protocol class - )
    >r [[ default-xt @ offset @ ]] r> + ! ;

: has-unmapped-properties? ( trait - bool )
    {: trait0 :}
    trait0 's property-list dup list-count for
        @next ( property ) is-property-mapped? not if
            -1 leave
        then
    loop drop
    0 ;

: ?size-changed ( size property - property )
    {: size property0 :}
    property0 's property-size @ size <> if
        -1
        size
        property0 's property-size @
        property0 body> >name count
        f" NPROPERTY >> %s changed from %n to %n bytes - reload/restart required."
        .abort
    then
    property0 ;

: nproperty ( size <name> - ) ( - a )
    classifier 0= abort" NPROPERTY >> Can't define a property outside of a classifier block."

    _property already? if
        ' >body ?size-changed
    else
        \ Property doesn't exist - check rules
        classifier >cla @ _trait = if
            \ Trait rules
            classifier reopened? if
                classifier 's dependents list-count 0<>
                abort" NPROPERTY >> Cannot add new properties to reopened traits with dependents."
            then
            \ New trait or reopened trait with no dependents - okay
        else
            \ Class rules
            classifier reopened? if
                \ Reopened class without a field-space - abort
                \ (Probably won't ever happen because CLASS: redefines
                \ classes without field-spaces instead of re-opening them)
                classifier has-field-space? not
                abort" NPROPERTY >> Cannot add properties to an existing class without a field-space."
                \ Reopened class with a field-space - okay
            then
            \ New class - okay
        then
        create-property
    then
    
    \ Map the property
    ( property )
    dup is-property-mapped? if
        drop \ -1 abort" PROPERTY >> Property already mapped!"
    else
        dup add-property
        map-property
    then ;
    
: property ( <name> - ) ( - a )
    cell nproperty ;

: static ( <name> - ) ( - a )
    classifier 0= abort" STATIC >> Can't define a static outside of a classifier block."
    _static already? if ' drop exit then
    push-order only forth definitions
    create _static instance [[
        allocate-static-offset
        MAGIC_FIELD magic !
    ]]
    pop-order
    does> 's offset @ cla @ + ;

\ ==============================================================================
\ Classifier definition
\ ==============================================================================

: apply-trait ( trait class b:id? - )
    {: trait0 class0 id? | could? :}
    class0 >cla @ _class <> abort" APPLY-TRAIT >> Invalid destination - must be a class."
    
    \ Check if trait has NEW properties that class can't handle
    class0 reopened? if
        class0 has-field-space? not if
            classifier >r class0 to classifier
            trait0 has-unmapped-properties? 
            r> to classifier
            abort" APPLY-TRAIT >> Cannot add trait with new properties to reopened class without field-space."
        then
    then
    
    \ Set classifier bit
    id? if
        trait0 's classifier# @ class0 's id-table set-bit
    then
    
    \ Cache the current capability status
    trait0 's classifier# @ class0 's can-table test-bit to could?
    
    \ Set capability bit
    trait0 's classifier# @ class0 's can-table set-bit
    
    \ Merge protocols
    trait0 's protocol-list dup list-count for
        @next 
        ( protocol ) class0
        \ Avoid clobbering already supported protocols if "upgrading"
        \ a class from WORKS-WITH to IS-A.
        could? if 2dup supports-protocol? not else -1 then
        if support-protocol then
    loop drop
    
    \ Merge properties
    trait0 's property-list dup list-count for
        @next
        dup is-property-mapped? if drop else dup add-property map-property then
    loop drop
    
    \ Add class to dependents
    class0 trait0 's dependents add-to ;
   
: class: ( <name> - )
    _class already? if
        ' >body to classifier
        exit
    then
    _class begin-classifier
    classifier [[
        (init-class) 
        /object-base instance-size !
        /object-base next-ofs !
        _object classifier -1 apply-trait 
    ]] ;

: class; ( - )
    end-classifier ;

: is-a ( [class] <trait> - )
    \ [class] only required if outside class block
    ' >body classifier ?dup 0= if swap then -1 apply-trait ;

: works-with ( [class] <trait> - )
    \ [class] only required if outside class block
    ' >body classifier ?dup 0= if swap then 0 apply-trait ;
    
: trait: ( <name> - )
    _trait already? if
        ' >body to classifier
        exit
    then
    _trait begin-classifier
    classifier [[
        (init-trait)
    ]] ;

: trait;
    end-classifier ;

: add-protocol ( protocol trait - )
    's protocol-list add-to ;

defer (on-exec-error) ( xt err# obj - )

\ debug @ [if]
\     : oexec ( ... xt - ... )
\         ?dup -exit
\         {: xt :}
\         xt catch ?dup if
\             xt swap me (on-exec-error)
\         then ;
\ [else]
    : oexec ( ... xt - ... )
        ?dup -exit >r ;
\ [then]

: unbound-dispatch ( ... object protocol-xt - ... ) ( ... - ... )
    \ Backdoor for using classes like callback structs.
    \ The object will not be bound during execution of the protocol.
    \ This means that it cannot use any of its properties.
    swap [[ >body 's offset @ cla @ + @ ]]
    ?dup if execute then ;

: does-protocol ( - )
    does> swap [[
        dup 's offset @ cla @ + @ ?dup if
            nip
        else
            ( protocol ) >r
            -1
            cla @ >name count
            r> body> >name count
            f" DOES-PROTOCOL >> Protocol %s not supported by %s!" .abort
        then
        ( xt ) oexec
    ]] ;

|| : :protocol ( protocolname-a protocolname-len classname-a classname-len - xt )
    f" : %s:%s" 2dup upper
    \ 2dup type cr
    evaluate
    state on
    here ; 

: implement-protocol ( protocol class - )
    {: protocol0 class0 | name[ 256 ] :} 
    protocol0 [[
        me body> >name count name[ place
        name[ count
        class0 body> >name count 
        :protocol ( xt ) class0 offset @ + !
    ]] ;
    
: (protocol:) ( trait <name> - ) ( ... object - ... )
    {: trait0 | protocol0 class0 class1 buf[ 256 ] :}
    bl preparse buf[ place
    _protocol already? if
        ' >body
        \ TODO: check if the protocol belongs to another trait and throw error if it is
    else
        create _protocol instance
        does-protocol 
        [[
            me trait0 add-protocol
            allocate-static-offset 
        me ]]
    then
    to protocol0
    
    \ Compile the default behavior
    buf[ count
    trait0 body> >name count
    :protocol protocol0 's default-xt !
    
    \ Propagate the protocol to dependents
    trait0 's dependents dup list-count for
        @next to class1
        protocol0 class1 supports-protocol? not if
            protocol0 class1 support-protocol
        then
    loop drop
    ;

: :: ( classifier <protocol> - )
    {: class0 | protocol0 :}
    \ classifier abort" :: >> Can only define a protocol outside of a classifier block."
    class0 >cla @ _trait = if class0 (protocol:) exit then
    class0 >cla @ _class <> abort" :: >> Invalid protocol implementation destination. (Must be a class.)"
    bl word find not abort" :: >> Protocol not found. Note: Protocols can only be created on traits."
    >body to protocol0
    protocol0 >cla @ _protocol <> abort" :: >> Word is not a protocol!"
    protocol0 class0 supports-protocol? not abort" :: >> Tried to implement a protocol not supported by the class."
    protocol0 class0 implement-protocol ;

: stub ( - )
    -1 r> >name count f" %s >> Not implemented" .abort ;

: :construct ( #params class - )
    classifier abort" :CONSTRUCT >> Constructors can only be defined outside of a classifier block."
    dup >cla @ _class <> abort" :CONSTRUCT >> Passed object is not a class - constructors can only be defined for classes."
    [[
        :noname constructor-xt !
        constructor-#params !
    ]] ;

\ : defaults ( - a )
\     classifier 0= abort" DEFAULTS >> Can't define defaults outside of a class block."
\     classifier >cla @ trait% = abort" DEFAULTS >> Cannot create defaults for traits - use in classes only"
\     classifier 's template @ ?dup if else
\         classifier instance classifier 's template !
\         classifier 's template @
\     then ;

: defaults ( [class] - a )
    {: | class0 :}
    classifier dup 0= if drop then to class0 
    class0 >cla @ _trait = abort" DEFAULTS >> Traits cannot have defaults. (Only classes.)"
    class0 's template @ ?dup 0= if
        class0 instance class0 's template !
        class0 's template @
    then ;

: derive ( class - )
    {: source-class :}
    
    source-class >cla @ _class <> abort" DERIVE >> Can only derive from classes."
    classifier 0= abort" DERIVE >> Can only be called inside a class block."
    
    \ Copy size fields
    source-class [[ instance-size @ next-ofs @ field-space-size @ ]]
    classifier [[ field-space-size ! next-ofs ! instance-size ! ]]
    
    \ Copy statics
    source-class /classifier-base +
    classifier /classifier-base +   
    /classifier /classifier-base - move
    
    \ Copy member lists
    source-class 's protocol-list  classifier 's protocol-list copy-list
    source-class 's property-list  classifier 's property-list copy-list
    
    \ Copy parent's bit table tables (trait relationships)
    source-class 's id-table classifier 's id-table /bit-table move
    source-class 's can-table classifier 's can-table /bit-table move
    
    \ Set parent bit for inheritance queries
    \ I believe this is not needed as it is set in the bit tables by begin-classifier
    \ source-class 's classifier# @ classifier 's can-table set-bit
    
    \ Copy template if one exists, updating its class
    source-class 's template @ ?dup if
        ( source-template ) defaults source-class 's instance-size @ move
        classifier defaults >cla !
    then
    
    \ Copy constructor
    source-class 's constructor-xt @ classifier 's constructor-xt !
    source-class 's constructor-#params @ classifier 's constructor-#params !
    
    \ Execute on-derive if set
    source-class 's on-derive-xt @ ?dup if
        source-class classifier rot execute  \ ( source-class derived-class - )
    then 
;

: :derive ( class - ) ( source-class derived-class - )
    dup >cla @ _class <> abort" :DERIVE >> Can only define on-derive hooks for classes! (Did you pass a trait?)"
    [[ :noname on-derive-xt ! ]] ;

\ ==============================================================================
\ Misc
\ ==============================================================================

aka nprop nproperty
aka prop property

\ Validation
: valid-class? ( a - n:res )
    dup firstname here within  >r  \ in dictionary
    r@ 0< if
        dup >cla @ _class = r> and >r
    then
    drop r> ;

: valid-classifier? ( a - n:res )
    dup firstname here within  >r  \ in dictionary
    r@ 0< if
        dup 's magic @ MAGIC_CLASSIFIER = r> and >r
    then
    drop r> ;

: valid-object? ( a - n:res )
    dup firstname here within  >r  \ in dictionary
    r@ 0< if
        dup >cla @ ( class ) valid-class? r> and >r
    then
    drop r> ;

: copy ( a1 a2 - a2 )
    dup dup >r sizeof move r> ;

\ TODO: Optimize and put the runtime checks in optional validations.
: is? ( object|class classifier - bool )
    over valid-object? not abort" IS? >> Invalid object."
    dup valid-classifier? not abort" IS? >> Invalid classifier."
    's classifier# @ swap
    dup >cla @ _class <> if >cla @ then 's id-table test-bit ;
    
\ ==============================================================================
\ _OBJECT Base Protocols
\ ==============================================================================

0 to classifier

_object :: info ( - )
    \ Default inspection - show class name and address
    me . cla @ .name me .name ;

_object :: describe ( - )
    \ Detailed inspection - override in subclasses for specific info
    me info ;

_object :: on-exec-error ( xt error# - )
    throw ;
    
' on-exec-error is (on-exec-error)

\ ==============================================================================
\ Apply _OBJECT to other system classifiers
\ ==============================================================================

_class is-a _object
_trait is-a _object
_protocol is-a _object
_property is-a _object
_static is-a _object

\ ==============================================================================
\ Init/Reset
\ ==============================================================================

|| _trait object object%-fresh  
_object object%-fresh copy drop

|| : reset-object-trait ( - )
||     object%-fresh _object copy drop ;

|| variable fresh-next-classifier#
|| variable fresh-/static

|| : init-nib ( - )
||     fresh-next-classifier# @ next-classifier# ! 
||     fresh-/static @ to /static
||     0 to classifier
||     reset-object-trait ;

|| : gild-nib ( - )
    next-classifier# @ fresh-next-classifier# !
    /static fresh-/static ! ;