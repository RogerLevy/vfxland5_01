\ ==============================================================================
\ Serialization Support
\ ==============================================================================

\ : <array ( - )
\     current-property 0= abort" <ARRAY >> No property being defined"
\     TYPE_ARRAY current-property -> property-type ! ;

: serialize? ( property - flag )
    -> serialize-flag @ ;

|| 0 value val-addr

|| : bin-ser-cell ( - ) val-addr @ , ;
|| : bin-ser-int ( - ) val-addr @ , ;
|| : bin-ser-fixed ( - ) val-addr @ , ;
|| : bin-ser-float ( - ) val-addr @ , ;
|| : bin-ser-cstring ( - ) val-addr count $, ;

|| : bin-deser-cell ( a - a' ) @+ val-addr ! ;
|| : bin-deser-int ( a - a' ) @+ val-addr ! ;
|| : bin-deser-fixed ( a - a' ) @+ val-addr ! ;
|| : bin-deser-float ( a - a' ) @+ val-addr ! ;
|| : bin-deser-cstring ( a -a'  ) $@+ val-addr place ;

|| create bin-ser-table
||     ' bin-ser-cell ,
||     ' bin-ser-int ,
||     ' bin-ser-fixed ,
||     ' bin-ser-float ,
||     ' bin-ser-cstring ,

|| create bin-deser-table
||     ' bin-deser-cell ,
||     ' bin-deser-int ,
||     ' bin-deser-fixed ,
||     ' bin-deser-float ,
||     ' bin-deser-cstring ,

: serbin ( obj - )
    \ serialize object into dictionary in binary format
    {: obj | property0 &count :}
    obj [[ 
        cla @ >name count $,
        here to &count 0 , 
        cla @ -> property-list dup list-count for
            @next to property0
            property0 serialize? if
                \ serialize the property
                1 &count +!
                me property0 -> offset @ prop+ to val-addr
                property0 >name count $,
                property0 -> property-type @ cells bin-ser-table + @ execute
            then
        loop drop 
    ]] ;

: desbin ( a instance-xt - a' ) ( class - obj )
    \ deserialize object from given buffer address in binary format
    \ returns updated buffer address
    {: data xt | property0 :}
    data
    \ dup 100 dump
    $@+ \ fetch class name
    \ 2dup type cr
    >pad find 0= abort" desbin >> Encountered unknown class name."
    >body dup valid-class? not abort" desbin >> Encountered invalid class."
    ( class ) xt execute [[
        \ fetch properties
        @+ for
            $@+ \ fetch property name
            \ 2dup type cr
            >pad find 0= abort" desbin >> Encountered unknown property name."
            >body dup -> cla @ _property <> abort" desbin >> Encountered invalid property."
            to property0
            \ deserialize the property
            me property0 -> offset @ prop+ to val-addr
            ( a ) 
            property0 -> property-type @ cells bin-deser-table + @ execute
            ( a' )
        loop
    ]]
    ( a' ) ;

: inspect-member ( member val-addr - )
    over -> cla @ _class = if 
        drop .name cr
    else
        inspect-property
    then ;

: readbin ( a cb - a' ) ( member val-addr - )
    {: data cb | property0 :}
    data 
    $@+ \ fetch class name
    >pad find 0= abort" READBIN >> Encountered unknown class name."
    >body dup valid-class? not abort" READBIN >> Encountered invalid class."
    ( class ) 0 cb execute
    \ Walk properties:
    @+ for
        $@+ \ fetch property name
        >pad find 0= abort" READBIN >> Encountered unknown property name."
        >body dup -> cla @ _property <> abort" READBIN >> Encountered invalid property."
        to property0

        \ fetch the value
        val-addr >r
        property0 -> property-size @ allocate throw to val-addr
        ( a ) 
        property0 -> property-type @ cells bin-deser-table + @ execute
        ( a' )
        \ execute the callback
        property0 val-addr cb execute
        val-addr free throw
        r> to val-addr
    loop
    ( a' ) ;

: .bin ( data - )
    ['] inspect-member readbin drop ;

: sermulti ( iterable filter-xt ser-xt - ) ( obj - flag ) ( obj - ) 
    {: arr filter-xt ser-xt | &count :}
    here to &count 0 ,
    arr #items for
        i arr deref-index 
        dup filter-xt execute if
            1 &count +!
            ser-xt execute 
        else drop then
    loop ;

: desmulti ( a instance-xt deser-xt - a' ) ( class - obj ) ( a instance-xt - a' ) 
    {: a instance-xt deser-xt :}
    a @+ for
        instance-xt deser-xt execute
    loop ;
