\ ==============================================================================
\ Serialization Support
\ ==============================================================================

1 constant GLOBAL_ENCODING_VERSION
s" BIN" drop @ 
$FFFFFF and GLOBAL_ENCODING_VERSION 24 lshift or constant MAGIC_BIN

trait: _object
    static version              \ always 0 for now, serialized but not checked
trait;

: serialize? ( property - flag )
    -> serialize-flag @ ;

|| 0 value val-addr

|| : bin-ser-cell ( - ) val-addr @ , ;
|| : bin-ser-int ( - ) val-addr @ , ;
|| : bin-ser-fixed ( - ) val-addr @ , ;
|| : bin-ser-float ( - ) val-addr @ , ;
|| : bin-ser-cstring ( - ) val-addr count $, ;

|| : bin-deser-cell ( a - a' ) @+ val-addr ! ;
|| : bin-deser-int ( a - a' ) @+ val-addr ! ;
|| : bin-deser-fixed ( a - a' ) @+ val-addr ! ;
|| : bin-deser-float ( a - a' ) @+ val-addr ! ;
|| : bin-deser-cstring ( a -a'  ) $@+ val-addr place ;

|| create bin-ser-table
||     ' bin-ser-cell ,
||     ' bin-ser-int ,
||     ' bin-ser-fixed ,
||     ' bin-ser-float ,
||     ' bin-ser-cstring ,

|| create bin-deser-table
||     ' bin-deser-cell ,
||     ' bin-deser-int ,
||     ' bin-deser-fixed ,
||     ' bin-deser-float ,
||     ' bin-deser-cstring ,

borrow nib2/ prop+

: serbin, ( obj - )
    \ serialize object into dictionary in binary format
    {: obj | property0 &count &psize tmpl-addr :}
    obj [[ 
        cla @ >name count $,
        version @ ,
        here to &count 0 , 
        cla @ -> property-list list-count for
            @next to property0
            property0 serialize? if
                \ get the property address in the instance and in the template
                me property0 prop+ to val-addr
                cla @ >template property0 prop+ to tmpl-addr

                \ check if the value differs from the class's template
                val-addr   property0 -> property-size @ 
                tmpl-addr   property0 -> property-size @ 
                compare 0<> if
                    \ it differs: serialize the property
                    1 &count +!
                    property0 >name count $,
                    here to &psize 0 , 
                    property0 -> property-type @ cells bin-ser-table + @ execute
                    here &psize - cell- &psize !
                then
            then
        loop drop 
    ]] ;

|| : skip-data ( a - a' )
    @+ + ;

|| : skip-property ( a - a' ) 
    $@+ 2drop skip-data ;

|| : skip-properties ( a - a' ) 
    @+ for skip-property loop ;

|| : @class+ ( a - a' class|0 )
    $@+ \ fetch class name
    >pad find 0= if
        drop
        pad count f" desbin+ >> Encountered unknown class name: `%s`" type cr
        cell+ \ skip version
        skip-properties 0 exit
    then
    >body dup valid-class? not if
        drop
        pad count f" desbin+ >> Not a class: `%s`" type cr
        cell+ \ skip version
        skip-properties 0 exit
    then 
    ( a' class ) cell u+ \ skip version
;    

|| : @property+ ( a - a' property|0 )
    $@+ \ fetch property name
    >pad find 0= if
        drop
        pad count f" desbin+ >> Encountered unknown property name: `%s`" type cr
        skip-data 0 exit
    then
    >body dup -> cla @ _property <> if
        drop
        pad count f" desbin+ >> Not a property: `%s`" type cr
        skip-data 0 exit
    then ;

|| : deser-property ( a property - a' )
    {: a property0 :}
    a @+ swap ( n a )
    property0 -> serialize-flag @ if
        me property0 prop+ to val-addr   \ get dest address
        ( n a ) dup 
        property0 -> property-type @ cells bin-deser-table + @ execute 
        drop
    then 
    ( n a ) + ;

: desbin+ ( a instance-xt - a' ) ( class - obj )
    \ deserialize object from given buffer address in binary format
    \ returns updated buffer address
    {: data xt | property0 :}
    data 
    @class+ ?dup if 
        ( a class ) xt execute [[
            \ fetch properties into returned object
            @+ for
                @property+ ?dup if deser-property then
            loop
        ]]
    then
    ( a' ) ;

\ old reading method:
\ || : skim-property ( a property cb - a' )
\     \ read the data then discard
\     {: a property0 cb :}
\     @+ swap
\     property0 -> serialize-flag @ if
\         val-addr >r
\         property0 -> property-size @ allocate throw to val-addr
\         ( a ) property0 -> property-type @ cells bin-deser-table + @ execute drop
\         property0 val-addr cb execute
\         val-addr free throw
\         r> to val-addr
\     then 
\     ( n a ) + ;

\ : inspect-member ( member val-addr - )
\     over -> cla @ _class = if 
\         drop .name cr
\     else
\         inspect-property
\     then ;

\ || 0 value it

\ : heap-instance ( class - obj )
\     \ instantiate given class in system heap without constructing it
\     dup sizeof allocate throw dup >r scaffold r> dup to it ;

\ : desbin+d ( a - a' obj )
\     \ dynamic deserializer
\     ['] heap-instance desbin+ it ;

\ : readbin+ ( a cb - a' ) ( member val-addr - )
\     \ TODO: implement by deserializing into heap instance that we then destroy
\ ;

\ : readbin+ ( a cb - a' ) ( member val-addr - )
\     {: data cb | property0 :}
\     data 
\     @class+ ?dup if
\         @+ for
\             @property+ ?dup if cb skim-property then
\         loop
\     then ;

\ : .bin ( data - )
\     ['] inspect-member readbin+ drop ;
