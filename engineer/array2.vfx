\ ------------------------------------------------------------------------------
\ Arrays (NIBS)
\ ------------------------------------------------------------------------------

trait: _iterable
    prop item-count
trait;

: #items ( iterable - n ) 's item-count @ ;
_iterable :: vacate ( - ) 0 item-count ! ;
_iterable :: index ( a - n ) stub ; 
_iterable :: deref-index ( n - ? ) stub ;

variable (enough)
: enough  (enough) on ;
    
_iterable :: [] ( n - a )
    \ pronounced "box"
    stub ;

: (each) ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me [] xt execute
        (enough) @ if unloop exit then
    loop ;

_iterable :: each ( xt - ) ( ... a - ... )
    (enough) @ >r
    (enough) off
    ['] (each) catch
    r> (enough) !
    throw ;
    
: (each@) ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me deref-index xt execute
        (enough) @ if unloop exit then
    loop ;

_iterable :: each@ ( xt - ) ( ... ? - ... )
    (enough) @ >r
    (enough) off
    ['] (each@) catch
    r> (enough) !
    throw ;

: n[] ( n. iterable - a )
    \ Index into iterable based on a value in range 0 ~ 1.0
    \ pronounced "n-box"
    dup >r 's item-count @ 1 - p* r> [] ;

\ Essential queries:
_iterable :: empty? ( - bool )
    item-count @ 0= ;

: in-bounds? ( n iterable - b )
    [[ dup 0 item-count @ 1 - within? ]] ;

_iterable :: ?bounds ( n - n )
    me in-bounds? not abort" ?BOUNDS >> Index out of range!" ;

\ Search operations:
_iterable :: find-index ( xt - n | -1 ) ( a - b )
    {: xt :}
    item-count @ for
        i me [] xt execute if i unloop exit then
    loop -1 ;

_iterable :: index-of ( item - n | -1 ) ( a - b )
    {: item :}
    item-count @ for
        i me deref-index item = if i unloop exit then
    loop -1 ;

_iterable :: contains? ( item - bool )
    me index-of 0 >= ;
      
\ Access helpers:
\ For object/reference types:
_iterable :: head ( - a )
    0 me ?bounds me [] ;

_iterable :: tail ( - a )
    item-count @ 1 - me ?bounds me [] ;

\ For value types:
_iterable :: head@ ( - ? )
    0 me ?bounds me deref-index ;

_iterable :: tail@ ( - ? )
    item-count @ 1 - me ?bounds me deref-index ;

\ Functional operations:
\ iterable% :: map ( xt dest - )
\     {: xt dest :}
\     item-count @ for
\         i me [] xt execute
\         i dest [] !
\     loop ;
\ 
\ iterable% :: filter ( xt dest - count )
\     {: xt dest | j :}
\     item-count @ for
\         i me [] dup xt execute if
\             j dest [] !
\             j 1+ to j
\         else drop then
\     loop j ;

trait: _lifo trait;
_lifo :: push ( item - ) stub ; 
_lifo :: pop ( - item ) stub ; 
_lifo :: push-copy ( a - ) stub ; 
_lifo :: pop-ref ( - a ) stub ; 
_lifo :: peek ( - item ) stub ;
_lifo :: peek-ref ( - a ) stub ;

trait: _fifo trait;
_fifo :: enqueue ( item - ) stub ;
_fifo :: dequeue ( - item ) stub ;
_fifo :: enqueue-copy ( a - ) stub ;
_fifo :: dequeue-ref ( - a ) stub ;
_fifo :: peek ( - item ) stub ;
_fifo :: peek-ref ( - item ) stub ;

class: _array
    is-a _iterable
    prop max-items
    prop item-size
    prop data
class;

2 _array :construct ( max-items item-size - )
    dup  0  16 1024 * 1024 *  within? not abort" Invalid array item size" 
    2dup item-size ! max-items !
    max-items @ item-count !
    here data ! * allot&erase ;

: /item ( array - n )
    's item-size @ ;

_array :: index ( a - n )
    data @ - item-size @ / me ?bounds ;

_array :: [] ( n - a )
    me ?bounds item-size @ * data @ + ;

_array :: deref-index ( n - ? )
    me [] @ ;

class: _stack
    _array derive
    is-a _lifo
class;

2 _stack :construct ( max-items item-size - )
    2dup item-size ! max-items !
    here data ! * allot&erase ;

_stack :: push ( item - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  me tail ! ;

_stack :: pop ( - item )
    item-count @ 0= abort" Underflow."
    me tail @  -1 item-count +! ;

_stack :: push-copy ( a - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  ( a ) me tail item-size @ move ;

_stack :: pop-ref ( - a )
    item-count @ 0= abort" Underflow."
    me tail  -1 item-count +! ;

\ ------------------------------------------------------------------------------

: array[ ( item-size - )
    0 swap _array instance [[
    here data !  me ]] ;  \ just to be sure

: array] ( array - array )
    [[ here data @ - item-size @ /
    dup item-count ! max-items !   me ]] ;

: pad-array  ( array count - array )
    \ Pad out an array being built, to given count
    over [[ data @ item-size @ rot * + here - allot&erase ]] ;

: array ( max width - <name> )
    _array object ;

: stack ( max width - <name> )
    _stack object ;

: object-table: ( a <name> - ) ( - object )
    create , cell array[
    does> @+ @ swap [] @ ;

: object-table; ( - )
    array] drop ;

: object-array ( c class <name> - )
    {: count class0 :}
    create count class0 sizeof _array instance [[
        count for
            class0 i me [] construct
        loop
    ]] ;