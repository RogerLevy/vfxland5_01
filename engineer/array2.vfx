\ ------------------------------------------------------------------------------
\ Arrays (NIBS)
\ ------------------------------------------------------------------------------

trait: iterable%
    prop item-count
trait;

: #items ( iterable - n ) 's item-count @ ;
iterable% :: vacate ( - ) 0 item-count ! ;
iterable% :: index ( a - n ) stub ; 
iterable% :: deref-index ( n - ? ) stub ;

variable (enough)
: enough  (enough) on ;
    
iterable% :: [] ( n - a )
    \ pronounced "box"
    stub ;

: (each) ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me [] xt execute
        (enough) @ if unloop exit then
    loop ;

iterable% :: each ( xt - ) ( ... a - ... )
    (enough) @ >r
    (enough) off
    ['] (each) catch
    r> (enough) !
    throw ;
    
: (each@) ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me deref-index xt execute
        (enough) @ if unloop exit then
    loop ;

iterable% :: each@ ( xt - ) ( ... ? - ... )
    (enough) @ >r
    (enough) off
    ['] (each@) catch
    r> (enough) !
    throw ;

: n[] ( n. iterable - a )
    \ Index into iterable based on a value in range 0 ~ 1.0
    \ pronounced "n-box"
    dup >r 's item-count @ 1 - p* r> [] ;

\ Essential queries:
iterable% :: empty? ( - bool )
    item-count @ 0= ;

iterable% :: ?bounds ( n - n )
    dup 0 item-count @ 1 - within? not abort" ?BOUNDS >> Index out of range!" ;

\ Search operations:
iterable% :: find-index ( xt - n | -1 ) ( a - b )
    {: xt :}
    item-count @ for
        i me [] xt execute if i unloop exit then
    loop -1 ;

iterable% :: index-of ( item - n | -1 ) ( a - b )
    {: item :}
    item-count @ for
        i me deref-index item = if i unloop exit then
    loop -1 ;

iterable% :: contains? ( item - bool )
    me index-of 0 >= ;
      
\ Access helpers:
\ For object/reference types:
iterable% :: head ( - a )
    0 me ?bounds me [] ;

iterable% :: tail ( - a )
    item-count @ 1 - me ?bounds me [] ;

\ For value types:
iterable% :: head@ ( - ? )
    0 me ?bounds me deref-index ;

iterable% :: tail@ ( - ? )
    item-count @ 1 - me ?bounds me deref-index ;

\ Functional operations:
\ iterable% :: map ( xt dest - )
\     {: xt dest :}
\     item-count @ for
\         i me [] xt execute
\         i dest [] !
\     loop ;
\ 
\ iterable% :: filter ( xt dest - count )
\     {: xt dest | j :}
\     item-count @ for
\         i me [] dup xt execute if
\             j dest [] !
\             j 1+ to j
\         else drop then
\     loop j ;

trait: lifo% trait;
lifo% :: push ( item - ) stub ; 
lifo% :: pop ( - item ) stub ; 
lifo% :: push-copy ( a - ) stub ; 
lifo% :: pop-ref ( - a ) stub ; 
lifo% :: peek ( - item ) stub ;
lifo% :: peek-ref ( - a ) stub ;

trait: fifo% trait;
fifo% :: enqueue ( item - ) stub ;
fifo% :: dequeue ( - item ) stub ;
fifo% :: enqueue-copy ( a - ) stub ;
fifo% :: dequeue-ref ( - a ) stub ;
fifo% :: peek ( - item ) stub ;
fifo% :: peek-ref ( - item ) stub ;

class: array%
    is-a iterable%
    prop max-items
    prop item-size
    prop data
class;

2 array% :construct ( max-items item-size - )
    2dup item-size ! max-items !
    max-items @ item-count !
    here data ! * allot&erase ;

array% :: index ( a - n )
    data @ - item-size @ / me ?bounds ;

array% :: [] ( n - a )
    me ?bounds item-size @ * data @ + ;

array% :: deref-index ( n - ? )
    me [] @ ;

class: stack%
    array% derive
    is-a lifo%
class;

2 stack% :construct ( max-items item-size - )
    2dup item-size ! max-items !
    here data ! * allot&erase ;

stack% :: push ( item - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  me tail ! ;

stack% :: pop ( - item )
    item-count @ 0= abort" Underflow."
    me tail @  -1 item-count +! ;

stack% :: push-copy ( a - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  ( a ) me tail item-size @ move ;

stack% :: pop-ref ( - a )
    item-count @ 0= abort" Underflow."
    me tail  -1 item-count +! ;

\ ------------------------------------------------------------------------------

: array[ ( item-size - )
    0 swap array% construct [[
    here data ! ;  \ just to be sure

: array] ( - array )
    here data @ - item-size @ /
    dup item-count ! max-items !   me ]] ;

: pad-array  ( count - )
    \ Pad out an array being built, to given count
    data @ item-size @ rot * + here - allot&erase ;

: array ( max width - <name> )
    array% object ;

: stack ( max width - <name> )
    stack% object ;

: object-table: ( a <name> - ) ( - object )
    create , cell array[
    does> @+ @ swap [] @ ;

: object-table;  array] drop ;