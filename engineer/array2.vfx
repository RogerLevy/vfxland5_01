\ ------------------------------------------------------------------------------
\ Arrays (NIBS)
\ ------------------------------------------------------------------------------

trait: %iterable
    prop item-count :int <save
    :: vacate ( - ) 0 item-count ! ;
    :: index ( a - n ) stub ; 
    :: deref-index ( n - ? ) stub ;
    redef :: [] ( n - a ) stub ; \ pronounced "box"
    :: redim ( #items - ) stub ;
trait;

: #items ( iterable - n ) -> item-count @ ;

|| variable (enough)
: enough  (enough) on ;

|| : (each) ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me [] xt execute
        (enough) @ if unloop exit then
    loop ;

%iterable :: each ( xt - ) ( ... a - ... )
    (enough) @ >r
    (enough) off
    ['] (each) catch
    r> (enough) !
    throw ;

|| : (each@) ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me deref-index xt execute
        (enough) @ if unloop exit then
    loop ;

%iterable :: each@ ( xt - ) ( ... ? - ... )
    (enough) @ >r
    (enough) off
    ['] (each@) catch
    r> (enough) !
    throw ;

: r[] ( n. iterable - a )
    \ Index into iterable based on a value in range 0 ~ 1.0
    \ pronounced "r-box"
    dup >r -> item-count @ 1 - p* r> [] ;

\ Essential queries:
%iterable :: empty? ( - bool )
    item-count @ 0= ;

: in-bounds? ( n iterable - b )
    { dup 0 item-count @ 1 - within? } ;

%iterable :: ?bounds ( n - n )
    me in-bounds? not abort" ?BOUNDS : Index out of range!" ;

\ Search operations:
%iterable :: find-index ( xt - n | -1 ) ( a - b )
    {: xt :}
    item-count @ for
        i me [] xt execute if i unloop exit then
    loop -1 ;

%iterable :: index-of ( item - n | -1 ) ( a - b )
    {: item :}
    item-count @ for
        i me deref-index item = if i unloop exit then
    loop -1 ;

%iterable :: contains? ( item - bool )
    me index-of 0 >= ;
      
\ Access helpers:
\ For object/reference types:
%iterable :: head ( - a )
    0 me ?bounds me [] ;

%iterable :: tail ( - a )
    item-count @ 1 - me ?bounds me [] ;

\ For value types:
%iterable :: head@ ( - ? )
    0 me ?bounds me deref-index ;

%iterable :: tail@ ( - ? )
    item-count @ 1 - me ?bounds me deref-index ;

\ Functional operations:
\ iterable :: map ( xt dest - )
\     {: xt dest :}
\     item-count @ for
\         i me [] xt execute
\         i dest [] !
\     loop ;
\ 
\ iterable :: filter ( xt dest - count )
\     {: xt dest | j :}
\     item-count @ for
\         i me [] dup xt execute if
\             j dest [] !
\             j 1+ to j
\         else drop then
\     loop j ;

trait: %lifo trait;
%lifo :: push ( item - ) stub ; 
%lifo :: pop ( - item ) stub ; 
%lifo :: push-copy ( a - ) stub ; 
%lifo :: pop-ref ( - a ) stub ; 
%lifo :: peek ( - item ) stub ;
%lifo :: peek-ref ( - a ) stub ;

trait: %fifo trait;
%fifo :: enqueue ( item - ) stub ;
%fifo :: dequeue ( - item ) stub ;
%fifo :: enqueue-copy ( a - ) stub ;
%fifo :: dequeue-ref ( - a ) stub ;
%fifo :: peek ( - item ) stub ;
%fifo :: peek-ref ( - item ) stub ;

class: %array
    is-a %iterable
    prop max-items :int <save
    prop item-size :int <save
    prop data :addr
class;

2 %array :construct ( max-items item-size - )
    dup  0  16 1024 * 1024 *  within? not abort" Invalid array item size" 
    2dup item-size ! max-items !
    max-items @ item-count !
    align here data ! * allot&erase ;

: /item ( array - n )
    -> item-size @ ;

%array :: index ( a - n )
    data @ - item-size @ / me ?bounds ;

%array :: [] ( n - a )
    me ?bounds item-size @ * data @ + ;

%array :: deref-index ( n - ? )
    me [] @ ;

%array :: redim ( #items - )
    dup max-items @ = if drop exit then
    item-size @ max-items @ * >r   data @ >r
    ( #items ) item-size @ array:construct 
    r> data @   item-size @ max-items @ *   r> min   move ;

\ ------------------------------------------------------------------------------

class: %stack
    %array derive
    is-a %lifo
class;

2 %stack :construct ( max-items item-size - )
    dup  0  16 1024 * 1024 *  within? not abort" Invalid array item size" 
    2dup item-size ! max-items !
    align here data ! * allot&erase ;

%stack :: push ( item - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  me tail ! ;

%stack :: pop ( - item )
    item-count @ 0= abort" Underflow."
    me tail @  -1 item-count +! ;

%stack :: push-copy ( a - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  ( a ) me tail item-size @ move ;

%stack :: pop-ref ( - a )
    item-count @ 0= abort" Underflow."
    me tail  -1 item-count +! ;

%stack :: redim ( #items - )
    dup max-items @ = if drop exit then
    item-size @ max-items @ * >r   data @ >r
    ( #items ) item-size @ stack:construct 
    r> data @   item-size @ max-items @ *   r> min   move 
    item-count @ max-items @ min item-count ! ;

\ ------------------------------------------------------------------------------

: array{ ( item-size - array )
    0 swap %array make {
    here data !  me } ;  \ just to be sure

: array} ( array - array )
    { here data @ - item-size @ /
    dup item-count ! max-items !   me } ;

: pad-array  ( array count - array )
    \ Pad out an array being built, to given count
    over { data @ item-size @ rot * + here - allot&erase } ;

redef : array ( max width - <name> )
    %array object ;

redef : stack ( max width - <name> )
    %stack object ;

class: %object-array
    %array derive
    :: deref-index ( n - ? ) me [] ;
class;

: object-array ( n class <name> - )
    {: count class0 :}
    create count class0 sizeof %object-array make {
        count for
            class0 i me [] construct
        loop
    } ;

