\ ------------------------------------------------------------------------------
\ Arrays (NIBS)
\ ------------------------------------------------------------------------------

trait: iterable%
    prop item-count
trait;

: #items ( iterable - n )
    's item-count @ ;
    
iterable% :: vacate ( - )
    0 item-count ! ;

iterable% :: index ( a - n )
    stub ; 

iterable% :: each ( xt - ) ( a - )
    {: xt :} 
    item-count @ for
        i me [] xt execute
    loop ;

iterable% :: [] ( n - a )
    \ pronounced "box"
    stub ;

: n[] ( n. iterable - a )
    \ Index into iterable based on a value in range 0 ~ 1.0
    \ pronounced "n-box"
    dup >r 's item-count @ 1 - p* r> [] ;

\ Begin Claude stuff -----------------------------------------------------------
\ Essential queries:
iterable% :: empty? ( - bool )
    item-count @ 0= ;

iterable% :: ?bounds ( n - n )
    dup 0 item-count @ within? not abort" ?BOUNDS >> Index out of range!" ;

\ Search operations:
iterable% :: find-index ( xt - n | -1 )
    {: xt :}
    item-count @ for
        i me [] xt execute if i unloop exit then
    loop -1 ;

iterable% :: deref-index ( n - ? )
    stub ;

iterable% :: index-of ( item - n | -1 )
    {: item :}
    item-count @ for
        i me deref-index item = if i unloop exit then
    loop -1 ;

iterable% :: contains? ( item - bool )
    me index-of 0>= ;
      
\ Access helpers:
\ For value types:
iterable% :: first-value ( - value )
    0 me ?bounds me [] @ ;

iterable% :: last-value ( - value )
    item-count @ 1 - me ?bounds me [] @ ;

\ For object/reference types:
iterable% :: first-ref ( - object )
    0 me ?bounds me [] ;

iterable% :: last-ref ( - object )
    item-count @ 1 - me ?bounds me [] ;

\ Functional operations:
\ iterable% :: map ( xt dest - )
\     {: xt dest :}
\     item-count @ for
\         i me [] xt execute
\         i dest [] !
\     loop ;
\ 
\ iterable% :: filter ( xt dest - count )
\     {: xt dest | j :}
\     item-count @ for
\         i me [] dup xt execute if
\             j dest [] !
\             j 1+ to j
\         else drop then
\     loop j ;
\ End Claude stuff -------------------------------------------------------------

trait: lifo% trait;
lifo% :: push ( item - ) stub ; 
lifo% :: pop ( - item ) stub ; 
lifo% :: push-data ( a - ) stub ; 
lifo% :: pop-data ( - a ) stub ; 
lifo% :: peek ( - item ) stub ;
lifo% :: peek-data ( - a ) stub ;

trait: fifo% trait;
fifo% :: enqueue ( item - ) stub ;
fifo% :: dequeue ( - item ) stub ;
fifo% :: enqueue-data ( a - ) stub ;
fifo% :: dequeue-data ( - a ) stub ;
fifo% :: peek ( - item ) stub ;
fifo% :: peek-data ( - item ) stub ;

class: array%
    array% is-a iterable%
    prop max-items
    prop item-size
    prop data
class;

array% :: index ( a - n )
    data @ - item-size @ / me ?bounds ;

array% :: [] ( n - a )
    me ?bounds item-size @ * data @ + ;

array% :: deref-index ( n - ? )
    me [] @ ;

2 array% constructor: ( max-items item-size - )
    2dup item-size ! max-items !
    max-items @ item-count !
    here data ! * allot&erase ;

class: stack%
    stack% is-a lifo%
    array% derive
    prop next-item#
class;

2 stack% constructor: ( max-items item-size - )
    2dup item-size ! max-items !
    here data ! * allot&erase ;

stack% :: push ( item - )
    item-count @ max-items @ = abort" Overflow."
    1 item-count +!  me first-ref ! ;

stack% :: pop ( - item )
    item-count @ 0= abort" Underflow."
    me first-ref @  -1 item-count +! ;

stack% :: push-data ( a - )
    {: src :}
    1 item-count +!  src me first-ref item-size move ;

stack% :: pop-data ( - a )
    me first-ref  -1 item-count +! ;

: array[ ( item-size - item-size source-a )
    \ Begin building an unnamed prepopulated array
    here ;

: array] ( item-size source-a - array )
    \ Complete building an unnamed prepopulated array
    {: w srca | n :}
    here srca - w / to n
    array% object [[
        src data @ n move
    me ]] ;

: pad-array  ( item-size source-a max-items - item-size a )
    \ Pad out an array being built, to given max-items
    | n a w | a w n * + here - allot&erase w a ;

: array ( max width - <name> )
    array% object ;

: stack ( max width - <name> )
    stack% object ;

    
