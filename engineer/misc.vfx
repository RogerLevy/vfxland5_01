\ ------------------------------------------------------------------------------
\ Misc
\ ------------------------------------------------------------------------------

: e -1 abort" e is not defined" ;

synonym aka synonym
aka not 0=
: >zpad  ( a n - z$ ) pad zplace pad ;
: >pad   ( a n - $ ) pad place pad ;
: $+     ( $ a n - $ ) rot dup >r append r> ;
: ?exit  ( n - ) s" if exit then" evaluate ; immediate
: -exit  ( n - ) s" 0= if exit then" evaluate ; immediate 
aka | locals|
aka cd cwd
: 2+  ( x y x y - x' y' ) rot + >r + r> ;
: 2-  ( x y x y - x' y' ) rot swap - >r - r> ;
: for ( n - ) s" 0 ?do" evaluate ; immediate
: @+  ( a - a' n ) dup cell+ swap @ ;
: c@+ ( a - a' n )  dup 1 + swap c@ ;
: lc  ( n - n ) dup 'A' 'Z' within? if $20 or then ;
: ltype  ( a n - ) for c@+ lc emit loop drop ;      
: pagealign ( - )  here $ff and 256 swap - allot ;
: aligned-page ( - <name> )  pagealign here $100 allot&erase constant ;
: ?execute ( xt - ) ?dup -exit >r ;

: screate ( name len - ) ( - a )
    {: | name$[ 256 ] :} name$[ place name$[ $create ;

include %idir%/../textmode/textmode-tools.vfx

: IP>NFA        \ addr -- nfa
\ *G Attempt to move backwards from an address within a definition to
\ ** the relevant NFA.
  13 -			\ NFA (count byte) is at least this far back
  1024 for
    dup InForth? 0= if drop  C" <???> "  unloop exit then
    dup name? if unloop exit then
    1-
  loop 
  drop  C" <???> " ;

: >name ( xt -- nfa|xt )
\ *G Move a pointer from an XT back to the NFA or name-pointer.
\ ** If the original pointer was not an XT or if the definition in
\ ** question has no name header in the dictionary the returned pointer
\ ** will be useless. Care should be taken when manipulating or scanning
\ ** the Forth dictionary in this way. If *\i{xt} is outside the
\ ** dictionary, a dummy for "???" is returned.
  dup inForth? if
    unalign  ip>nfa
  else
    drop  dummyNFA
  endif
;

: >zname ( xt -- znfa|xt )
    >name 1 + ;

: .name ( a - )
    \ Smart name print
    \ NOTE: Slow!
    dup body> inForth? if
        14 push-foreground
        body> >name count ltype space
        pop-attribute
    else . then ;

: .ip ( a - )
    dup body> inForth? if
        11 push-foreground
        dup ip>nfa dup count ltype
        name> - ?dup if
            ." +" .
        else
            space
        then
        pop-attribute
    else . then ;

: .data ( a - )
    dup body> inForth? if
        12 push-foreground
        dup ip>nfa dup count ltype
        name> >body - ?dup if
            ." +" .
        else
            space
        then
        pop-attribute
    else . then ;

: f>ds  ( f:n - dl dh ) 0 >r rp@ sf! r> ;
: :now  :noname  ';' parse evaluate  postpone ;  execute ;

: link ( list - )
    \ backward-linked list (chain)
    here  over @ ,  swap ! ;

: do-chain ( chain - )
    begin @ ?dup while dup cell+ @ execute repeat ;

: _.s
    depth 8 min | d |
    d 0< -4 ?throw
    3 push-attribute
    d if ."     DS( " depth . ." ):[ " else ."     DS:[ " then
    d if
        d 0 ?do d 1 - i - pick . loop 
    else
        ." Empty! "
    then
    ." ] "
    pop-attribute ;

: .s  _.s cr ;

: _f.s 
    fdepth | d |
    d 0< -400 ?throw
    3 push-attribute
    ."     FS:[ " 
    d if
        d 0 ?do d 1 - i - fpick f. loop 
    else
        ." Empty! "
    then
    ." ] "
    pop-attribute ;

: f.s  _f.s cr ;

: rs ( - ) reset-stacks ;

: ending ( a len c - a' len' )
   >r begin  2dup r@ scan
      ?dup while  2swap 2drop  #1 /string
   repeat  r> 2drop ;

: slashes ( a len - a len )  
    2dup  over + swap do  i c@ '/' = if
    '\' i c!  then  #1 +loop ; 

: -path ( a len - a len' ) slashes  '\' ending  0 max ;
: -ext  ( a len - a len' ) 2dup '.' scan nip - ;

: <scan ( a len c - a len' )
    {: a len c :}
    a len 
    2dup bounds swap 1 - do
        i c@ c = if 1 - exit then 
        1 - 
    -1 +loop ;

aka parse' parse

: parse ( - a len )
    parse-word ;
: preword ( - pad )
    >in @ bl parse rot >in ! >pad ;
: preparse ( - a len )
    >in @ swap parse-word rot >in ! ;

: ?constant ( n - <name> ) ( - n )
    preword find nip if drop ' drop else constant then ;
: ?fconstant ( n - <name> ) ( - n )
    preword find nip if fdrop ' drop else fconstant then ;
: ?value ( n - <name> ) ( - n )
    preword find nip if drop ' drop else value then ;

: lastbody ( - a ) last @ ctrl>nfa name> >body ;

: >lowercase ( a c - a c ) 2dup bounds ?do i dup c@ lc swap c! loop ;
: >uppercase ( a c - a c ) 2dup upper ;

: jumptable ( a - <name> ) ( ... - ... ) 
    create , does> @+ @ cells + @ ?execute ;

: h. ( n - ) ." $" base @ swap hex u. base ! ;
: #. ( n - ) base @ >r  decimal . r> base ! ;

: h.8 ( n - )
    base @ hex  swap
    0 <# # # # # # # # # #> type
    base !
    space ;

: (.rs) ( a -- )
    {: rp :}
    3 push-attribute
    ."     RS:[ " 
    \ Walk from bottom (r0) to top (rp@), going downward
    rp r0 @ over 9 cells + min  ?do
        i @ .name                    \ Print return address
    cell negate +loop
    ." ] "
    pop-attribute ;

: .rs ( -- )
    rp@ (.rs) cr ;

: clamp ( n lo hi - n' ) >r max r> min ;

: umod ( n n -- n' ) 2dup mod dup 0< if + else nip then nip ;

aka se" s\"        \ " \ syntax highlight guard

: walk-order ( xt - ) ( thread# nfa - f )
    {: xt :}
    get-order for
        cr dup .name 
        xt swap WalkWordList
    loop ;
    
: .abort ( err a:msg len:msg - )
    rot if
        4 push-attribute
        ." ABORT: " type cr
        rp@ cell+ (.rs)
        .s
        pop-attribute
        c" " 'AbortText !
        \ EditOnError
        -2 throw
    else
        2drop
    then ;

: abort"
    ?comp
    postpone s"         \ syntax-highlighting guard: "
    postpone .abort  discard-sinline
; immediate

: magic-id ( - <name> <id> )
    create here 0 ,
    bl parse drop @ swap !
    does> @ ;

: .- ( n - ) (.) type ;

: .comma ( n - )
    \ Format number with commas e.g. 100000000 -> 100,000,000
    \ By Claude Sonnet 4
    dup 0< if ." -" abs then
    dup 1000000000 >= if
        dup 1000000000 / .- ." ,"
        1000000000 mod
        dup 1000000 / 0 <# # # # #> type ." ,"
        1000000 mod
        dup 1000 / 0 <# # # # #> type ." ,"
        1000 mod 0 <# # # # #> type
    else dup 1000000 >= if
        dup 1000000 / .- ." ,"
        1000000 mod
        dup 1000 / 0 <# # # # #> type ." ,"
        1000 mod 0 <# # # # #> type
    else dup 1000 >= if
        dup 1000 / .- ." ,"
        1000 mod 0 <# # # # #> type
    else
        .-
    then then then ;

: interpret-string ( a len - res )
    to-source
    -1 to source-id
    0 >in !
    'SourceFile off
    ['] interpret catch 
    dup 0= if
        -1 >in !  \ prevent erroneous source text display on later errors
    then ;

: strip-exe   \ c-addr u -- 'c-addr 'u
  dup 0= if  exit  then
  bl skip               \ c-addr u --
  dup if
    over c@ [char] " = if
      1 /string
      [char] " scan
    else
      bl scan
    then
    1 /string bl skip
  then
;

: strin?  search nip nip ;    
: ?literal  state @ if postpone literal then ;
: .:  postpone (s") 0 parse $, postpone type postpone cr ; immediate

: toggle dup @ 0= swap ! ;
: udup  over swap ;

variable old-dp
: temp{ ( - )  here old-dp ! ;
: temp} ( - a len )  old-dp @ here over -  old-dp @ dp ! ;
    
: $@+ ( a - a' str len ) count 2dup + -rot ;
: $, ( a len - ) dup >r    here place    r> 1 + allot ;

: indent ( n - ) 4 * spaces ;
: cstring ( -- <name> ) create 256 allot&erase ;
  
cstring lastword
: find  dup count lastword place  find ;
: save-next-word  preword count lastword place ;
: '  save-next-word  ' ;
: [']  save-next-word  postpone ['] ; immediate    
: locate  save-next-word locate ;
: see  save-next-word see ;
: show  save-next-word show ;
: aka  save-next-word aka ;

aka save-exe save

: s= compare 0= ;
: ext? ( fn len ext len - flag ) 2swap '.' ending s= ;
: ['] ( <name> - xt ) state @ if postpone ['] else ' then ; immediate
: body>name ( a - a' ) body> >name count ;
: u+  rot + swap ;

\ Search order stack
aligned-page search-order-stack
variable sosp   search-order-stack sosp ! \ object stack pointer
: sos-push ( ? - ) sosp @ !  4 sosp c+! ;
: sos-pop ( - ? ) -4 sosp c+!  sosp @ @ ;
: sos-pushes ( ... n - ) dup >r for sos-push loop r> sos-push ;
: sos-pops ( - ... n ) sos-pop dup >r for sos-pop loop r> ;
: push-order ( - ) get-order sos-pushes get-current sos-push ;
: pop-order ( - ) sos-pop set-current sos-pops set-order ;

: >shout ( a len - ) 
    2>r push-order 2r>
    ['] evaluate catch ?dup if .throw 2drop then
    pop-order ;

: shout" ( - <string>" )
    \ Late-bound execution; don't care if it succeeds.  
    \ Search order is preserved.
    \ Caller cannot pass params in directly.
    state @ if
        postpone (s") ", postpone >shout
    else
        '"' parse >syspad >shout
    then ; immediate

: cutoff ( a len char - a` len` ) >r 2dup r> scan nip - ;
: move, ( a len - ) dup >r here swap move r> allot ;

: continuation: ( <name> - ) ( ... xt - ... )
    create immediate
    here 0 ,
    :noname swap !
    postpone r>
    does> 
        lvcount @ abort" Can't use locals inside continuations."
        @ compile, ;

: redef ( - )
    warnings? >r postpone -warnings 0 parse evaluate r> to warnings? ;

errdef err_redefined "Word redefined"

\ Redefine redefhook: protection from unintentional redefinitions (use REDEF)
: vfxland-redefhook
    6 push-attribute 
        LastNameFound .name ." Word was redefined. (Precede with REDEF to override.)" 
    pop-attribute
    err_redefined throw ;

' vfxland-redefhook is redefhook  

: evaluate-lines ( addr len -- )
    {: addr len | line-start line-len pos :}
    addr to line-start
    0 to pos
    begin
        pos len < while
        addr pos + c@ 10 = if           \ Found newline
            addr pos + line-start - to line-len
            line-len if
                \ line-start line-len type cr
                line-start line-len evaluate
            then
            addr pos + 1+ to line-start \ Start of next line
        then
        1 +to pos
    repeat
    \ Handle last line if no trailing newline
    addr pos + line-start - to line-len
    line-len if
        line-start line-len type cr
        line-start line-len evaluate
    then ;

\ =============================================================================
\ Extend INTERPRET to track last word interpreted
\ =============================================================================

redef : (interpret)	\ --
    page-check
    begin  
        ?stack 
        parse-name 
        2dup lastword place
        dup
    while
        parser execute
    repeat
    2drop ;

' (interpret) is interpret

\ =============================================================================
\ Float-color utilities
\ =============================================================================

redef code sf-!	\ addr -- addr' ; F: -- f
\ *G Places the 32 bit float at addr on the float stack, and
\ ** increments addr by 4.
\ ** NDP387.FTH only.
  add   ebx, # -4		\ update address
  fstp  float 0 [ebx]   \ store at addr
  fnext,
end-code

: 4f@  sf@+ sf@+ sf@+ sf@ ;
: 4f!  4 cells + sf-! sf-! sf-! cell- sf! ;


variable verbose
[defined] verbose-compilation verbose !
: .evaluate  verbose @ if 2dup type cr then evaluate ;


: sandbox ( - ) 
    only previous previous previous ;

\ =============================================================================
\ Custom prompt
\ =============================================================================

: .engineer-prompt    \ --
  ."  ok " 
  depth if _.s then
  fdepth if _f.s then
  depth -> SbDepth
  base @ -> SbBase
  context @ -> sbContext
  current @ -> sbCurrent
;

['] .engineer-prompt is .prompt 

