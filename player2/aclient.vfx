include %idir%/libcurl.fth

extern: void * "C" curl_easy_init();
extern: void "C" curl_easy_setopt( void * curl, int opt, int val );
extern: int "C" curl_easy_perform( void * curl );
extern: void "C" curl_easy_cleanup( void * curl );
extern: void * "C" curl_multi_init();                    \ Create multi manager
extern: int "C" curl_multi_add_handle( multi, easy );     \ Add a request to manager
extern: void "C" curl_multi_remove_handle( multi, easy );  \ Remove a request
extern: int "C" curl_multi_perform( multi, int *running );    \ Do network work (non-blocking)
extern: void "C" curl_multi_cleanup( multi );            \ Clean up multi manager
extern: void * "C" curl_multi_info_read( multi, *msgs );  \ Check for completed requests

struct /curl-msg
    int msg.msg        \ what this message means
    int msg.handle     \ the handle it concerns 
    int msg.whatever   \ message-specific data 
    int msg.result     \ return code for transfer 
end-struct

trait: _object
    :: init ( - ) ;
    :: deinit ( - ) ;
    :: process ( - ) ;
trait;

class: aclient              \ asynchronous http client using libcurl
    prop multi-handle       \ Main multi handle - manages all connections
    prop #transfers
    prop #messages
    prop #requests
    prop requests <ref _array
class;

class: request
    prop en
    prop easy-handle 
    prop on-completion-xt <xt   \ scoped to completed request
    prop streaming
    prop headers            \ slist, automatically freed on completion
    prop op                 \ output handle for callbacks, defaults to consoledev
    prop write-xt           \ ( a len - ) , scoped to the request
    prop data               \ arbitrary data pointer available to write-xt
class;

1 aclient :construct ( request-array - )
    dup _array is? not abort" aclient:construct >> request-array must be an array"
    requests ! ;

aclient :: init ( - )
    curl_multi_init multi-handle !
    multi-handle @ 0= abort" curl_multi_init failed" ;

create response$ 65536 allot
: .response  response$ wcount dump   response$ wcount type ;

private

fast[
: >ascii ( src len dest - dest len )
    {: src len dest | src-end dest-start :}
    dest to dest-start
    src len +   to src-end
    begin src src-end < while 
        src c@ '\' = if
            src-end src 1 + -   5 >= if
                src 1 +   5   s" u003c" compare 0= if
                    '<' dest c!   1 +to dest   6 +to src
                else src 1 +   5   s" u003e" compare 0= if
                    '>' dest c!   1 +to dest   6 +to src  
                else src 1 +   c@ 'n' = if
                    10 dest c!   1 +to dest   2 +to src
                else
                    \ Copy backslash as-is
                    src c@ dest c!   1 +to dest   1 +to src
                then then then 
            else
                \ Not enough chars, copy backslash
                src c@ dest c!   1 +to dest   1 +to src
            then
        else src c@ $E2 = if
            src 2 +   src-end < if
                src 1 +   c@ $80 = 
                src 2 +   c@ $99 = and if
                    [char] ' dest c!   1 +to dest   3 +to src
                else 
                src 1 +   c@ $80 = 
                src 2 +   c@ $94 = and if
                    '-' dest c!   1 +to dest   
                    '-' dest c!   1 +to dest   3 +to src
                else
                src 1 +   c@ $80 = 
                src 2 +   c@ $a6 = and if
                    '.' dest c!   1 +to dest   
                    '.' dest c!   1 +to dest   
                    '.' dest c!   1 +to dest   3 +to src
                else
                    src c@ dest c!   1 +to dest   1 +to src
                then then then
            else
                src c@ dest c!   1 +to dest   1 +to src
            then
        else
            \ Copy character as-is
            src c@ dest c!   1 +to dest   1 +to src
        then then
    repeat
    dest-start   dest dest-start - ;  
fast]

fromC 4 1 callproc: standard-cb ( ptr size nmemb userdata -- bytes-written )
    \ userdata is the request
    {: ptr size nmemb req | buf len :}
    size nmemb * 0= if 0 exit then
    req [[
        op-handle @ >r   op @ op-handle !
        ptr size nmemb * response$ wplace
        size nmemb *  allocate throw to buf
        ptr size nmemb *  buf >ascii to len drop
        write-xt @ if
            buf len   write-xt @ catch .throw
        else
            buf len type   cr  
        then
        buf free drop
        r> op-handle !        
        ptr size nmemb * 
    ]] ;

: *request ( aclient - request )
    as>
        requests @ #items for
            i requests @ deref-index 
            dup -> en @ 0= if
                1 #requests +!
                request over construct
                [[ en on   me ]] unloop exit
            else drop then
        loop 
        -1 abort" Out of request objects" ;

: /request ( url len aclient - request ) 
    {: url len aclient | easy zurl[ 1024 ] :}
    url len zurl[ zplace
    url len type cr

    aclient *request [[
        curl_easy_init to easy
        easy 0= abort" curl_easy_init failed"
        easy easy-handle !
        easy CURLOPT_SSL_VERIFYPEER 0 curl_easy_setopt
        easy CURLOPT_SSL_VERIFYHOST 0 curl_easy_setopt
        easy CURLOPT_URL zurl[ curl_easy_setopt
        easy CURLOPT_HTTP_VERSION 2 curl_easy_setopt 
        easy CURLOPT_WRITEFUNCTION standard-cb curl_easy_setopt  \ standard callback
        easy CURLOPT_WRITEDATA me curl_easy_setopt  \ set userdata = the request
        consoledev op ! 
    me ]] ;

: sendoff ( request aclient - )
    over [[ 
        streaming @ if
            easy-handle @ CURLOPT_TIMEOUT 0 curl_easy_setopt 
        then 
    ]]
    -> multi-handle @   swap -> easy-handle @   curl_multi_add_handle 
    ?dup if
        f" curl_multi_add_handle failed with err # %n" -1 -rot .abort
    then ;

: /get ( - ) easy-handle @ CURLOPT_HTTPGET 1 curl_easy_setopt ;
: /post ( - ) easy-handle @ CURLOPT_POST 1 curl_easy_setopt ;
: /put ( - ) easy-handle @ CURLOPT_CUSTOMREQUEST z" PUT" curl_easy_setopt ;
: /delete ( - ) easy-handle @ CURLOPT_CUSTOMREQUEST z" DELETE" curl_easy_setopt ;

: handle-curl-msg ( curl-msg aclient - )
    {: msg aclient | handle req :}
    0 to req
    aclient as>
        ." curl msg result: " msg msg.result @ . cr

        msg msg.handle @ to handle
        requests @ #items for
            i requests @ deref-index 
            dup -> en @ 0<>
            over -> easy-handle @ handle = and if
                to req leave
            else drop then
        loop
        req 0= if
            msg msg.handle @ f" handle-curl-msg >> Handle %n not found" type cr
            exit
        then
        req [[
            sp@ >r 
            on-completion-xt @ ?dup if 
                execute 
            then
            r> sp!
            headers @ ?dup if curl_slist_free_all then
        ]] 
        multi-handle @ handle curl_multi_remove_handle
        handle curl_easy_cleanup
        req -> streaming @ not if req -> en off   -1 #requests +! then 
;

public

aclient :: process ( - )
    multi-handle @ -exit
    multi-handle @ #transfers curl_multi_perform ?dup if 
        f" curl_multi_perform failed with err # %n" -1 -rot .abort
    then
    begin
        multi-handle @ #messages curl_multi_info_read
    ?dup while
        \ ." incoming curl message..." cr
        me handle-curl-msg
    repeat ;

: setopt ( val opt - ) 
    swap easy-handle @ -rot curl_easy_setopt ;

: on-complete> ( - )
    r> on-completion-xt ! ;

: setheaders ( slist - )
    dup headers !   CURLOPT_HTTPHEADER setopt ;

: setfields ( payload len - )
    ." Fields: " 
    2dup type cr
    CURLOPT_POSTFIELDSIZE setopt   CURLOPT_COPYPOSTFIELDS setopt ;

: get> ( ... url len aclient - ) ( ... - )
    ." GET: " cr
    r> {: url len aclient xt :}
    url len aclient /request [[ /get  xt execute   me ]] aclient sendoff ;

: post> ( ... url len aclient - ) ( ... - )
    ." POST: " cr
    r> {: url len aclient xt :}
    url len aclient /request [[ /post  xt execute   me ]] aclient sendoff ;
 
: @json ( a len - a' len' )
    \ strips braces from returned payload; simple version
    1 -2 2+ ;

: cutoff ( a len char - a` len` )
    >r 2dup r> scan nip - ;

: @field ( payload len name len - val len )
    \ fetch field from returned payload; assumes value is a string surrounded
    \ by double-quotes.
    {: pl pl-len name name-len | buf[ 256 ] :}
    name name-len fe" \"%s\"" buf[ place
    pl pl-len buf[ count search 0= if
        buf[ count f" Field %s not found" -1 -rot .abort 
    then
    buf[ count nip 2 + /string 
    '"' cutoff ;