include %idir%/libcurl.fth
include %vfxland5%/lib/cjson.vfx

extern: void * "C" curl_easy_init();
extern: void "C" curl_easy_setopt( void * curl, int opt, int val );
extern: int "C" curl_easy_perform( void * curl );
extern: void "C" curl_easy_cleanup( void * curl );
extern: void * "C" curl_multi_init();                    \ Create multi manager
extern: int "C" curl_multi_add_handle( multi, easy );     \ Add a request to manager
extern: void "C" curl_multi_remove_handle( multi, easy );  \ Remove a request
extern: int "C" curl_multi_perform( multi, int *running );    \ Do network work (non-blocking)
extern: void "C" curl_multi_cleanup( multi );            \ Clean up multi manager
extern: void * "C" curl_multi_info_read( multi, *msgs );  \ Check for completed requests

struct /curl-msg
    int msg.msg        \ what this message means
    int msg.handle     \ the handle it concerns 
    int msg.whatever   \ message-specific data 
    int msg.result     \ return code for transfer 
end-struct

trait: %object
    :: init ( - ) ;
    :: deinit ( - ) ;
    :: process ( - ) ;
trait;

class: aclient              \ asynchronous http client using libcurl
    prop multi-handle       \ Main multi handle - manages all connections
    prop #transfers
    prop #messages
    prop #requests
    prop requests :ref %array
class;

class: request
    prop en
    prop easy-handle 
    prop on-completion-xt :xt   \ scoped to completed request
    prop streaming
    prop headers            \ slist, automatically freed on completion
    prop op                 \ output handle for callbacks, defaults to consoledev
    prop write-xt           \ ( cjson - ) , scoped to the request
    prop data               \ arbitrary data pointer available to write-xt
class;

1 aclient :construct ( request-array - )
    dup %array is? not abort" aclient:construct : request-array must be an array"
    requests ! ;

aclient :: init ( - )
    curl_multi_init multi-handle !
    multi-handle @ 0= abort" curl_multi_init failed" ;

create response$ 65536 allot
: .response  response$ lcount dump   response$ lcount type ;

private

fromC 4 1 callproc: standard-cb ( ptr size nmemb userdata -- bytes-written )
    \ userdata is the request
    {: ptr size nmemb req | cjson :}
    size nmemb * 0= if 0 exit then
    req {
        op-handle @ >r   op @ op-handle !
        ptr size nmemb * response$ lplace
        ptr size nmemb * parse-json to cjson
        write-xt @ if
            cjson write-xt @ catch .throw
        else
            cjson cjson. cr  
        then
        cjson delete-cjson
        r> op-handle !        
        ptr size nmemb * 
    } ;

: *request ( aclient - request )
    as>
        requests @ #items for
            i requests @ deref-index 
            dup -> en @ 0= if
                1 #requests +!
                request over construct
                { en on   me } unloop exit
            else drop then
        loop 
        -1 abort" Out of request objects" ;

: /request ( url len aclient - request ) 
    {: url len aclient | easy zurl[ 1024 ] :}
    url len zurl[ zplace
    url len type cr

    aclient *request {
        curl_easy_init to easy
        easy 0= abort" curl_easy_init failed"
        easy easy-handle !
        easy CURLOPT_SSL_VERIFYPEER 0 curl_easy_setopt
        easy CURLOPT_SSL_VERIFYHOST 0 curl_easy_setopt
        easy CURLOPT_URL zurl[ curl_easy_setopt
        easy CURLOPT_HTTP_VERSION 2 curl_easy_setopt 
        easy CURLOPT_WRITEFUNCTION standard-cb curl_easy_setopt  \ standard callback
        easy CURLOPT_WRITEDATA me curl_easy_setopt  \ set userdata = the request
        consoledev op ! 
    me } ;

: sendoff ( request aclient - )
    over { 
        streaming @ if
            easy-handle @ CURLOPT_TIMEOUT 0 curl_easy_setopt 
        then 
    }
    -> multi-handle @   swap -> easy-handle @   curl_multi_add_handle 
    ?dup if
        f" curl_multi_add_handle failed with err # %n" -1 -rot .abort
    then ;

: /get ( - ) easy-handle @ CURLOPT_HTTPGET 1 curl_easy_setopt ;
: /post ( - ) easy-handle @ CURLOPT_POST 1 curl_easy_setopt ;
: /put ( - ) easy-handle @ CURLOPT_CUSTOMREQUEST z" PUT" curl_easy_setopt ;
: /delete ( - ) easy-handle @ CURLOPT_CUSTOMREQUEST z" DELETE" curl_easy_setopt ;

public
: remove-request ( request aclient - )
    { -> en off   -1 #requests +! } ;
private

: handle-curl-msg ( curl-msg aclient - )
    {: msg aclient | handle req :}
    0 to req
    aclient as>
        ." curl msg result: " msg msg.result @ . cr

        msg msg.handle @ to handle
        requests @ #items for
            i requests @ deref-index 
            dup -> en @ 0<>
            over -> easy-handle @ handle = and if
                to req leave
            else drop then
        loop
        req 0= if
            msg msg.handle @ f" handle-curl-msg : Handle %n not found" type cr
            exit
        then
        req {
            sp@ >r 
            on-completion-xt @ ?dup if 
                execute 
            then
            r> sp!
            headers @ ?dup if curl_slist_free_all then
        } 
        req -> streaming @ not if 
            multi-handle @ handle curl_multi_remove_handle
            handle curl_easy_cleanup
            req aclient remove-request 
        then 
;

public

aclient :: process ( - )
    multi-handle @ -exit
    multi-handle @ #transfers curl_multi_perform ?dup if 
        f" curl_multi_perform failed with err # %n" -1 -rot .abort
    then
    begin
        multi-handle @ #messages curl_multi_info_read
    ?dup while
        \ ." incoming curl message..." cr
        me handle-curl-msg
    repeat ;

: setopt ( val opt - ) 
    swap easy-handle @ -rot curl_easy_setopt ;

: on-complete> ( - )
    r> on-completion-xt ! ;

: setheaders ( slist - )
    dup headers !   CURLOPT_HTTPHEADER setopt ;

: setfields ( payload len - )
    ." Fields: " 
    2dup type cr
    CURLOPT_POSTFIELDSIZE setopt   CURLOPT_COPYPOSTFIELDS setopt ;

continuation: get> ( ... url len aclient - ) ( ... - )
    ." GET: " cr
    ( xt ) {: url len aclient xt :}
    url len aclient /request { /get  xt execute   me } aclient sendoff ;

continuation: post> ( ... url len aclient - ) ( ... - )
    ." POST: " cr
    ( xt ) {: url len aclient xt :}
    url len aclient /request { /post  xt execute   me } aclient sendoff ;