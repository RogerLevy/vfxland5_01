\ Scene asset - serializable collection of actors (verbose conventional approach)

include ../../engineer/nib2.vfx
include asset.vfx

\ Scene format version for compatibility
1 constant SCENE-FORMAT-VERSION

class: scene-verbose
    is-a file-asset
    
    \ Scene properties
    256 nprop scene-name <cstring <save
    prop actor-count <int <save
    
    \ Runtime actor storage
    variable actors-data     \ Pointer to serialized actor data
    variable actors-size     \ Size of actor data in bytes
    
    static scene-allocator   \ Custom allocator XT for instantiation
class;

\ Default allocator - creates actors in current memory space
: default-scene-allocator ( len - a )
    allocate throw ;

\ Initialize scene allocator
' default-scene-allocator scene-verbose -> scene-allocator !

\ Asset protocol implementations
scene-verbose :: refresh ( - )
    \ Reload scene from filesystem
    me -> filename count file-exists? if
        me -> filename count r/o open-file throw >r
        
        \ Read format version
        cell allocate throw >r
        r@ cell r'@ read-file throw cell <> abort" REFRESH >> Invalid scene file format"
        r> @ SCENE-FORMAT-VERSION <> abort" REFRESH >> Unsupported scene format version"
        r> free throw
        
        \ Read scene metadata (name, count, etc.)
        me deserialize-metadata r@
        
        \ Read actor data as blob
        me load-actor-data r@
        
        r> close-file throw
        -1 me -> synchronized !
    else
        ." Warning: Scene file not found: " me -> filename count type cr
    then ;

scene-verbose :: save ( - )
    \ Save scene to filesystem  
    me -> filename count w/o create-file throw >r
    
    \ Write format version
    SCENE-FORMAT-VERSION r@ write-file throw
    
    \ Serialize scene metadata
    here me serbin here over - r@ write-file throw
    
    \ Write actor data if present
    me -> actors-data @ ?dup if
        me -> actors-size @ r@ write-file throw
    then
    
    r> close-file throw
    -1 me -> synchronized ! ;

scene-verbose :: load ( - )
    \ Deploy actors to runtime (stage)
    me -> actors-data @ ?dup if
        me -> scene-allocator @ deserbin
        \ Actor instantiation handled by deserializer
        ." Scene loaded: " me -> actor-count @ . ." actors" cr
    else
        ." Warning: No actor data to load" cr
    then ;

scene-verbose :: unload ( - )
    \ Remove actors from stage, free runtime resources
    clear-stage  \ Assuming this exists in supershow
    me -> actors-data @ ?dup if
        free throw
        0 me -> actors-data !
        0 me -> actors-size !
    then ;

scene-verbose :: use ( - )
    \ Make this scene the active scene
    me load ;

\ Scene-specific methods
scene-verbose :: capture-stage ( - )
    \ Serialize current stage actors to scene data
    here
    actors each> serbin  \ Serialize all active actors
    here over -          \ Calculate size
    
    \ Store the data  
    dup me -> actors-size !
    dup allocate throw me -> actors-data !
    me -> actors-data @ swap move
    
    \ Update metadata
    count-actors me -> actor-count ! ;

scene-verbose :: add-actor ( actor - )
    \ Add single actor to scene data (append to existing)
    \ Implementation would extend the actors-data blob
    ." ADD-ACTOR not yet implemented" cr ;

scene-verbose :: deserialize-metadata ( file-handle - )
    \ Read just the scene properties, not actor data
    {: fh | data-start :}
    here to data-start
    me serbin \ Serialize current scene to get size template
    here data-start - \ Get size needed
    
    data-start swap fh read-file throw
    data-start me swap deserbin drop ;

scene-verbose :: load-actor-data ( file-handle - )
    \ Read actor data as binary blob
    {: fh | remaining :}
    fh file-size throw fh file-position throw - to remaining
    remaining 0> if
        remaining allocate throw me -> actors-data !
        remaining me -> actors-size !
        me -> actors-data @ remaining fh read-file throw drop
    then ;

\ Utility words
: make-scene-verbose ( filename-a filename-len name-a name-len - scene )
    scene-verbose make [[
        scene-name place
        filename place
        0 actor-count !
        0 actors-data !
        0 actors-size !
        me refresh  \ Load from file if exists
    me ]] ;

: save-current-scene-verbose ( filename-a filename-len name-a name-len - )
    make-scene-verbose [[
        me capture-stage
        me save
    ]] ;

\ Example usage:
\ s" test-scene.dat" s" Test Scene" make-scene-verbose object my-scene
\ my-scene use
\ s" level1.dat" s" Level 1" save-current-scene-verbose