
\ Glypher-style AI experiment
\ Status: charging doesn't work yet
\ Verdict: some good ideas occurred, but the style isn't necessarily better
\ Decision: move on for now, give self permission to write AI however i want
\   on an individual basis.

\ Charging system:
\ - 4-level charge system (0-100 charge points) with escalating costs and power
\ - Charge delay prevents accidental charging - must hold key N frames before charging begins
\ - Resource protection - charging caps automatically to preserve 10+ energy, prevents player suicide
\ - Immediate pea shots - initial key press fires weak shot, holding continues to charge
\ - Cancel-on-redirect - pressing new direction key cancels current charge and fires pea shot
\ - Level progression feedback - displays bars next to owner (the ship)
\ - Dual firing modes - pea shooter (1 energy) vs charged shots (based on level)

require scripts\shot.vfx
require tween.vfx
require scripts\ship.vfx

class: turret
    actor derive-exp
    prop shooting
    prop shaking     \ 0 ~ 1.0
    prop aim
    prop atk
    prop dest-w 
    prop dest-atk 

    prop owner \ ship tracking pointer

borrow ship/ flash-ctr \ ship's recovery counter

turret.png 32 32 tileset turret.ts

: ang>bmp ( tileset n. - n )
    360. umod dup >r
    5. p/ p>s 36 mod tile r> 180. >= if hv| then ;

: flicker  gamelife @ 1 and if drop 0 then ;

variable charging
\ variable charge  \ moved to common.vfx
variable level
variable level-ctr
\ variable charge-key \ now a stack value

create dir-buttons 2 cells array[ 
    \ key , angle ,
    <l> , 0. ,
    <.> , 45. ,
    <,> , 90. ,
    <k> , 90. ,
    <m> , 135. ,
    <n> , 135. ,
    <j> , 180. ,
    <u> , 225. ,
    <i> , 270. ,
    <o> , 315. ,    
array] drop

: key@ @ ;
: ang@ cell+ @ ;

: shoot ( power speed. class - )
    aim @ 
    owner @ 0 0 from swap ( aim. class ) one as>
        swap ( aim. speed. ) vec vx 2!
        atk !
        act> ?cull ;

: pea ( atk - ) *shoot* 8. shot shoot ;
: fire-medium ( atk - ) *shoot* 8. missile1 shoot ;
: fire-large ( atk - ) *shoot* 8. missile2 shoot ;

: laser-physics
    owner @ [[ x 2@ vx 2@ 2+ ]] x 2!
    owner @ -> a @ a ! ;

: fire-thin ( atk - )
    *shoot*
    me 0 0 from
    me
    a @ 20. 5. *beam as>
        w @ dest-w ! 20. w !
        exponential ease-out w dest-w @ 0.25 tween
        owner ! atk !
        ['] laser-physics phys !
        act>
            80. l +!
            0.25 passed? -exit
            exponential2 ease-out w 0.0 0.1 tween
        act>
            0.1 passed? -exit
            unload ;

: fire-wide ( atk - )
    *shoot*
    me 0 0 from
    me
    aim @ 2000. 100. *beam as>
        owner ! atk !
        ['] laser-physics phys !
        w @ dest-w ! 1.0 w !
        atk @ dest-atk ! 0 atk !
        exponential3 ease-in w dest-w @ 0.25 tween
        act>
            0.25 passed? -exit
            dest-atk @ atk !
            exponential2 ease-out w 0.5 0.5 tween
        act>
            0 atk !            
        act>
            0.5 passed? -exit
            unload ;

( ease dir adr n2. len. - )        
create charge-levels 4 cells array[
    \ charge , cost , atk , xt ,
    10  , 0 , 0 ,   ' drop , 
    20  , 10 , 5 ,   ' fire-medium , \ medium projectile, damages one enemy
    30  , 25 , 10 ,  ' fire-large ,  \ large projectile, damages one enemy
    \ 25  , 10 , ' pea ,          \ moving laser projectile, damages multiple enemies as its travels
    40 ,  50 , 1 ,    ' fire-thin ,    \ thin laser cannon, damages multiple enemies over a brief time
    120 ,  100 , 100 ,  ' fire-wide ,   \ wide laser cannon, damages multiple enemies
array] drop

: level[] charge-levels [] ;
: charge@  @ ;
: cost@  cell+ @ ;
: atk@  cell+ cell+ @ ;
: fire-xt@  cell+ cell+ cell+ @ ;

charge-levels #items cell array bars
: /bars ( - )
    charge-levels #items 1 do
        bar one i bars [] !
    loop ;

\ Glypher-style code tools
\ ------------------------
aka -; -exit
aka ?; ?exit
0 value a@   \ A register
: a! to a@ ;
: d: : postpone cr here postpone literal postpone .name ;

: eacha ( xt array - ) ( - )
    \ Iterate on array, address of each item in "A"
    | arr xt |
    a@ >r
    arr -> data @ arr #items arr /item * bounds ?do
        i a!
        xt execute
    arr /item +loop
    r> a! ;

: each> r> swap eacha ;

: indexofa ( xt array - n ) ( - f )
    \ Iterate on array, address of each item in "A", until flag is true
    \ Then return the index of the current item
    \ Returns -1 if not found
    | arr xt |
    a@ >r
    arr -> data @ arr #items arr /item * bounds ?do
        i a!
        xt execute if
            i arr index unloop exit
        then
    arr /item +loop
    r> a!
    -1 ;

: indexof> r> swap indexofa ;

 
\ Begin AI section (Glypher style)
\ --------------------------------

: @key  a@ key@ ;
: @ang  a@ ang@ ;
: @charge a@ charge@ ;

\ charge mechanic
    \ charge level progression
        : ?reached ( n-n ) charge @ @charge >= if 1 + then ;
        : level-reached ( -n ) 0 charge-levels each> ?reached ;
        : level-pause 15 level-ctr ! ;
        d: +level 1 level +! level @ 0> -; 0.5 loud *snd-04* level-pause ;
        : ?+level level-reached level @ > -; +level ;
        d: /level -1 level ! ;
        d: -charge 0 charge ! 0 level-ctr ! charging off -1 level ! ;
        d: /charge charging on /level ;
    \ firing
        d: pay level @ level[] cost@ negate energy +! ;
        d: attack level @ level[] dup atk@ swap fire-xt@ execute ;
        d: fire level @ 0> if pay attack then -charge ;  \ level 0 is after the charge delay
    \ charging
        : afford? 0 max level[] cost@ energy @ swap - 10 >= ;
        : ?jam level-reached afford? ?; charge @ 1 - 0 max charge ! ;
        : shake ( n- ) s>p 60. p/ shaking ! ;
        d: +charge charge @ 1 + 120 min charge ! ?jam ?+level charge @ shake ;
        : go? level-ctr @ 0= ;
        : juice go? if +charge else -1 level-ctr +! then ;
        : flashing? -> flash-ctr @ 0 >= ;
        : ?cancel owner @ flashing? -; -charge r> drop ; 
        : cannon ( n-n ) charging @ -; ?cancel dup letgo? if fire else juice then ;
        : ?switch ( n-n ) dup pressed? -; /charge ;
        : ?charge dir-buttons each> @key ?switch cannon drop ;
\ aiming
    : cock ( p- ) aim ! shooting on ;
    : auto dir-buttons each> @key held? -; @ang cock ;
    : normal dir-buttons each> @key pressed? -; @ang cock ;   
    : ?aim automatic @ if auto else normal then ;
\ shooting
    \ : ?-auto <shoot> letgo? -; -task ;
    \ : /auto 0 t1 work> begin ?-auto 1 pea 0.12 pause again ;
    \ : ?pea <shoot> pressed? -; automatic @ if /auto else 1 pea then ;
    : ?pea shooting @ -; 1 pea shooting off ;
\ positioning
    : ?shake shaking @ dup 2rnd 3. 3. 2p* 2. 2. 2- x 2+! ;
    : spinfix a @ 360. umod 180. >= if 1. 1. x 2+! then ;
    : adhere [[ x 2@ vx 2@ 2+ ]] x 2! ;
    : orbit a @ 32. vec x 2+! ;
    : >owner owner @ adhere orbit ;
    : !pos >owner spinfix ?shake ;
    : !ang a @ p>f aim @ p>f 0.2e alerp f>p a ! ;
\ display
    : hide [[ -9999. -9999. x 2! ]] ;
    : show [[ at@ 2s>p x 2! ]] ;
    : bar[] bars [] @ ;
    : bar-spacing 0 bar.png bmph 1 + negate ;
    : bars-pos 13 -13 owner @ -> vx 2@ 2p>s 2+ ;
    : !bars 
        owner @ bars-pos from
        bars #items 1 do
            i bar[] i level @ <= if show else hide then
            bar-spacing +at 
        loop ;
    : !bmp turret.ts a @ ang>bmp flicker bmp ! ;
\ init
    turret-exp :: init
        !bmp /bars /level
        act> ?aim ?charge ?pea !ang !pos !bmp !bars ; 
