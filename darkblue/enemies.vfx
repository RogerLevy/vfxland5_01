\ ==============================================================================
\ Enemy Factory System - Living Factory Pattern
\ ==============================================================================
\
\ SUMMARY: Dynamic enemy class generation with hot-reload capability. Combines
\ Factory, Prototype, and Strategy patterns for rapid game development iteration.
\
\ USAGE:
\   enemy-class enemy1%           \ Create enemy class derived from ENEMY%
\   5 i/hp !                      \ Override default HP
\   enemy1% one                   \ Instantiate enemy
\
\ COMPILE-TIME BEHAVIOR:
\ - enemy-class creates new actor class derived from ENEMY%
\ - Copies all i/values (initial values) from base template
\ - Auto-detects sprite: enemy1% â†’ enemy1.png if available  
\ - Registers class in dictionary for hot-reload tracking
\
\ RUNTIME BEHAVIOR:
\ - Standard two-phase initialization: (init) then post-init
\ - (init) applies all i/values to instance variables
\ - post-init calls _post-init hook for custom behavior
\ - UPDATE ENEMIES reloads this file and re-initializes all active enemies
\
\ SPECIAL FEATURES:
\ - Live factory modification: i/values can be changed and applied to existing enemies
\ - Hybrid compile/runtime: classes can be modified at runtime, but maintain object identity
\ - Data-driven configuration: stats in table, behavior in _post-init hooks
\ - Hot-reload integration: automatic enemy updates during development
\ - Controlled inheritance: all enemies derive from single ENEMY% template
\
\ ==============================================================================

class: enemy%
    actor% derive
    is-a vessel%
class;
    
enemy% defaults [[
    enemy1.png bmp !
    1 hp !
    12. r !
    5. m !
    30 atk !
    20 bounty !
    80 firing-rate !
]]

object% :: post-init ( - ) ;

variable tris-next#  512 tris-next# !

private

dictionary enemy-classes
 
\ : regen 0.5 timer> 320 220 2rnd at enemy1% one drop ;
\ : tri-speed 0.2 rnd 0.05 + ;
\ : bias  me pos@ dist 160 / ;
\ : towards  me pos@ 2- ang 0.33 rnd center-pos bias + tri-speed + vec ;
\ : p/c  4 5 chance if player-pos else center-pos then ;

: burst ( n - )
    {: | c :}
    s" tri%" find-class to c
    next# @ >r 512 next# !
    for c one [[ 360. rnd .5 rnd .5 + vec vx 2+! ]] loop
    r> next# ! ;

: burst-ring ( n - )
    {: | c :}
    s" tri%" find-class to c
    next# @ >r 512 next# !
    for c one [[ 360. rnd .05 rnd .95 + vec vx 2+! ]] loop
    r> next# ! ;

enemy% :: kill
    me 0 0 from bounty @ burst-ring
    unload 
    ; \ regen ;

\ variable orbs-next#  4096 orbs-next# !

: ?shoot
    firing-rate @ -exit
    gamelife @ firing-rate @ mod ?exit
    next# @ >r
    4096 512 + next# !
    me 0 0 from s" orb%" find-class one [[
        player pos@ me pos@ 2- ang 1. vec vx 2!
    ]]
    \ next# @ orbs-next# !
    r> next# ! ;

enemy% :: damage ( n - )
    ?dup -exit
    ( atk ) negate hp +!
    0.7 loud *snd-06* \ *snd-05*
    hp @ 0 <= if die then ;
    
: ?bullets
    me beam laser-hit? if
        beam [[ atk @ you damage ]]
        exit
    then
    actives>
        player me fired? -exit
        you me rhit? if
            atk @ you damage
            unload
        then ;

: enemy-physics
    ?bullets vx 2@ x 2+!
    ?cull ;

: (init)
    ['] enemy-physics phys !
    act> ?shoot ;

enemy% :: init
    (init) me post-init ;

: auto-bitmap ( class - )
    {: c :} 
    c body> >name count -% f" %s.png" >pad find if
        execute c defaults 's bmp !
    else drop then ;

: register-enemy-class ( class - )
    dup body> >name enemy-classes lookup ! ;

: (include-enemy-class) ( -1 key$ a:val - -1 )
    rot >r drop count -% f" scripts\%s.vfx"
    ?included r> ;

: hot-reload-enemies ( - )
    ['] (include-enemy-class) enemy-classes walk-dictionary
    actives> enemy% is? -exit me init ;

\ Enemy table definition DSL
: val  bl parse evaluate ;
: str  bl parse ;
: for:  str f" enemy-class %s%%" evaluate  enemies~  defaults ;
: hp:  val hp ! ;
: atk:  val atk ! ;
: gold:  val bounty ! ;
: mass:  val m ! ;
: rad:  val r ! ;
: bmp:  val bmp ! ;

public

: enemy-class ( - <name> )
    {: | already? :}
    bl preparse ?hide-autoclass  \ autoclasses don't count
    preword find swap >body valid-class? and to already?
    actor-class 
    already? not if
        ." deriving enemy " classifier .name cr
        enemy% derive
        classifier .class
        classifier register-enemy-class
    then
    classifier auto-bitmap
    ['] noop classifier 's post-init ! ;

\ id            hp          atk         gold        rad         bmp                 spd         path
for: enemy1     hp: 1       atk: 10     gold: 20                                    \ spd: 1.0    path: path1 
for: enemy2     hp: 5       atk: 20     gold: 30                                    \ spd: 2.0    path: path2
for: bigbug     hp: 100     atk: 100    gold: 400   rad: 50.                        \ spd: 2.0    path: path2
for: vacuum     hp: 20      atk: 5      gold: 0                 bmp: enemy23.png

honing @ [if]
    hot-reload-enemies
[then]
