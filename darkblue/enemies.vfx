\ ==============================================================================
\ Enemy Factory System - Living Factory Pattern
\ ==============================================================================

(( 
<outdated-help>
SUMMARY: Dynamic enemy class generation with hot-reload capability. Combines
Factory, Prototype, and Strategy patterns for rapid game development iteration.

USAGE:
  enemy-class enemy1           \ Create enemy class derived from ENEMY
  5 i/hp !                      \ Override default HP
  enemy1 one                   \ Instantiate enemy

COMPILE-TIME BEHAVIOR:
- enemy-class creates new actor class derived from ENEMY
- Copies all i/values (initial values) from base template
- Auto-detects sprite: enemy1 â†’ enemy1.png if available  
- Registers class in dictionary for hot-reload tracking

RUNTIME BEHAVIOR:
- Standard two-phase initialization: (init) then post-init
- (init) applies all i/values to instance variables
- post-init calls _post-init hook for custom behavior
- UPDATE ENEMIES reloads this file and re-initializes all active enemies

SPECIAL FEATURES:
- Live factory modification: i/values can be changed and applied to existing enemies
- Hybrid compile/runtime: classes can be modified at runtime, but maintain object identity
- Data-driven configuration: stats in table, behavior in _post-init hooks
- Hot-reload integration: automatic enemy updates during development
- Controlled inheritance: all enemies derive from single ENEMY template
</outdated-help>
))

class: enemy-script
    actor-script derive
    :: default-path ( - path len )
        s" scripts/enemies" ;
class;

: reheat-enemies
    enemy-script reheat-default-dir ;

class: enemy
    actor derive
    works-with vessel
class;

\ aka enemies enemy

enemy defaults [[
    enemy1.png bmp !
    1 hp !
    12. r !
    5. m !
    30 atk !
    20 bounty !
    80 firing-rate !
]]

variable tris-next#  512 tris-next# !

private

\ : regen 0.5 timer> 320 220 2rnd at enemy1 one drop ;
\ : tri-speed 0.2 rnd 0.05 + ;
\ : bias  me pos@ dist 160 / ;
\ : towards  me pos@ 2- ang 0.33 rnd center-pos bias + tri-speed + vec ;
\ : p/c  4 5 chance if player-pos else center-pos then ;

: burst ( n - )
    {: | c :}
    s" tri" find-class to c
    next# @ >r 512 next# !
    for c one [[ 360. rnd .5 rnd .5 + vec vx 2+! ]] loop
    r> next# ! ;

: burst-ring ( n - )
    {: | c :}
    s" tri" find-class to c
    next# @ >r 512 next# !
    for c one [[ 360. rnd .05 rnd .95 + vec vx 2+! ]] loop
    r> next# ! ;

enemy :: kill
    me 0 0 from bounty @ burst-ring
    me unload 
    ; \ regen ;

\ variable orbs-next#  4096 orbs-next# !

: ?shoot
    firing-rate @ -exit
    gamelife @ firing-rate @ mod ?exit
    next# @ >r
    4096 512 + next# !
    me 0 0 from s" orb" find-class one [[
        player0 pos@ me pos@ 2- ang 1. vec vx 2!
    ]]
    \ next# @ orbs-next# !
    r> next# ! ;

enemy :: damage ( n - )
    ?dup -exit
    ( atk ) negate hp +!
    0.7 loud *snd-06* \ *snd-05*
    hp @ 0 <= if die then ;
    
: ?bullets
    me beam laser-hit? if
        beam [[ atk @ you damage ]]
        exit
    then
    actives>
        \ me projectile is? -exit
        player0 me fired? -exit
        you me rhit? if
            atk @ you damage
            me unload
        then ;

: enemy-physics
    ?bullets 
    vx 2@ x 2+!
    ?cull ;

enemy :: init
    ['] enemy-physics phys !
    act> ?shoot ;

: auto-bitmap ( - )
    classifier body> >name count f" %s.png" >pad find if
        execute defaults -> bmp !
    else drop then ;

enemy :derive ( parent derived - )
    2dup actor:derive
    nip auto-bitmap ;

\ : register-enemy-class ( class - )
\     dup body> >name enemy-classes lookup ! ;

\ : (include-enemy-class) ( 1 key$ a - 1 )
\     rot >r drop count f" scripts\%s.vfx"
\     ?included r> ;

\ : hot-reload-enemies ( - )
\     \ ['] (include-enemy-class) enemy-classes walk-dictionary
\     actives> enemy is? -exit me init ;

\ Enemy table definition DSL
: val  bl parse evaluate ;
: str  bl parse ;
: enm:  str f" class: %s enemy derive class;" evaluate  enemies/  defaults [[ ;
: hp:  val hp ! ;
: atk:  val atk ! ;
: gold:  val bounty ! ;
: mass:  val m ! ;
: rad:  val r ! ;
: bmp:  val bmp ! ;

public


." Loading enemy table..." cr
\ id            hp          atk         gold        rad         bmp                 spd         path
enm: enemy1     hp: 1       atk: 10     gold: 20                                    \ spd: 1.0    path: path1 
enm: enemy2     hp: 5       atk: 20     gold: 30                                    \ spd: 2.0    path: path2
enm: bigbug     hp: 100     atk: 100    gold: 400   rad: 50.                        \ spd: 2.0    path: path2
enm: vacuum     hp: 20      atk: 5      gold: 0                 bmp: enemy23.png
." Done loading enemy table." cr

honing @ [if]
    ." Hot-reloading enemies..." cr
    hot-reload-enemies
[then]
