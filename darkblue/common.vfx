\ Common classifiers
trait: vessel
    prop hp <int <save
    prop r  <fixed <save \ radius
    prop m  <fixed <save \ mass
    prop atk <int <save
    prop bounty <int <save
    prop firing-rate <int

    :: recovering? ( - flag ) 0 ;
trait;

trait: projectile
    prop r <fixed <save \ radius
    prop firer <ref _object
    prop atk <int <save
    prop a <fixed <save \ angle
    prop w <fixed \ width 
    prop l <fixed \ length
trait;

trait: pickup
    prop worth <int <save \ when non-zero, makes object a collectible source of energy
trait;

class: actor
    works-with vessel
    works-with projectile
    works-with pickup
    prop owner <ref actor
class;

\ Common protocols
_object :: damage ( n - ) negate hp +! ;
_object :: kill ( - ) me unload ;
: die  me kill ;

\ Common logic
actor :: serializable? ( - flag ) 
    \ TODO: this is fine because we know that all Dark Blue actors have firers,
    \ but if we wanted more modularity, implementing this across traits 
    \ would have to be accumulative, rather than destructive.
    actor:serializable? firer @ 0= and ;

: fired? ( firer actor - b )
    over 0= if 2drop 0 exit then
    -> firer @ = ;
 
\ Global variables
dummy value player0
variable energy  1000 energy !
variable automatic
variable charge

\ Input names
aka <start> <enter>

\ HUD
: hrs  gametime 360000000 m/ ;
: mins  gametime 60000000 m/ 60 mod ;
: secs  gametime 1000000 m/ 60 mod ;
: hud
    15 color
    \ 0 310 at s[ 480 8 / for space loop s] print    
    8 0 at
    charge @ energy @ f" %n   %n" print
    357 0 at secs mins hrs f" %02n:%02n:%02n" print ;

\ Common accessors
: radius r @ ;
: -radius radius negate ;

\ Scripting helpers
: pos@ -> x 2@ ;
: in? ( - f )
    x @ 0. r @ 2 * - gamew. r @ 2 * + within?
    y @ 0. r @ 2 * - gameh. r @ 2 * + within? and ;
: ?cull in? ?exit me unload ;
: center-pos  160. 120. ;
: player-pos  player0 pos@ ;
: chance ( dividend divisor -- f ) rnd swap < ;

: backdrop  0 0 at backdrop.png put ;
: (blank) show> backdrop ;
: blank 'show @ (blank) 10 for frame loop 'show ! ;

: >shout ( a len - ) 
    ['] evaluate catch drop ;

: shout" ( - <string>" )
    \ Late-bound execution; don't care if it succeeds.  
    \ Caller cannot pass params in directly.
    state @ if
        postpone (s") ", postpone >shout
    else
        '"' parse >syspad >shout
    then ; immediate

: from-top ( xratio. y. -- x. y. )
    >r gamew *  r> ;

: from-bottom ( xratio. y. -- x. y. )
    >r gamew *  r> gameh >. + ;

\ Music
bgm *bgm1* softice.ogg

