\ ------------------------------------------------------------------------------
\ Scripted Event System
\
\ These are scripted events - authored sequences that play out over time.
\ Not to be confused with event-driven programming!
\
\ This system provides a framework for creating and executing scripted game events
\ with hot-reload development support. Events are defined in separate .vfx files
\ and can be dynamically loaded, executed, and reloaded during development.
\
\ Core Components:
\ - event actor class: Base class for all scripted events
\ - :EVENT word: Creates named events that can be executed later
\ - DELAY mechanism: Allows events to wait for specified time periods
\ - RUN command: Development tool for testing events with hot-reload
\ - REQUIRE-EVENT: Loads event files from the events/ directory
\
\ Usage Pattern:
\ 1. Create event files in events/ directory using :EVENT to define them
\ 2. Use RUN <eventname> during development to test with hot-reload
\ 3. Use REQUIRE-EVENT <eventname> to load events into the game
\ 4. Events can spawn actor instances and set up delayed actions
\
\ Example Event File (events/intro.vfx):
\   :event 
\     100 100 at player spawn [[ ]]
\     3. delay
\     cr ." Welcome to the game!"
\   ;
\
\ Hot-Reload Development:
\ - RUN enables HONING mode for automatic reloading on F5
\ - All dependencies are reloaded when the event is modified
\ - Supports iterative event scripting and testing
\ ------------------------------------------------------------------------------

class: event
    actor derive
    prop delay-xt <xt
    prop delay-secs <fixed
    prop starting-xt <xt
    prop curves <ref _array
    32 nprop name$ <cstring
class;   

: (suicidal) ( - )
    act> 
        ." Event finished: " cr 
        me unload 
        me .summary cr ;

: start-event ( - )
    at@ 2>r
    at@ 2>. x 2! 
    (suicidal)
    \ sp@ cell+ >r
    starting-xt @ execute
    \ r> !sp
    2r> at ;

public

: delay ( secs. - )
    delay-secs ! r> delay-xt ! 
    act>
        delay-secs @ passed? -exit
        x 2@ 2.> at    \ restore pen from event's position
        (suicidal)      \ unless another delay (or act>) is called, event 
                        \ unalives itself on the next frame.
        delay-xt @ execute
;

: spawn ( class - actor )
    at@ 2>. x 2!  \ save pen in event's position 
    one ;

: >event-path  f" events\%s.vfx" ;

|| : check-event-file ( a len -- )
    >event-path file-exists? not if
        -1 abort" Event doesn't exist!"
    then ;
    
: require-event ( - <event> )
    {: | buf[ 256 ] :}
    bl parse buf[ place
    push-order
    buf[ count check-event-file
    buf[ count f" %s/" $private 
    buf[ count >event-path required
    pop-order ;

: run ( - <event> )
    \ Development tool; find, load and execute an event.
    \ Turns on honing, so everything it depends on is reloaded and f5 runs it
    \ again via honing as an xt.
    \ TODO: support saving the data stack in TRY for hone to recreate in
    \ honing mode; or just put that mechanism in RUN and HONE-EVENT.
    {: | a len :}
    bl parse to len to a
    a len check-event-file
    a len f" run %s" hone!
    a len f" %s/" $private 
    a len >event-path f" ?hone %s" evaluate
    a len >pad find if
        execute ( event ) as
    else
        drop -1 abort" Event entry point not found! did you forget :event ? "
    then ;

\ : clear ( - )
\     \ Clear the stage of other events, skipping ME.
\     0 0 at
\     actives> me you = ?exit me unload ;

|| : my-curve? ( fn len - )
    {: fn len :} 
    fn len me body>name strin?
    fn len s" curve" strin? and
    fn len '.' ending s" dat" s= and ;

|| : ?load-curve ( fn len - )
    {: fn len :} 
    fn len my-curve? if
        cr fn len type
        2 cells fn len array[ file, array] curves @ push
    then ;

|| : count-curve ( fn len - )
    my-curve? if 1 + then ;
    
: count-curves ( - n )
    0 s" events" ['] count-curve each-file ;

: load-curves ( - )
    count-curves cell stack instance curves !
    s" events" ['] ?load-curve each-file ;

|| : does-event ( - )
    does> ( template ) event one copy [[ start-event me ]] ;

: :event ( - ) ( ... - event )
    \ Create executable event named after the file being included.
    event currsourcename -path -ext public $object [[ 
        me body>name name$ place
        does-event :noname starting-xt ! ( load-curves ) 
    ]] ;

: curve[] ( n - )
    dup curves @ ?bounds not if drop exit then
    curves @ [] @ #items ? ;

event :: .summary ( actor - )
    11 push-attribute ." [ "
    me actor# dup 0 >= if ." #" . else drop me .name then
    cla @ .name
    name$ count type space
    ." at: " x 2@ 2.> swap . . 
    ." ] " pop-attribute ;

class: actor
    prop calltime <fixed <save
class;

: ready? ( actor - flag )
    [[ calltime @ time @ <= ]] ;