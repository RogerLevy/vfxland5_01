class: %tilemap
    is-a %drawable
    prop ta :ref %array
    prop w
    prop h
    prop ts :ref %tileset
    32 nprop name :cstring

    :: draw ( - ) 
        ts @ ?dup -exit 0 tile pile ! 
        ta @ 0 slot w 2@ drawbg ;
class;

class: %scene
    is-a %loadable
    prop tm-main :ref %tilemap
    prop troupe :ref %array
    
    : copy-to-stage ( actor - )
        stage-slot copy stage-init ;

    :: load ( - )
        \ Instantiate actors.    
        ['] copy-to-stage troupe @ each ;
class;

require %vfxland5%/cjson/cjson.vfx
require %vfxland5%/engineer/json.vfx
also cjson>>

: _load-tiled-tilemap-layer ( cjson - )
    {: layer | tileset :}
    layer "width" int@ w !
    layer "height" int@ h !
    cell array{ 
        layer "data" array-count for
            dup i int@ 1 - ,
        loop drop 
    array} ta !
;

: load-tiled-tilemap-simple ( cjson - tilemap )
    \ Load tilemap from Tiled cjson object.  Assumes it's in layer 0.
    \ Also assumes the first tileset is the tileset to be used by the tilemap.
    {: ctmj | tileset :}
    %tilemap instance { 
        ctmj "tilesets" array@ 0 object@ to tileset
        tileset if
            tileset "source" string@ -ext f" %s.ts" >pad find if
                >body ts ! 
            else drop then
        then
        ctmj "layers" array@ 0 object@ _load-tiled-tilemap-layer
    me } ;

: tiled-actor ( cjson - actor | 0 )
    {: obj :}
    obj "type" ['] string@ catch if 
        2drop 
        ." No 'type' property found in JSON object, skipping..." cr
        0 exit
    then 
    f" %%%s" >pad find if 
        execute make {
            obj "x" fixed@ 
                obj "width" ?fixed@ 2 / + x !
            obj "y" fixed@ 
                obj "height" ?fixed@ 2 / - y !
        me } exit
    else
        ( $ ) f" Class %$ not found, skipping..." type cr
        0 exit
    then ;

: load-tiled-actors-simple ( ctmj - array )
    \ Load objects from Tiled cjson object.  Assumes they're in layer 1.
    {: ctmj | tileset :}
    %actor object-array{
        ctmj "layers" array@ 1 object@ "objects" array-count for
            dup i object@ tiled-actor ?dup if .summary cr then
        loop drop 
    array} ;

: scene-from-tmj ( path len <name> - ) ( - scene )
    \ Load .tmj file.  Assumes tilemap is in layer 0, tileset 0 is the 
    \ tileset to be used by the tilemap, and objects are in layer 1.
    create %scene instance {
        load-json dup 
        load-tiled-tilemap-simple tm-main !
        load-tiled-actors-simple troupe !
    } ;

|| : set-meta ( bits index - ) metas-array @ swap slot dup @ rot or swap ! ;

|| : named? ( cjson name len - f ) 2>r "name" string@ 2r> s= ; 

also cjson>>

0 value _i
0 value _j

: cjson-each ( ... cjson zkey xt - ... ) ( ... cjson - ... )
    _i to _j
    -rot array-count for 
        i to _i
        2dup 2>r 2 rpick item@ swap execute 2r>
    loop 2drop ;

|| 0 value id 
: read-tsj-properties ( path len tileset - )
    {
        #tiles @ cell %array instance metas-array !
        load-json "tiles" 
        [: 
            dup "id" int@ to id
            "properties"
            [: s" solid" named? if $0F id set-meta then ;] cjson-each
        ;] cjson-each
        me tileset>metas 
    } ;
 
    \ {
    \     #tiles @ cell %array instance metas-array !
    \     load-json "tiles" array@ array-count for
    \         dup i object@ "properties" array@ array-count for
    \             dup i object@ 
    \             dup s" solid" named? if $0F j set-meta then
    \             drop
    \         loop drop
    \     loop drop
    \ } ;