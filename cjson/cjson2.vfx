library: cjson.dll

vocabulary cjson>>

fast{ 
private
0
    cell field next   \ &cjson
    cell field prev   \ &cjson
    cell field child  \ &cjson
    cell field jsontype   \ int
    cell field valuestring \ &zstring
    cell field valueint \ int
    2 cells field valuedouble \ double
    cell field namestring \ &zstring
constant s/cjson

public
: j@n  -> valueint @ ;
: j@f  -> valuedouble df@ ;
: j@p  -> valuedouble df@ f>p ;
: j@z  -> valuestring @ ;
: j@s  -> valuestring @ zcount ;
fast}


private

0 constant cJSON_Invalid
1 constant cJSON_False
2 constant cJSON_True
4 constant cJSON_NULL
8 constant cJSON_Number
16 constant cJSON_String
32 constant cJSON_Array
64 constant cJSON_Object

extern: void * STDCALL _cJSON_Parse@4( char * json_string );
extern: void * STDCALL _cJSON_ParseWithLength@8( char * json_string, int buffer_length );
extern: void * STDCALL _cJSON_GetObjectItem@8( void * json_obj, char * key );
extern: char * STDCALL _cJSON_GetStringValue@4( void * item );
extern: void STDCALL _cJSON_Delete@4( void * json_obj );
extern: void * STDCALL _cJSON_CreateObject@0();
extern: void * STDCALL _cJSON_AddStringToObject@12( void * obj, char * key, char * value );
extern: char * STDCALL _cJSON_Print@4( void * obj );
extern: char * STDCALL _cJSON_PrintUnformatted@4( void * obj );
extern: char * STDCALL _cJSON_Version@0();
extern: void STDCALL _cJSON_free@4( void * ptr );
extern: void * STDCALL _cJSON_GetArrayItem@8( void * array, int index );
extern: int STDCALL _cJSON_GetArraySize@4( void * array );
extern: void * STDCALL _cJSON_AddNumberToObject@16( void * obj, char * key, double num );
extern: double STDCALL _cJSON_GetNumberValue@4( void * item );
extern: bool STDCALL _cJSON_AddItemToObject@12( void * obj, char * zname, void * item );
extern: void * STDCALL _cJSON_CreateArray@0();
extern: bool STDCALL _cJSON_AddItemToArray@8( void * array, void * item );
extern: void * STDCALL _cJSON_CreateNumber@8( double num );
extern: void * STDCALL _cJSON_CreateString@4( char * zstr );

public : destroy-json ( cjson - ) _cJSON_Delete@4 ; 
private
: new-object ( - cjson ) _cJSON_CreateObject@0 ;
: new-array ( - cjson ) _cJSON_CreateArray@0 ;
: new-number ( f:n - item ) _cJSON_CreateNumber@8 ;
: new-string ( zstr - item ) _cJSON_CreateString@4 ;
: j>type ( cjson - n ) -> jsontype @ ;
: is-array? ( cjson - flag ) j>type cJSON_Array = ;
: serialize-cjson ( cjson - heap-zstr len ) _cJSON_Print@4 zcount ;
: cjson-free ( heap-zstr - ) _cJSON_free@4 ;

\ Generic add-item that works for both arrays and objects
: add-item ( item zkey|0 cjson - )
    dup is-array? if
        nip \ drop key
        swap _cJSON_AddItemToArray@8 drop
    else
        -rot swap _cJSON_AddItemToObject@12 drop
    then ;

: add-object ( cjson zkey|0 cjson - ) 
    add-item ;

: add-array ( cjson zkey|0 cjson - ) 
    add-item ;

: add-string ( zvalue zkey|0 cjson - ) 
    -rot swap _cJSON_AddStringToObject@12 drop ;

: add-float ( f:n zkey|0 cjson - ) 
    swap _cJSON_AddNumberToObject@16 drop ;

: add-fixed ( p zkey|0 cjson - )
    2>r p>f 2r> add-float ;

: add-int ( n zkey cjson - )
    2>r s>f 2r> add-float ;

: get-string-content ( cjson - a len )
    _cJSON_GetStringValue@4 zcount ;

: get-item ( cjson n|zkey - cjson )
    {: cjson key :} 
    cjson is-array? if 
        cjson key _cJSON_GetArrayItem@8
    else
        cjson key _cJSON_GetObjectItem@8
    then 
    ?dup 0= if key f" JSON key '%z' not found!" -1 -rot .abort then ;

: get-array ( zkey cjson - cjson ) get-item ;
: get-object ( zkey cjson - cjson ) get-item ;
: get-string ( zkey cjson - a len ) get-item j@s ;
: get-zstring ( zkey cjson - z$ ) get-item j@z ;
: get-float ( zkey cjson - f:n ) get-item j@f ;
: get-fixed ( zkey cjson - p ) get-item j@p ;
: get-int ( zkey cjson - n ) get-item j@n ;

public

: .json ( cjson - ) 
    serialize-cjson udup type _cJSON_free@4 ;

|| 0 value path 0 value len 0 value xt 0 value cjson
continuation: serjson> ( path len [xt] - ) ( cjson - ) 
    \ {: path len xt | cjson :}
    to xt to len to path
    new-object to cjson
    cjson xt ?execute 
    cjson serialize-cjson 
        udup path len write 
        cjson-free
    cjson destroy-json ;

aka j>j get-item 
: ?j>j ( json key - json'|0 ) ['] j>j catch if 2drop 0 then ;
: jlen ( jarray - n ) _cJSON_GetArraySize@4 ;
: jcount ( jarray - array-json n ) dup _cJSON_GetArraySize@4 ;

aka j>n get-int
aka j>f get-float
aka j>p get-fixed
aka j>s get-string
aka j>z get-zstring

: ?j>n ( json key - n|0 ) ['] j>n catch if 2drop 0 then ;
: ?j>f ( json key - f:n|f:0 ) ['] j>f catch if 2drop 0e then ;
: ?j>p ( json key - p|0 ) ['] j>p catch if 2drop 0 then ;
\ no ?J>S , too complicated
: ?j>z ( json key - z$|0 ) ['] j>z catch if 2drop 0 then ;

borrow array2>> enough-flag
|| : _jeach ( ... jsrc xt - ... ) ( ... jsrc key' - ... )
    swap jcount for 
        2dup 2>r 2 rpick rot execute 
        enough-flag @ if 2r> 2drop unloop exit then
        2r>
    loop 2drop ;

: jeach ( ... jsrc xt - ... ) ( ... jsrc key' - ... )
    2dup and 0= if 2drop exit then
    enough-flag @ >r
    enough-flag off
    ['] _jeach catch
    r> enough-flag !
    throw ;

|| : _jeach-fast ( ... jsrc xt - ... ) ( ... jitem - ... )
    swap jcount swap -> child @ swap ( xt child count )
    for 
        2dup 2>r  swap execute 
        enough-flag @ if 2r> 2drop unloop exit then
        2r> -> next @
    loop 2drop ;

: jeach-fast ( ... jsrc xt - ... ) ( ... jitem - ... )
    2dup and 0= if 2drop exit then    
    enough-flag @ >r
    enough-flag off
    ['] _jeach-fast catch
    r> enough-flag !
    throw ;

: parse-json ( a len - cjson ) _cJSON_ParseWithLength@8 ;
