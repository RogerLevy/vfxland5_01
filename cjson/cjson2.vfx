library: cjson.dll

vocabulary cjson>>

fast{ 
private
0
    cell field next   \ &cjson
    cell field prev   \ &cjson
    cell field child  \ &cjson
    cell field jsontype   \ int
    cell field valuestring \ &zstring
    cell field valueint \ int
    2 cells field valuedouble \ double
    cell field namestring \ &zstring
constant s/cjson

public
: j@n  -> valueint @ ;
: j@f  -> valuedouble df@ ;
: j@p  -> valuedouble df@ f>p ;
: j@z  -> valuestring @ ;
: j@s  -> valuestring @ zcount ;
fast}


private

0 constant cJSON_Invalid
1 constant cJSON_False
2 constant cJSON_True
4 constant cJSON_NULL
8 constant cJSON_Number
16 constant cJSON_String
32 constant cJSON_Array
64 constant cJSON_Object

extern: void * STDCALL _cJSON_Parse@4( char * json_string );
extern: void * STDCALL _cJSON_ParseWithLength@8( char * json_string, int buffer_length );
extern: void * STDCALL _cJSON_GetObjectItem@8( void * json_obj, char * key );
extern: char * STDCALL _cJSON_GetStringValue@4( void * item );
extern: void STDCALL _cJSON_Delete@4( void * json_obj );
extern: void * STDCALL _cJSON_CreateObject@0();
extern: void * STDCALL _cJSON_AddStringToObject@12( void * obj, char * key, char * value );
extern: char * STDCALL _cJSON_Print@4( void * obj );
extern: char * STDCALL _cJSON_PrintUnformatted@4( void * obj );
extern: char * STDCALL _cJSON_Version@0();
extern: void STDCALL _cJSON_free@4( void * ptr );
extern: void * STDCALL _cJSON_GetArrayItem@8( void * array, int index );
extern: int STDCALL _cJSON_GetArraySize@4( void * array );
extern: void * STDCALL _cJSON_AddNumberToObject@16( void * obj, char * key, double num );
extern: double STDCALL _cJSON_GetNumberValue@4( void * item );
extern: bool STDCALL _cJSON_AddItemToObject@12( void * obj, char * zname, void * item );
extern: void * STDCALL _cJSON_CreateArray@0();
extern: bool STDCALL _cJSON_AddItemToArray@8( void * array, void * item );
extern: void * STDCALL _cJSON_CreateNumber@8( double num );
extern: void * STDCALL _cJSON_CreateString@4( char * zstr );

public : destroy-json ( cjson - ) _cJSON_Delete@4 ; 
private
: new-object ( - cjson ) _cJSON_CreateObject@0 ;
: new-array ( - cjson ) _cJSON_CreateArray@0 ;
: new-number ( f:n - item ) _cJSON_CreateNumber@8 ;
: new-string ( zstr - item ) _cJSON_CreateString@4 ;
: j>type ( cjson - n ) -> jsontype @ ;
: is-array? ( cjson - flag ) j>type cJSON_Array = ;
: serialize-cjson ( cjson - heap-zstr len ) _cJSON_Print@4 zcount ;
: cjson-free ( heap-zstr - ) _cJSON_free@4 ;

\ Generic add-item that works for both arrays and objects
: add-item ( item zkey|0 cjson - )
    dup is-array? if
        nip \ drop key
        swap _cJSON_AddItemToArray@8 drop
    else
        -rot swap _cJSON_AddItemToObject@12 drop
    then ;

: add-object ( cjson zkey|0 cjson - ) 
    add-item ;

: add-array ( cjson zkey|0 cjson - ) 
    add-item ;

: add-string ( zvalue zkey|0 cjson - ) 
    -rot swap _cJSON_AddStringToObject@12 drop ;

: add-float ( f:n zkey|0 cjson - ) 
    swap _cJSON_AddNumberToObject@16 drop ;

: add-fixed ( p zkey|0 cjson - )
    2>r p>f 2r> add-float ;

: add-int ( n zkey cjson - )
    2>r s>f 2r> add-float ;

: get-string-content ( cjson - a len )
    _cJSON_GetStringValue@4 zcount ;

: ?get-item ( cjson n|zkey - cjson|0 )
    over is-array? if 
        _cJSON_GetArrayItem@8
    else
        _cJSON_GetObjectItem@8
    then ;

: get-item ( cjson n|zkey - cjson )
    {: cjson zkey :}
    cjson zkey ?get-item
    ?dup 0= if zkey f" JSON key '%z' not found!" -1 -rot .abort then ;

public

: .json ( cjson - ) 
    serialize-cjson udup type cjson-free ;

aka j>j get-item 
: ?j>j ( json key - json'|0 ) ?get-item ;

: j>n ( zkey cjson - n )      get-item j@n ;
: j>f ( zkey cjson - f:n )    get-item j@f ;
: j>p ( zkey cjson - p )      get-item j@p ;
: j>z ( zkey cjson - z$ )     get-item j@z ;
: j>s ( zkey cjson - a len )  get-item j@s ;

: ?j>n ( json key - n|0 )     ?get-item dup -exit j@n ;
: ?j>f ( json key - f:n|f:0 ) ?get-item ?dup if j@f else 0e then ;
: ?j>p ( json key - p|0 )     ?get-item dup -exit j@p ;
: ?j>z ( json key - z$|0 )    ?get-item dup -exit j@z ;
\ no ?J>S , too complicated

: jlen ( jarray - n ) _cJSON_GetArraySize@4 ;
: jcount ( jarray - array-json n ) dup _cJSON_GetArraySize@4 ;

borrow array2>> enough-flag
|| : _jeach ( ... jsrc xt - ... ) ( ... jsrc key' - ... )
    swap jcount for 
        2dup 2>r 2 rpick rot execute 
        enough-flag @ if 2r> 2drop unloop exit then
        2r>
    loop 2drop ;

: jeach ( ... jsrc xt - ... ) ( ... jsrc key' - ... )
    2dup and 0= if 2drop exit then
    enough-flag @ >r
    enough-flag off
    ['] _jeach catch
    r> enough-flag !
    throw ;

|| : _jeach-fast ( ... jsrc xt - ... ) ( ... jitem - ... )
    swap jcount swap -> child @ swap ( xt child count )
    for 
        2dup 2>r  swap execute 
        enough-flag @ if 2r> 2drop unloop exit then
        2r> -> next @
    loop 2drop ;

: jeach-fast ( ... jsrc xt - ... ) ( ... jitem - ... )
    2dup and 0= if 2drop exit then    
    enough-flag @ >r
    enough-flag off
    ['] _jeach-fast catch
    r> enough-flag !
    throw ;

: parse-json ( a len - cjson ) _cJSON_ParseWithLength@8 ;

|| 0 value path 0 value len 0 value xt 0 value cjson
continuation: serjson> ( path len [xt] - ) ( cjson - ) 
    to xt to len to path
    new-object to cjson
    cjson xt ?execute 
    cjson serialize-cjson 
        udup path len write 
        cjson-free
    cjson destroy-json ;