\ ------------------------------------------------------------------------------
\ Arrays (NIBS)
\ ------------------------------------------------------------------------------

trait: %iterable
    prop item-count :int <save
    :: vacate ( - ) 0 item-count ! ;
    :: slot>index ( a - i ) stub ; 
    :: index>slot ( i - a ) stub ; 
    :: index>val ( i - ? ) stub ;
    :: store-at ( val i - ) stub ;
    :: redim ( #items - ) stub ;
trait;

: nth ( iterable i - a ) swap index>slot ; 
: []@ ( iterable i - val ) swap index>val ;
: []! ( n iterable i - ) swap store-at ;
: #items ( iterable - n ) -> item-count @ ;

|| variable enough-flag
: enough  enough-flag on ;

|| : _eacha ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me index>slot xt you { execute }
        enough-flag @ if unloop exit then
    loop ;

%iterable :: eacha ( xt - ) ( ... a - ... )
    enough-flag @ >r
    enough-flag off
    ['] _eacha catch
    r> enough-flag !
    throw ;

|| : _each ( xt - ) ( ... a - ... )
    {: xt :}
    item-count @ for
        i me index>val xt you { execute }
        enough-flag @ if unloop exit then
    loop ;

%iterable :: each ( xt - ) ( ... ? - ... )
    enough-flag @ >r
    enough-flag off
    ['] _each catch
    r> enough-flag !
    throw ;

\ Essential queries:
%iterable :: empty? ( - bool )
    item-count @ 0= ;

: in-bounds? ( n iterable - b )
    { dup 0 item-count @ 1 - within? } ;

%iterable :: ?bounds ( n - n )
    me in-bounds? not abort" ?BOUNDS : Index out of range!" ;

\ Search operations:
%iterable :: find-index ( xt - n | -1 ) ( a - b )
    {: xt :}
    item-count @ for
        i me index>slot xt you { execute } if i unloop exit then
    loop -1 ;

%iterable :: slot>index ( item - n | -1 ) ( a - b )
    {: item :}
    item-count @ for
        i me index>val item = if i unloop exit then
    loop -1 ;

%iterable :: contains? ( item - bool )
    me slot>index 0 >= ;
      
\ Access helpers:
\ For object/reference types:
%iterable :: head-slot ( - a )
    0 me ?bounds me index>slot ;

%iterable :: tail-slot ( - a )
    item-count @ 1 - me ?bounds me index>slot ;

\ For value types:
%iterable :: head@ ( - ? )
    0 me ?bounds me index>val ;

%iterable :: tail@ ( - ? )
    item-count @ 1 - me ?bounds me index>val ;

\ Functional operations:
\ iterable :: map ( xt dest - )
\     {: xt dest :}
\     item-count @ for
\         i me [] xt you { execute }
\         i dest [] !
\     loop ;
\ 
\ iterable :: filter ( xt dest - count )
\     {: xt dest | j :}
\     item-count @ for
\         i me [] dup xt you { execute } if
\             j dest [] !
\             j 1+ to j
\         else drop then
\     loop j ;

trait: %lifo trait;
%lifo :: push ( item - ) stub ; 
%lifo :: pop ( - item ) stub ; 
%lifo :: push-copy ( a - ) stub ; 
%lifo :: pop-ref ( - a ) stub ; 
%lifo :: peek ( - item ) stub ;
%lifo :: peek-ref ( - a ) stub ;

trait: %fifo trait;
%fifo :: enqueue ( item - ) stub ;
%fifo :: dequeue ( - item ) stub ;
%fifo :: enqueue-copy ( a - ) stub ;
%fifo :: dequeue-ref ( - a ) stub ;
%fifo :: peek ( - item ) stub ;
%fifo :: peek-ref ( - item ) stub ;

class: %array
    is-a %iterable
    prop max-slots :int <save
    prop slot-size :int <save
    prop data :addr
class;

: s/slot ( array - n ) -> slot-size @ ;

2 %array :construct ( max-slots slot-size - )
    dup  0  16 1024 * 1024 *  within? not abort" Invalid array nth size" 
    2dup slot-size ! max-slots !
    max-slots @ item-count !
    align here data ! * allot&erase ;

%array :: slot>index ( a - i )
    data @ - slot-size @ / me ?bounds ;

%array :: index>slot ( i - a )
    me ?bounds slot-size @ * data @ + ;

%array :: index>val ( i - ? )
    me index>slot @ ;

%array :: store-at ( n i - )
    \ TODO: add support for other types.  in the meantime,
    \ use the old [] to store other number types. (defined in back.vfx)
    me index>slot ! ;

%array :: redim ( #slots - )
    dup max-slots @ = if drop exit then
    slot-size @ max-slots @ * >r   data @ >r
    ( #slots ) slot-size @ array:construct 
    r> data @   slot-size @ max-slots @ *   r> min   move ;

\ ------------------------------------------------------------------------------

class: %stack
    %array derive
    is-a %lifo
class;

2 %stack :construct ( max-slots slot-size - )
    dup  0  16 1024 * 1024 *  within? not abort" Invalid array nth size" 
    2dup slot-size ! max-slots !
    align here data ! * allot&erase ;

%stack :: push ( nth - )
    item-count @ max-slots @ = abort" Overflow."
    1 item-count +!  me tail-slot ! ;

%stack :: pop ( - nth )
    item-count @ 0= abort" Underflow."
    me tail-slot @  -1 item-count +! ;

%stack :: push-copy ( a - )
    item-count @ max-slots @ = abort" Overflow."
    1 item-count +!  ( a ) me tail-slot slot-size @ move ;

%stack :: pop-ref ( - a )
    item-count @ 0= abort" Underflow."
    me tail-slot  -1 item-count +! ;

%stack :: redim ( #slots - )
    dup max-slots @ = if drop exit then
    slot-size @ max-slots @ * >r   data @ >r
    ( #slots ) slot-size @ stack:construct 
    r> data @   slot-size @ max-slots @ *   r> min   move 
    item-count @ max-slots @ min item-count ! ;

\ ------------------------------------------------------------------------------

|| : _array{ ( slot-size array-class - array )
    0 -rot make { here data !  me } ;

: array{ ( slot-size - array )
    %array _array{ ; 

: array} ( array - array )
    { here data @ - slot-size @ /
    dup item-count ! max-slots !   me } ;

: pad-array  ( array count - array )
    \ Pad out an array being built, to given count
    over { data @ slot-size @ rot * + here - allot&erase } ;

redef : array ( max width - <name> )
    %array object ;

redef : stack ( max width - <name> )
    %stack object ;

class: %object-array
    %array derive
class;

%object-array :: index>val ( n - ? ) 
    me index>slot ;

: object-array ( n class <name> - )
    {: count class0 :}
    create count class0 sizeof %object-array make {
        count for
            class0 i me index>slot construct
        loop
    } ;

: move-range ( array1 array2 ofs1 ofs2 #slots - )
    {: arr1 arr2 ofs1 ofs2 n :}
    arr1 -> slot-size @ arr2 -> slot-size @ <> abort" MOVE-RANGE : Array nth sizes mismatch!" 
    ofs1 arr1 index>slot` ofs2 arr2 index>slot` arr1 -> slot-size @ n * move ;

%object-array :: store-at ( obj i - )
    index>slot me s/slot move ;

%object-array :: each ( xt - )
    me eacha ;

: object-array{ ( class - object-array )
    sizeof %object-array _array{ ;